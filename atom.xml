<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W.T.的博客</title>
  
  <subtitle>Every day to be a little better</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2021-03-09T08:18:31.899Z</updated>
  <id>/</id>
  
  <author>
    <name>Wang Ting</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js读取本地json跨域问题</title>
    <link href="/2021/02/26/js%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0json%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>/2021/02/26/js读取本地json跨域问题/</id>
    <published>2021-02-26T06:19:43.000Z</published>
    <updated>2021-03-09T08:18:31.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">jsonp解决跨域</blockquote><a id="more"></a><h1 id="问题">1. 问题</h1><p>使用ajax方式读取本地json文件，谷歌浏览器会提示跨域错误，导致获取不到json数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">"get"</span>,<span class="string">"plan.json"</span>);</span><br><span class="line">request.send(<span class="literal">null</span>);</span><br><span class="line">request.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(request.responseText);</span><br><span class="line">  <span class="built_in">console</span>.log(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Access to XMLHttpRequest at &#39;file:///Users/Learning/Downloads/index/plan.json&#39; from origin &#39;null&#39; has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.</code></p><h2 id="跨域问题">1.1. 跨域问题</h2><p>跨域是指从一个域名的网页去请求另一个域名的资源。由浏览器的同源策略造成的，是浏览器对<code>JavaScript</code>施加的安全限制。跨域的严格一点的定义是：只要 <code>协议，域名，端口</code>有任何一个的不同，就被当作是跨域</p><p><strong>所谓同源是指 域名，协议，端口均相同。</strong>这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据。</p><h3 id="Ajax为什么不能跨域？">1.1.1. Ajax为什么不能跨域？</h3><p>Ajax其实就是向服务器发送一个GET或POST请求，然后取得服务器响应结果，返回客户端。理论上这是没有任何问题的，只是服务端响应数据返回给浏览器的时候，浏览器根据响应头的Access-Control-Allow-Origin字段的值来判断是否有权限获取数据，一般情况下，服务器端如果没有在这个字段做特殊处理的话，跨域是没有权限访问的，所以响应数据被浏览器给拦截了，所以在ajax回调函数里是获取不到数据的。所以现在ajax跨域的问题可以转化为<code>数据怎么拿回客户端的问题</code></p><h3 id="js可以被任意网站加载">1.1.2. js可以被任意网站加载</h3><p>web页面可以加载放在任意站点的js、css、图片等资源，不会受到”跨域”的影响。将数据放到第三方站点的js中将数据带到客户端</p><p>getjs.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"get data"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>本地站点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"getjs.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> data = getData();</span></span><br><span class="line">    alert(data);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以显示</p><p><img src="/2021/02/26/js读取本地json跨域问题/js.png" alt></p><p>如何根据需要发送请求和获取请求的结果呢？来认识一下JSONP</p><h1 id="解决">2. 解决</h1><h2 id="JSONP">2.1. JSONP</h2><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。它允许在服务器端集成<code>&lt;script&gt;</code>返回至客户端，通过javascript callback的形式实现跨域访问</p><p><code>仅适用于GET请求</code></p><p><code>&lt;script&gt;</code> 标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件，而并不要求同源。</p><p>和服务端约定好一个函数名，当请求文件的时候，服务端返回一段 JavaScript。这段 JavaScript 调用了我们约定好的函数，并且将数据当做参数传入。JSON 的数据格式和 JavaScript 语言里对象的格式正好相同。所以在我们约定的函数里面可以直接使用这个对象。</p><h3 id="使用">2.1.1. 使用</h3><p>plan.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">createTable(&#123;</span><br><span class="line">    "plan":[</span><br><span class="line">        &#123;"index":"1","site":"AAA","content":"content1","person":"A1"&#125;,</span><br><span class="line">        &#123;"index":"2","site":"BBB","content":"content2","person":"A2"&#125;,</span><br><span class="line">        &#123;"index":"3","site":"CCC","content":"content3","person":"A3"&#125;,</span><br><span class="line">        &#123;<span class="attr">"index"</span>:<span class="string">"4"</span>,<span class="attr">"site"</span>:<span class="string">"DDD"</span>,<span class="attr">"content"</span>:<span class="string">"content4"</span>,<span class="attr">"person"</span>:<span class="string">"A4"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>本地站点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">createTable</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--src ? 之前为文件地址，? 之后为回调函数callback名称，回调函数可以简写为cb，然后回调函数名称要与JSON文件中的名称一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"plan.json?cb=createTable"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示</p><p><img src="/2021/02/26/js读取本地json跨域问题/console.png" alt></p><h3 id="流程">2.1.2. 流程</h3><p><img src="/2021/02/26/js读取本地json跨域问题/seq.png" alt></p><h3 id="注意">2.1.3. 注意</h3><ul><li>一定要在json文件的外部用函数名+（）套住；</li><li>js中的回调函数一定要与json中函数名相同；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;jsonp解决跨域&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>网页实现元素轮播</title>
    <link href="/2021/02/25/%E7%BD%91%E9%A1%B5%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E8%BD%AE%E6%92%AD/"/>
    <id>/2021/02/25/网页实现元素轮播/</id>
    <published>2021-02-25T05:39:57.000Z</published>
    <updated>2021-03-01T08:52:45.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">CSS3 animation，transform</blockquote><a id="more"></a><h1 id="animation">1. animation</h1><h2 id="浏览器支持">1.1. 浏览器支持</h2><p>Internet Explorer 10、Firefox 以及 Opera 支持 animation 属性。</p><p>Safari 和 Chrome 支持替代的 -webkit-animation 属性。</p><p>Internet Explorer 9 以及更早的版本不支持 animation 属性。</p><h2 id="语法">1.2. 语法</h2><p><code>animation: name duration timing-function delay iteration-count direction;</code></p><h3 id="animation-name">1.2.1. animation-name</h3><p>规定需要绑定到选择器的 keyframe 名称</p><h4 id="keyframe">1.2.1.1. @keyframe</h4><p><code>@keyframes animationname {keyframes-selector {css-styles;}}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> mymove</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">top</span>:<span class="number">50px</span>&#125;</span><br><span class="line">100% &#123;<span class="attribute">top</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="浏览器支持-1">1.2.1.1.1. 浏览器支持</h5><p>目前浏览器都不支持 @keyframes 规则。</p><p>Firefox 支持替代的 @-moz-keyframes 规则。</p><p>Opera 支持替代的 @-o-keyframes 规则。</p><p>Safari 和 Chrome 支持替代的 @-webkit-keyframes 规则。</p><h5 id="说明">1.2.1.1.2. 说明</h5><p>创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。</p><p>在动画过程中，您能够多次改变这套 CSS 样式。</p><p>以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。</p><p>0% 是动画的开始时间，100% 动画的结束时间。</p><p>为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><p>请使用动画属性来控制动画的外观，同时将动画与选择器绑定。</p><h3 id="animation-duration">1.2.2. animation-duration</h3><p>规定完成动画所花费的时间，以秒或毫秒计</p><h3 id="animation-timing-function">1.2.3. animation-timing-function</h3><p>规定动画的速度曲线</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>linear</td><td>动画从头到尾的速度是相同的</td></tr><tr><td>ease</td><td>默认。动画以低速开始，然后加快，在结束前变慢</td></tr><tr><td>ease-in</td><td>动画以低速开始</td></tr><tr><td>ease-out</td><td>动画以低速结束</td></tr><tr><td>ease-in-out</td><td>动画以低速开始和结束</td></tr><tr><td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值</td></tr></tbody></table><h3 id="animation-delay">1.2.4. animation-delay</h3><p>规定在动画开始之前的延迟</p><h3 id="animation-iteration-count">1.2.5. animation-iteration-count</h3><p>规定动画应该播放的次数</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><em>n</em></td><td>定义动画播放次数的数值</td></tr><tr><td>infinite</td><td>规定动画应该无限次播放</td></tr></tbody></table><h3 id="animation-direction">1.2.6. animation-direction</h3><p>规定是否应该轮流反向播放动画</p><p>如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。</p><p><strong>注释：</strong>如果把动画设置为只播放一次，则该属性没有效果。</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">normal</td><td align="left">默认值。动画应该正常播放。</td></tr><tr><td align="left">alternate</td><td align="left">动画应该轮流反向播放。</td></tr></tbody></table><h1 id="应用">2. 应用</h1><p>文字从右往左移动</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">            *&#123;</span><br><span class="line">                <span class="attribute">position</span>: relative;</span><br><span class="line">            &#125;</span><br><span class="line">            @<span class="keyword">keyframes</span> move &#123;</span><br><span class="line">                <span class="selector-tag">from</span>&#123;<span class="attribute">left</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">                <span class="selector-tag">to</span>&#123;<span class="attribute">left</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> move&#123;</span><br><span class="line">                <span class="selector-tag">from</span>&#123;<span class="attribute">left</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">                <span class="selector-tag">to</span>&#123;<span class="attribute">left</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-tag">div</span>&#123;</span><br><span class="line">                <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">                <span class="attribute">animation</span>: move <span class="number">5s</span> linear infinite;</span><br><span class="line">                <span class="attribute">-webkit-animation</span>: move <span class="number">5s</span> linear infinite;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;span&gt;文字&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;CSS3 animation，transform&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>数据结构08-排序</title>
    <link href="/2021/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"/>
    <id>/2021/02/08/数据结构-排序/</id>
    <published>2021-02-08T14:54:29.000Z</published>
    <updated>2021-05-22T05:08:52.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">b</blockquote><a id="more"></a><p>视频讲解，习题讲解，思维导图，PPT资源</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;b&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构07-查找</title>
    <link href="/2021/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"/>
    <id>/2021/02/08/数据结构-查找/</id>
    <published>2021-02-08T14:54:24.000Z</published>
    <updated>2021-05-22T05:08:46.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">b</blockquote><a id="more"></a><p>视频讲解，习题讲解，思维导图，PPT资源</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;b&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构06-图</title>
    <link href="/2021/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>/2021/02/08/数据结构-图/</id>
    <published>2021-02-08T14:54:19.000Z</published>
    <updated>2021-06-05T19:50:25.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">图的概念，图的存储【邻接矩阵，邻接表】，图的基本操作，图的遍历【DFS，BFS】，最小生成树，最短路径，拓扑排序，关键路径</blockquote><a id="more"></a><p>视频讲解，习题讲解，思维导图，PPT资源</p><p>链接: <a href="https://pan.baidu.com/s/1fRViwPYYriuezJANg2uJmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1fRViwPYYriuezJANg2uJmA</a>  密码: 7a4f</p><h1 id="图的基本概念">1. 图的基本概念</h1><h2 id="图的定义">1.1. 图的定义</h2><p>图G由顶点集V和边集E组成，记为G = (V, E)，其中V(G)表示图G中顶点的有限非空集；E(G) 表示图G中顶点之间的关系(边)集合。若V = {v<sub>1</sub>, v<sub>2</sub>, … , v<sub>n</sub>}，则用|V|表示图G中顶点的个数，也称图G的阶，</p><p>E= {(u, v) | u$\epsilon $V, v$\epsilon $V}，用|E|表示图G中边的条数。</p><p>注意：线性表可以是空表，树可以是空树，但图不可以是空，即<code>V一定是非空集</code></p><h2 id="图逻辑结构的应用">1.2. 图逻辑结构的应用</h2><p>车站路线图</p><p>铁路路线图</p><p>地图</p><p>微信好友关系网——无向图</p><p>微博粉丝关系网——有向图</p><p><img src="/2021/02/08/数据结构-图/weixin.png" alt></p><h2 id="图分类">1.3. 图分类</h2><h3 id="无向图">1.3.1. 无向图</h3><p>若E是<font color="#f00">无向边</font>(简称边)的有限集合时，则图G为<font color="#f00">无向图</font>。边是顶点的无序对，记为(v, w)或(w, v)，因为(v, w) = (w, v)，其中v、w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。</p><p><img src="/2021/02/08/数据结构-图/unorder.png" alt></p><p>G<sub>2</sub> = (V<sub>2</sub>, E<sub>2</sub>)</p><p>V<sub>2</sub> ={A,B,C,D,E}</p><p>E<sub>2</sub> = {(A, B), (B, D), (B, E), (C, D), (C, E), (D, E)}</p><h3 id="有向图">1.3.2. 有向图</h3><p>若E是<font color="#f00">有向边</font>(也称弧)的有限集合时，则图G为有向图。 弧是顶点的有序对，记为&lt;v, w&gt;，其中v、w是顶点，v称为弧尾，w称为弧头，&lt;v,w&gt;称为从顶点v到顶点w的弧，也称v邻接到<em>w</em>，或w邻接自v。</p><p>&lt;v, w&gt; ≠ &lt;w, v&gt;</p><p><img src="/2021/02/08/数据结构-图/order.png" alt></p><p>G<sub>1</sub> = (V<sub>1</sub>, E<sub>1</sub>)</p><p>V<sub>1</sub> = {A, B, C, D, E} D </p><p>E<sub>1</sub> = {&lt;A, B&gt;, &lt;A, C&gt;, &lt;A, D&gt;, &lt;A, E&gt;, &lt;B, A&gt;, &lt;B, C&gt;, &lt;B, E&gt;, &lt;C, D&gt;}</p><h3 id="简单图">1.3.3. 简单图</h3><ol><li>不存在重复边; </li><li>不存在顶点到自身的边</li></ol><p><font color="#f00">数据结构课程只探讨 “简单图”</font></p><p><img src="/2021/02/08/数据结构-图/simple.png" alt></p><h3 id="多重图">1.3.4. 多重图</h3><p>图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联， 则G为多重图</p><p><img src="/2021/02/08/数据结构-图/duoyu.png" alt></p><h2 id="顶点的度、入度、出度">1.4. 顶点的度、入度、出度</h2><h3 id="无向图-1">1.4.1. 无向图</h3><p>顶点v的度是指依附于该顶点的边的条数，记为TD(<em>v</em>)。 </p><p>在具有n个顶点、e条边的无向图中，$\sum_{i=1}^{n}$ TD(v<sub>i</sub>)=2e</p><p>即无向图的全部顶点的度的和等于边数的2倍</p><h3 id="有向图-1">1.4.2. 有向图</h3><p>入度是以顶点v为终点的有向边的数目，记为ID(v); </p><p>出度是以顶点v为起点的有向边的数目，记为OD(v)。 </p><p>顶点v的度等于其入度和出度之和，即TD(v) = ID(v) + OD(v)。</p><p>在具有<em>n</em>个顶点、<em>e</em>条边的有向图中，$\sum_{i=1}^{n}$ID(v<sub>i</sub>) =$\sum_{i=1}^{n}$OD(v<sub>i</sub>) = e</p><h2 id="顶点-顶点的关系描述">1.5. 顶点-顶点的关系描述</h2><p>路径——顶点v<sub>p</sub>到顶点v<sub>q</sub>之间的一条路径是指顶点序列，V<sub>p</sub>，V<sub>i<sub>1</sub></sub>，V<sub>i<sub>2</sub></sub>，…，V<sub>i<sub>m</sub></sub>，V<sub>q</sub></p><p>回路——第一个顶点和最后一个顶点相同的路径称为回路或环 </p><p>简单路径——在路径序列中，顶点不重复出现的路径称为简单路径 </p><p>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。 路径长度——路径上边的数目</p><p>点到点的距离——从顶点<em>u</em>出发到顶点<em>v</em>的<code>最短路径</code>若存在，则此路径的长度称为从u到v的距离。 若从u到v根本不存在路径，则记该距离为无穷∞)。</p><p><code>无向图</code>中，若从顶点v到顶点w有路径存在，则称v和w是<code>连通</code>的 </p><p><code>有向图</code>中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<code>强连通</code>的</p><h2 id="连通图">1.6. 连通图</h2><p>若<code>无向图</code>中任意两个顶点都是连通的，则称图G为<code>连通图</code>，否则称为<code>非连通图</code>。</p><p>常见考点: </p><p>对于n个顶点的无向图G， 若G是连通图，则最少有 n-1 条边</p><p>若G是非连通图，则最多可能有 𝐶$_{n-1}^{2}$条边</p><h2 id="强连通图">1.7. 强连通图</h2><p>若<code>有向图</code>中任何一对顶点都是<code>强连通</code>的，则称此图为<code>强连通图</code>。</p><p>常见考点：</p><p>对于n个顶点的有向图G， 若G是强连通图，则最少有n条边(形成回路)</p><h2 id="研究图的局部——子图">1.8. 研究图的局部——子图</h2><p>设有两个图 G= (V, E)和 G<sup>‘</sup> = (V<sup>‘</sup>, E<sup>‘</sup>)，若V<sup>‘</sup>是V的子集，且E<sup>‘</sup>是E的子集，则称G<sup>‘</sup>是G的子图。</p><p><font color="#f00">并非V和E的任何子集都能构成G的子图，E的子集中某些边关联的顶点可能不在V的子集中</font></p><p>若有满足 V(G<sup>‘</sup>) = V(G)的子图G<sup>‘</sup>，则称其为G的生成子图</p><p><font color="#f00">并非任意挑几个点、几条边都能构成子图</font></p><p><img src="/2021/02/08/数据结构-图/zitu.png" alt></p><h2 id="连通分量">1.9. 连通分量</h2><p>无向图中的极大连通子图称为连通分量。</p><p>极大连通子图：子图必须连通，且包含<code>尽可能多</code>的顶点和边</p><p><img src="/2021/02/08/数据结构-图/fenliang.png" alt></p><h2 id="强连通分量">1.10. 强连通分量</h2><p>有向图中的极大强连通子图称为有向图的强连通分量</p><p>极大强连通子图：子图必须强连通，同时强连通分量保留<code>尽可能多</code>的边</p><p><img src="/2021/02/08/数据结构-图/qiang.png" alt></p><h2 id="生成树">1.11. 生成树</h2><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。</p><p>极小连通子图：边尽可能的少，但要保持连通</p><p>若图中顶点数为n，则它的生成树含有 <code>n-1</code> 条边。对生成树而言，若砍去它的一条边，则会变成非连通 图，若加上一条边则会形成一个回路。</p><h2 id="生成森林">1.12. 生成森林</h2><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p><p><img src="/2021/02/08/数据结构-图/forest.png" alt></p><h2 id="边的权、带权图-网">1.13. 边的权、带权图/网</h2><p>给各边赋予一个权 值——实际距离</p><p>给各边赋予一个数 值——转发概率</p><p>边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。 </p><p>带权图/网——边上带有权值的图称为带权图，也称网。</p><p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p><p>带权图的应用举例：地图导航——距离最短，地图导航——收费最低</p><h2 id="几种特殊形态的图">1.14. 几种特殊形态的图</h2><h3 id="无向完全图">1.14.1. 无向完全图</h3><p>无向图中任意两个顶点之间都存在边</p><p>若无向图的顶点数|V|=n，则 |E| ∈ [0, C$_{n}^{2}$] = [0, n(n–1)/2]</p><h3 id="有向完全图">1.14.2. 有向完全图</h3><p>有向图中任意两个顶点之间都存在方向相反的两条弧</p><p>若有向图的顶点数|V|=n，则 |<em>E</em>| ∈ [0, 2C$_{n}^{2}$] = [0, n(n–1)]</p><h3 id="稀疏图">1.14.3. 稀疏图</h3><p>边数很少的图</p><h3 id="稠密图">1.14.4. 稠密图</h3><p>边数很多的图</p><p>没有绝对的界限，一般来说|E| $\geq$ |V|log|V|时，可以将G视为稠密图</p><h3 id="树">1.14.5. 树</h3><p>不存在回路，且连通的无向图</p><p>n个顶点的树，必有n-1条边。 </p><p>常见考点：n个顶点的图，若 |E|&gt;n-1，则一定有回路</p><p><img src="/2021/02/08/数据结构-图/shu.png" alt></p><h3 id="有向树">1.14.6. 有向树</h3><p>一个顶点的入度为0、其余顶点的 入度均为1的有向图，称为有向树。</p><p><img src="/2021/02/08/数据结构-图/youshu.png" alt></p><h1 id="图的存储">2. 图的存储</h1><h2 id="邻接矩阵法-数组">2.1. 邻接矩阵法(数组)</h2><p>数组实现的顺序存储，空间复杂度高，不适合存储稀疏图</p><h3 id="结构体">2.1.1. 结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点数目最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">//权值无穷大</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 2&lt;&lt;30</span></span><br><span class="line"><span class="comment">//顶点数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> char VertexType</span></span><br><span class="line"><span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int EdgeType</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//顶点表</span></span><br><span class="line">  VertexType Vex[MaxVertexNum];</span><br><span class="line">  <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">  EdgeType Edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">  <span class="comment">//图的当前顶点树和边数</span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-图/juzhen.png" alt></p><h3 id="度计算">2.1.2. 度计算</h3><p>第i个结点的出度 = 第i行的非零元素个数 </p><p>第i个结点的入度 = 第i列的非零元素个数</p><p>第i个结点的度 = 第i行、第i列的非零元素个数之和</p><p>邻接矩阵法求顶点的度/出度/入度的时间复杂度为 O(|V|)</p><h3 id="邻接矩阵法的性能分析">2.1.3. 邻接矩阵法的性能分析</h3><p>空间复杂度：O(|V|<sup>2</sup>) ——只和顶点数相关，和实际的边数无关 </p><p>适合用于存储稠密图 </p><p>无向图的邻接矩阵是对称矩阵，可以压缩存储(只存储上三角区/下三角区)</p><h3 id="对称矩阵">2.1.4. 对称矩阵</h3><p><img src="/2021/02/08/数据结构-图/aij.png" alt></p><p>若 n 阶方阵中任意一个元素 a<sub>i,j</sub> 都有 a<sub>i,j</sub> = a<sub>j,i</sub> 则该矩阵为对称矩阵</p><p>普通存储：n*n 二维数组 </p><p>压缩存储策略：只存储主对角线+下三角区(或主对角线+上三角区)</p><p>策略:只存储主对角线+下三角区 按行优先原则将各元素存入一维数组中。</p><table><thead><tr><th>B[0]</th><th>B[1]</th><th>B[2]</th><th>B[3]</th><th>…</th><th></th><th>B[$\frac{(1+n)*n}{2}$-1]</th></tr></thead><tbody><tr><td>a<sub>1,1</sub></td><td>a<sub>2,1</sub></td><td>a<sub>2,2</sub></td><td>a<sub>3,1</sub></td><td>…</td><td>a<sub>n,n-1</sub></td><td>a<sub>n,n</sub></td></tr></tbody></table><p>思考:</p><ol><li><p>数组大小应为多少? </p><p>$\frac{(1+n)*n}{2}$</p></li><li><p>站在程序员的角度，对称矩阵压缩存储后怎样才能方便使用?</p><p>可以实现一个“映射”函数</p><p>矩阵下标 -&gt; 一维数组下标</p></li><li><p>按行优先的原则，a<sub>i,j</sub> 是第几个元素?</p><p>[1+2+···+(i-1)] + j  -&gt; 第 $\frac{i(i-1)}{2}$ + j 个元素 -&gt; k= $\frac{i(i-1)}{2}$+ j − 1</p></li><li><p>按行优先的原则，a<sub>j,i</sub>是第几个元素?</p><p>ai,j = aj,i (对称矩阵性质)</p><p>k= $\frac{j(j-1)}{2}$ + 𝑖 − 1</p></li></ol><p>故压缩到一维数组时k=$\left{\begin{matrix}<br>\frac{i(i-1)}{2}+j-1, i\geq j (下三角区和主对角线元素)  &amp; \<br>  \frac{j(j-1)}{2}+i-1, i&lt;j (上三角区元素a_{i,j} =a_{j,i})&amp;<br>\end{matrix}\right.$</p><h3 id="邻接矩阵法的性质">2.1.5. 邻接矩阵法的性质</h3><p>设图<em>G</em>的邻接矩阵为A(矩阵元素为0/1)，则A<sup>n</sup>的元素A<sup>n</sup> [i] [j]等于由顶点i到顶点j的长度为n的路径的数目</p><p><img src="/2021/02/08/数据结构-图/ajie.png" alt></p><p><img src="/2021/02/08/数据结构-图/an.png" alt></p><h3 id="邻接矩阵法要点回顾">2.1.6. 邻接矩阵法要点回顾</h3><ul><li>如何计算指定顶点的度、入度、出度(分无向图、有向图来考虑)?时间复杂度如何?</li><li>如何找到与顶点相邻的边(入边、出边)?时间复杂度如何?</li><li>如何存储带权图?</li><li>空间复杂度——O(|V|<sup>2</sup>)，适合存储稠密图</li><li>无向图的邻接矩阵为对称矩阵，如何压缩存储?</li><li>设图G的邻接矩阵为A(矩阵元素为0/1)，则A<sup>n</sup>的元素A<sup>n</sup>[i] [j]等于由顶点i到顶点j的长度为n 的路径的数目</li></ul><h2 id="邻接表法-顺序-链式存储">2.2. 邻接表法(顺序+链式存储)</h2><h3 id="结构体-1">2.2.1. 结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">  <span class="keyword">int</span> adjvex;</span><br><span class="line">  <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">//边权值</span></span><br><span class="line">  <span class="comment">//InfoType info</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">//顶点数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> char VertexType</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//顶点信息</span></span><br><span class="line">  VertexType data;</span><br><span class="line">  <span class="comment">//指向第一条依附该结点的弧的指针</span></span><br><span class="line">  ArcNode *first;</span><br><span class="line">&#125;VNode,AdjList[MaxVertxNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//邻接表</span></span><br><span class="line">  AdjList vertices;</span><br><span class="line">  <span class="comment">//顶点数，弧数</span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-图/wulist.png" alt></p><h3 id="对比-树的孩子表示法">2.2.2. 对比:树的孩子表示法</h3><p>孩子表示法：顺序存储各个节点，每个结点中保存孩子链表头指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">  <span class="keyword">int</span> child;</span><br><span class="line">  <span class="comment">//下一个孩子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//第一个孩子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">  <span class="keyword">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-图/shuangqi.png" alt><img src="/2021/02/08/数据结构-图/shuanglian.png" alt></p><h3 id="邻接表的性能分析">2.2.3. 邻接表的性能分析</h3><p><img src="/2021/02/08/数据结构-图/wulist.png" alt></p><p><img src="/2021/02/08/数据结构-图/youlist.png" alt></p><p>图的邻接表表示方式并不唯一</p><p>无向图：边结点的数量是2|E|，整体空间复杂度为 O(|V| + 2|E|)</p><p>有向图：边结点的数量是|E|，整体空间复杂度为 O(|V| + |E|)</p><p>思考：</p><ol><li><p>如何求顶点的度、入度、出度?</p><p>第i个结点的出度 = 该结点后链接的结点个数</p><p>第i个结点的入度 = 遍历所有边结点中值等于该结点的个数</p><p>第i个结点的度 = 出度+入度</p></li><li><p>如何找到与一个顶点相连的边/弧?</p><p>指向：搜索该结点后链接结点中是否存在该结点</p><p>被指向：搜索所有边结点找相同值</p></li></ol><h2 id="十字链表法-存储有向图">2.3. 十字链表法-存储有向图</h2><p>邻接矩阵、邻接表存储有向图时，有向图找顶点的入边不方便，邻接矩阵存储空间复杂度高达O(|V|<sup>2</sup>)</p><p>用十字链表法空间复杂度：O(|V|+|E|) </p><p><img src="/2021/02/08/数据结构-图/shiyoulist.png" alt></p><p>如何找到指定顶点的所有出边?——顺着绿色线路找</p><p>如何找到指定顶点的所有入边?——顺着橙色线路找</p><h2 id="邻接多重表法-存储无向图">2.4. 邻接多重表法-存储无向图</h2><p>邻接矩阵、邻接表存储无向图，邻接表每条边对应两份冗余信息，删除顶点、删除边等操作时间复杂度高，邻接矩阵存储空间复杂度高达O(|V|<sup>2</sup>)</p><p><img src="/2021/02/08/数据结构-图/wusuo.png" alt></p><p>空间复杂度：O(|V|+|E|) 删除边、删除节点等操作很方便</p><p>删除A-B边</p><p><img src="/2021/02/08/数据结构-图/delete1.png" alt></p><p>删除顶点E</p><p><img src="/2021/02/08/数据结构-图/delete2.png" alt></p><h2 id="四种存储结构对比">2.5. 四种存储结构对比</h2><table><thead><tr><th></th><th>邻接表</th><th>邻接矩阵</th><th>十字链表</th><th>邻接多重表</th></tr></thead><tbody><tr><td>空间复杂度</td><td>无向图O(|V|+2|E|)；有向图O(|V|+|E|)</td><td>O(|V|<sup>2</sup>)</td><td>O(|V|+|E|)</td><td>O(|V|+|E|)</td></tr><tr><td>适用于</td><td>存储稀疏图</td><td>存储稠密图</td><td>有向图</td><td>无向图</td></tr><tr><td>表示方式</td><td>不唯一</td><td>唯一</td><td>不唯一</td><td>不唯一</td></tr><tr><td>计算度/出度/入度</td><td>计算有向图的度，入度不方便，其余很方便</td><td>必须遍历对应行或列</td><td></td><td></td></tr><tr><td>找相邻的边</td><td>找有向图的入边不方便，其余很方便</td><td>必须遍历对应行或列</td><td>很方便</td><td>很方便</td></tr></tbody></table><h1 id="图的基本操作">3. 图的基本操作</h1><h2 id="总览">3.1. 总览</h2><ul><li><p>Adjacent(G,x,y)：判断图<em>G</em>是否存在边&lt;<em>x</em>, <em>y</em>&gt;或(<em>x</em>, <em>y</em>)。</p></li><li><p>Neighbors(G,x)：列出图<em>G</em>中与结点<em>x</em>邻接的边。</p></li><li><p>InsertVertex(G,x)：在图<em>G</em>中插入顶点<em>x</em>。</p></li><li><p>DeleteVertex(G,x)：从图<em>G</em>中删除顶点<em>x</em>。</p></li><li><p>AddEdge(G,x,y)：若无向边(<em>x</em>, <em>y</em>)或有向边&lt;<em>x</em>, <em>y</em>&gt;不存在，则向图<em>G</em>中添加该边。</p></li><li><p>RemoveEdge(G,x,y)：若无向边(<em>x</em>, <em>y</em>)或有向边&lt;<em>x</em>, <em>y</em>&gt;存在，则从图<em>G</em>中删除该边。</p></li><li><p>FirstNeighbor(G,x)：求图<em>G</em>中顶点<em>x</em>的第一个邻接点，若有则返回顶点号。若<em>x</em>没有邻接点</p><p>或图中不存在<em>x</em>，则返回-1。</p></li><li><p>NextNeighbor(G,x,y)：假设图<em>G</em>中顶点<em>y</em>是顶点<em>x</em>的一个邻接点，返回除<em>y</em>之外顶点<em>x</em>的下一</p></li></ul><p>个邻接点的顶点号，若<em>y</em>是<em>x</em>的最后一个邻接点，则返回-1。</p><ul><li>Get_edge_value(G,x,y)：获取图<em>G</em>中边(<em>x</em>, <em>y</em>)或&lt;<em>x</em>, <em>y</em>&gt;对应的权值。</li><li>Set_edge_value(G,x,y,v)：设置图<em>G</em>中边(<em>x</em>, <em>y</em>)或&lt;<em>x</em>, <em>y</em>&gt;对应的权值为<em>v</em>。</li></ul><h2 id="Adjacent-G-x-y">3.2. Adjacent(G,x,y)</h2><p>判断图G是否存在边&lt;x,y&gt;或(x, y)。</p><table><thead><tr><th></th><th>有向图</th><th>无向图</th></tr></thead><tbody><tr><td>邻接表</td><td>查找结点x的链表中是否存在结点y<br>O(1)~O(|V|)</td><td>查找结点x的链表中是否存在结点y or<br>查找结点y的链表中是否存在结点x<br>O(1)~O(|V|)</td></tr><tr><td>邻接矩阵</td><td>矩阵G[x] [j]=0则不存在，=1则存在<br>O(1)</td><td>矩阵G[x] [j]=0则不存在，=1则存在 or<br>矩阵G[j] [x]=0则不存在，=1则存在<br>O(1)</td></tr></tbody></table><h2 id="Neighbors-G-x">3.3. Neighbors(G,x)</h2><p>列出图G中与结点x邻接的边–求结点x的度</p><table><thead><tr><th></th><th>有向图</th><th>无向图</th></tr></thead><tbody><tr><td>邻接表</td><td>出度：列举结点x的链表中所有结点O(|V|)<br>入度：搜素所有边结点查找结点x，找到结点x所在链表的被指向O(|E|)</td><td>出/入度：列举结点x的链表中所有结点O(|V|)</td></tr><tr><td>邻接矩阵</td><td>出度：使G[x] [j]!=0所在x行的所有结点j - O(|V|)<br>入度：使G[j] [x]!=0所在x列的所有结点j - O(|V|)</td><td>出/入度：使G[x] [j]!=0所在x行的所有结点j - O(|V|)</td></tr></tbody></table><h2 id="InsertVertex-G-x">3.4. InsertVertex(G,x)</h2><p>在图G中插入顶点x</p><table><thead><tr><th></th><th>有向图</th><th>无向图</th></tr></thead><tbody><tr><td>邻接表</td><td>结点数组增加一行 –O(1)</td><td>结点数组增加一行 – O(1)</td></tr><tr><td>邻接矩阵</td><td>矩阵增加一行一列 – O(1)</td><td>矩阵增加一行一列 – O(1)</td></tr></tbody></table><p><img src="/2021/02/08/数据结构-图/insert.png" alt></p><h2 id="DeleteVertex-G-x">3.5. DeleteVertex(G,x)</h2><p>从图G中删除顶点x</p><table><thead><tr><th></th><th>有向图</th><th>无向图</th></tr></thead><tbody><tr><td>邻接表</td><td>将数组结点中对应结点数据域置空，对应链表置NULL – O(1)~O(|V|)<br>遍历所有边结点删除结点x – O(|E|)</td><td>将数组结点中对应结点数据域置空，对应链表置NULL<br>遍历所有边结点删除结点x– O(1)~O(|E|)</td></tr><tr><td>邻接矩阵</td><td>将x行x列置空</td><td>将x行x列置空</td></tr></tbody></table><p><img src="/2021/02/08/数据结构-图/delete.png" alt></p><h2 id="AddEdge-G-x-y">3.6. AddEdge(G,x,y)</h2><p>若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边。</p><table><thead><tr><th></th><th>有向图</th><th>无向图</th></tr></thead><tbody><tr><td>邻接表</td><td>结点x链表中后插结点y – O(1)-O(|V|)</td><td>结点x链表中后插结点y<br>结点y链表中后插结点x – O(1)-O(|V|)</td></tr><tr><td>邻接矩阵</td><td>G[x] [y]=1 - O(1)</td><td>G[x] [y]=1 且G[y] [x]=1 – O(1)</td></tr></tbody></table><h1 id="图的遍历">4. 图的遍历</h1><h2 id="广度优先遍历BFS">4.1. 广度优先遍历BFS</h2><h3 id="树层序-vs-图层序">4.1.1. 树层序 vs 图层序</h3><p><img src="/2021/02/08/数据结构-图/cengtu.png" alt></p><p>树层序遍历：</p><ol><li>若树非空，则根节点入队 </li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队 </li><li>重复2直到队列为空</li></ol><p>图层序遍历类同于树，此外要点：</p><ol><li>找到与一个顶点相邻的所有顶点</li><li>标记哪些顶点被访问过</li><li>需要一个辅助队列</li></ol><h3 id="算法实现">4.1.2. 算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[VertexNum];</span><br><span class="line">InitQueue(Q);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    visited[i]=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">      BFS(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从结点v开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  visit(v);</span><br><span class="line">  visited[v]=<span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//顶点v入队</span></span><br><span class="line">  EnQueue(Q,v);</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">    <span class="comment">//顶点v出队</span></span><br><span class="line">    DeQueue(Q,v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line">      <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">      <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">        <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">        visit(w);</span><br><span class="line">        <span class="comment">//w作已访问标记</span></span><br><span class="line">        visited[w]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//w入队</span></span><br><span class="line">        EnQueue(Q,w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历实现">4.1.3. 遍历实现</h3><p><img src="/2021/02/08/数据结构-图/bfs.png" alt></p><p>从顶点1出发得到的广度优先遍历序列：1，2，5，6，3，7，4，8</p><p>从顶点2出发得到的广 度优先遍历序列：2，1，6，5，3，7，4，8</p><p>从顶点3出发得到的广度优先遍历序列：3，4，6，7，8，2，1，5</p><h3 id="遍历序列的可变性">4.1.4. 遍历序列的可变性</h3><p><img src="/2021/02/08/数据结构-图/bfs1.png" alt><img src="/2021/02/08/数据结构-图/bfs2.png" alt></p><p><strong>同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一</strong> </p><p>从顶点2开始，【2，1，6，5，3，7，4，8】</p><p><strong>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</strong></p><p>从顶点2开始，【2，1，6，5，3，7，4，8】 or 【2，6，1，3，7，5，4，8】</p><h3 id="复杂度">4.1.5. 复杂度</h3><p>空间复杂度：最坏情况，辅助队列大小为 O(|V|)</p><p>时间复杂度：</p><p>邻接矩阵——访问|V|个顶点需要O(|V|)的时间，查找每个顶点的邻接点都需要O(|V|)的时间，而总共有|V|个顶点， 时间复杂度<strong>=</strong> O(|V|<sup>2</sup>)</p><p>邻接表——访问|V|个顶点需要O(|V|)的时间，查找各个顶点的邻接点共需要O(|E|)的时间， 时间复杂度=O(|V|+|E|)</p><h3 id="广度优先生成树">4.1.6. 广度优先生成树</h3><p>广度优先生成树由广度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一。</p><p>对非连通图的广度优先遍历，可得到广度优先生成森林</p><p><img src="/2021/02/08/数据结构-图/bfslist1.png" alt><img src="/2021/02/08/数据结构-图/bfstree.png" alt></p><p><img src="/2021/02/08/数据结构-图/bfslist2.png" alt><img src="/2021/02/08/数据结构-图/bfstree2.png" alt></p><h2 id="深度优先遍历DFS">4.2. 深度优先遍历DFS</h2><h3 id="树的深度优先遍历-vs-DFS">4.2.1. 树的深度优先遍历 vs DFS</h3><p>树的深度优先遍历(先根、后根): </p><p>从根节点出发，能往更深处走就尽量往深处走。每当访问一个结点的时候，要检查是否还有与当前结点相邻的且没有被访问过的结点，如果有的话就往下一层钻。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    visit(R);</span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">/*R还有下一个子树T*/</span>)&#123;</span><br><span class="line">      PreOder(T);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图的深度优先遍历类似于树的先根遍历。</p><h3 id="算法实现-1">4.2.2. 算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[VertexNum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    visited[i]=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">      DFS(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从结点v开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  visit(v);</span><br><span class="line">  visited[v]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line">      <span class="comment">//w为u尚未访问的邻接顶点</span></span><br><span class="line">      <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">        DFS(G,w);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历实现-1">4.2.3. 遍历实现</h3><p><img src="/2021/02/08/数据结构-图/bfs.png" alt></p><p>从2出发的深度优先遍历序列：2，1，5，6，3，4，7，8</p><p>从3出发的深度优先遍历序列：3，4，7，6，2，1，5，8</p><p>从1出发的深度优先遍历序列：1，2，6，3，4，7，8，5</p><h3 id="复杂度分析">4.2.4. 复杂度分析</h3><p><strong>空间复杂度</strong>：</p><p>来自函数调用栈，最坏情况，递归深度为<strong>O(|V|)</strong></p><p>最好情况，O(1) —— 一个顶点关联其他所有结点</p><p><strong>时间复杂度</strong>：</p><p>时间复杂度=访问各结点所需时间+探索各条边所需时间</p><p>邻接矩阵——访问|V|个顶点需要O(|V|)的时间，查找每个顶点的邻接点都需要O(|V|)的时间，而总共有|V|个顶点， 时间复杂度<strong>=</strong> O(|V|<sup>2</sup>)</p><p>邻接表——访问|V|个顶点需要O(|V|)的时间，查找各个顶点的邻接点共需要O(|E|)的时间， 时间复杂度=O(|V|+|E|)</p><h3 id="遍历序列可变性">4.2.5. 遍历序列可变性</h3><p>同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一 </p><p>同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一</p><h3 id="深度优先生成树">4.2.6. 深度优先生成树</h3><p>深度优先生成树由深度优先遍历过程确定</p><p>同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一 </p><p>同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</p><p><img src="/2021/02/08/数据结构-图/bfslist2.png" alt><img src="/2021/02/08/数据结构-图/dfs1.png" alt></p><p><img src="/2021/02/08/数据结构-图/bfslist1.png" alt><img src="/2021/02/08/数据结构-图/dfs2.png" alt></p><h2 id="图的遍历与图的连通性">4.3. 图的遍历与图的连通性</h2><p>对<code>无向图</code>进行<strong>BFS/DFS</strong>遍历，调用<strong>BFS/DFS</strong>函数的次数<strong>=</strong>连通分量数</p><p>对于连通图，只需调用<strong>1</strong>次 <strong>BFS/DFS</strong></p><p>对<code>有向图</code>进行<strong>BFS/DFS</strong>遍历 调用<strong>BFS/DFS</strong>函数的次数要具体问题具体分析</p><p>若起始顶点到其他各顶点都有路径，则只需调用<strong>1</strong>次 <strong>BFS/DFS</strong> 函数</p><p>对于强连通图，从任一结点出发都只需调用<strong>1</strong>次 <strong>BFS/DFS</strong></p><h1 id="最小生成树">5. 最小生成树</h1><p>连通图的生成树是包含图中全部顶点的一个<code>极小连通子图</code>。</p><p>若图中顶点数为n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通 图，若加上一条边则会形成一个回路。</p><p>广度优先生成树，深度优先生成树都是极小连通子图。</p><h2 id="最小生成树-最小代价树-概念">5.1. 最小生成树(最小代价树)概念</h2><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。</p><p>对于一个<code>带权连通无向图</code> G= (V, E)，生成树不同，每棵树的权(即树中所有边上的权值之和)也可能不同。设R为G的所有生成树的集合，若T为R中<code>边的权值之和最小的生成树</code>，则T称为G的最小生成树(<em>Minimum-Spanning-Tree, MST</em>)。</p><p>最小生成树可能有多个，但边的权值之和总是唯一且最小的</p><p><code>最小生成树的边数 = 顶点数 - 1</code>。砍掉一条则不连通，增加一条边则会出现回路</p><p>如果一个连通图本身就是一棵树，则其最小生成树就是它本身 </p><p>只有连通图才有生成树，非连通图只有生成森林</p><p>求最小生成树的算法：Prim，Kruskal</p><h2 id="Prim算法-普里姆">5.2. Prim算法(普里姆)</h2><h3 id="概念">5.2.1. 概念</h3><p>从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p><p><img src="/2021/02/08/数据结构-图/prim.png" alt></p><p>时间复杂度：O(|V|<sup>2</sup>) 适合用于边稠密图</p><h3 id="实现思想">5.2.2. 实现思想</h3><p>从V<sub>0</sub>开始，总共需要 n-1 轮处理</p><p>每一轮处理：循环遍历所有个结点，找到lowCost最低的，且还没加入树的顶点。 再次循环遍历，更新还没加入的各个顶点的lowCost值</p><p><img src="/2021/02/08/数据结构-图/prim1.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/prim3.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/prim2.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/prim4.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/prim5.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/prim6.png" alt></p><h3 id="算法代码">5.2.3. 算法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">312312312</span>;</span><br><span class="line"><span class="keyword">int</span> graph[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>; <span class="keyword">int</span> min=Inf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[j]==<span class="literal">false</span>&amp;&amp;min&gt;dis[j])</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">min=dis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (u==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">visit[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[v]==<span class="literal">false</span>&amp;&amp;graph[u][v]!=Inf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (graph[u][v]&lt;dis[v])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=graph[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法">5.3. Kruskal算法</h2><h3 id="概念-1">5.3.1. 概念</h3><p>每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)直到所有结点都连通</p><p><img src="/2021/02/08/数据结构-图/kruskal.png" alt></p><p>时间复杂度：O( |E|log<sub>2</sub>|E| ) 适合用于边稀疏图</p><h3 id="实现思想-1">5.3.2. 实现思想</h3><p>共执行 e 轮，每轮判断两个顶点是否属于同一集合，需要 O(log<sub>2</sub>e)</p><p>总时间复杂度 O(elog<sub>2</sub>e)</p><p>初始：将各条边按权值排序</p><p><img src="/2021/02/08/数据结构-图/kru1.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/kru2.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/kru3.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/kru4.png" alt></p><p><img src="/2021/02/08/数据结构-图/kru5.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/kru6.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/kru7.png" alt></p><h1 id="最短路径">6. 最短路径</h1><h2 id="单源最短路径">6.1. 单源最短路径</h2><h3 id="BFS">6.1.1. BFS</h3><p>无权图可以视为一种特殊的带权图，只是每条边的权值都为1</p><p><img src="/2021/02/08/数据结构-图/bfsduan.png" alt></p><h4 id="算法实现-2">6.1.1.1. 算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 2&lt;&lt;30;</span></span><br><span class="line"><span class="keyword">bool</span> visited[VertexNum];</span><br><span class="line">InitQueue(Q);</span><br><span class="line"><span class="comment">//最短路径数组</span></span><br><span class="line"><span class="keyword">int</span> d[VertexNum];</span><br><span class="line"><span class="comment">//记录路径中的顶点</span></span><br><span class="line"><span class="keyword">int</span> path[VertexNum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    visited[i]=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//开始时u到i结点距离为无穷</span></span><br><span class="line">    d[i]=Inf;</span><br><span class="line">    <span class="comment">//无结点指向i结点</span></span><br><span class="line">    path[i]=<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  d[u]=<span class="number">0</span>;</span><br><span class="line">  visited[u]=<span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//顶点v入队</span></span><br><span class="line">  EnQueue(Q,u);</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">    <span class="comment">//顶点v出队</span></span><br><span class="line">    DeQueue(Q,u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))&#123;</span><br><span class="line">      <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">      <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">        d[w]=d[v]+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//路径为从u到w</span></span><br><span class="line">        path[w]=u;</span><br><span class="line">        <span class="comment">//w作已访问标记</span></span><br><span class="line">        visited[w]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//w入队</span></span><br><span class="line">        EnQueue(Q,w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS算法的局限性">6.1.1.2. BFS算法的局限性</h4><p>BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p><h3 id="Dijkstra算法">6.1.2. Dijkstra算法</h3><h4 id="迪杰斯特拉">6.1.2.1. 迪杰斯特拉</h4><p>艾兹格·W·迪杰斯特拉 Edsger Wybe Dijkstra (1930~2002)1972年图灵奖得主</p><ul><li>提出<strong>“goto</strong> 有害理论<strong>”——</strong>操作系统，虚拟存储技术 </li><li>信号量机制<strong>PV</strong>原语<strong>——</strong>操作系统，进程同步</li><li>银行家算法<strong>——</strong>操作系统，死锁</li><li>解决哲学家进餐问题<strong>——</strong>操作系统，死锁</li><li>Dijkstra最短路径算法——数据结构大题、小题</li></ul><h4 id="算法思想">6.1.2.2. 算法思想</h4><p><img src="/2021/02/08/数据结构-图/dijk.png" alt></p><p>初始：从V<sub>0</sub>开始，初始化三个数组信息如下：</p><p><img src="/2021/02/08/数据结构-图/dijarray.png" alt></p><p>算法过程：</p><p><img src="/2021/02/08/数据结构-图/dij1.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dij2.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dij3.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dij4.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dij5.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dij6.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dij7.png" alt></p><p><strong>V0</strong>到<strong>V2</strong> 的最短<strong>(</strong>带权<strong>)</strong>路径⻓度为：<strong>dist[2] = 9</strong></p><p>通过 <strong>path[ ]</strong> 可知，<strong>V0</strong>到<strong>V2</strong> 的最短<strong>(</strong>带权<strong>)</strong>路径：<strong>V2 —&gt; V1 —&gt; V4 —&gt; V0</strong></p><h4 id="算法代码-1">6.1.2.3. 算法代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">312312312</span>;</span><br><span class="line"><span class="keyword">int</span> graph[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> visit[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">-1</span>; <span class="keyword">int</span> min=Inf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[j]==<span class="literal">false</span>&amp;&amp;min&gt;dis[j])</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">min=dis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (u==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">visit[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[v]==<span class="literal">false</span>&amp;&amp;graph[u][v]!=Inf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dis[u]+graph[u][v]&lt;dis[v])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+graph[u][v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度">6.1.2.4. 时间复杂度</h4><p>初始：</p><ul><li>若从V<sub>0</sub>开始，令 final[0]=ture; dist[0]=0; path[0]=-1。</li><li>其余顶点final[k]=false; dist[k]=arcs[0] [k]; path[k]= (arcs[0] [k]==∞) ? -1 : 0 </li></ul><p>n-1轮处理:</p><p>循环遍历所有顶点，找到还没确定最短路径，且dist 最小的顶点V<sub>i</sub>，令final[i]=ture。</p><p>并检查所有邻接自V<sub>i</sub> 的顶点，对于邻接自V<sub>i</sub> 的顶点 V<sub>j</sub> ，若 final[j]==false 且 dist[i]+arcs[i] [j] &lt; dist[j]，则令 dist[j]=dist[i]+arcs[i] [j]; path[j]=i。(注:arcs[i] [j]表示V<sub>i</sub> 到V<sub>j</sub> 的弧的权值)</p><p>时间复杂度：O(|V|<sup>2</sup>)</p><p>对比Prim最小生成树算法，不同的是 arcs[i] [j] &lt; dist[j] ，则 dist[j]=arcs[i] [j]; path[j]=i，不涉及路径的累加</p><h4 id="可用于求所有顶点间的最短路径">6.1.2.5. 可用于求所有顶点间的最短路径</h4><p>对于所有顶点，重复|V|次即可，总的时间复杂度也是O(|V|<sup>3</sup>)</p><h4 id="不用于负权值带权图">6.1.2.6. 不用于负权值带权图</h4><p><img src="/2021/02/08/数据结构-图/dijfu.png" alt></p><p>事实上V<sub>0</sub>到V<sub>2</sub>的最短带权路径⻓度为5，Dijkstra算法不适用于有负权值的带权图</p><h2 id="各顶点间最短路径-Floyd算法">6.2. 各顶点间最短路径-Floyd算法</h2><h3 id="罗伯特·弗洛伊德">6.2.1. 罗伯特·弗洛伊德</h3><p>罗伯特·弗洛伊德 (1936-2001)Robert W<strong>.</strong>Floyd 1978年图灵奖得主</p><ul><li>提出Floyd算法(Floyd-Warshall算法 ) </li><li>提出堆排序算法</li></ul><h3 id="Floyd算法思想">6.2.2. Floyd算法思想</h3><p>求出每一对顶点之间的最短路径 使用动态规划思想，将问题的求解分为多个阶段</p><p>对于n个顶点的图G，求任意一对顶点 V<sub>i</sub> —&gt; V<sub>j</sub> 之间的最短路径可分为如下几个阶段: </p><ul><li><p>初始：不允许在其他顶点中转，最短路径是?</p><p><img src="/2021/02/08/数据结构-图/floyd1.png" alt></p></li><li><p>0：若允许在 V<sub>0</sub>中转，最短路径是?</p><p><img src="/2021/02/08/数据结构-图/floyd2.png" alt></p></li><li><p>1：若允许在 V<sub>0</sub>、V<sub>1</sub>中转，最短路径是?</p><p><img src="/2021/02/08/数据结构-图/floyd3.png" alt></p></li><li><p>2：若允许在 V<sub>0</sub>、V<sub>1</sub>、V<sub>2</sub> 中转，最短路径是?</p><p><img src="/2021/02/08/数据结构-图/floyd4.png" alt></p></li></ul><p>  根据 A<sup>(2)</sup> 可知，V<sub>1</sub>到V<sub>2</sub> 最短路径⻓度为 <strong>4</strong>，根据 path<sup>(2)</sup> 可知，完整路径信息为 <strong>V1—&gt;V2</strong> </p><p>  根据 A<sup>(2)</sup> 可知，V<sub>0</sub>到V<sub>2</sub> 最短路径⻓度为 <strong>10</strong>，根据 path<sup>(2)</sup> 可知，完整路径信息为 <strong>V0—&gt;V1—&gt;V2</strong></p><p>  根据 A<sup>(2) </sup>可知，V<sub>1</sub>到V<sub>0</sub> 最短路径⻓度为 <strong>9,</strong> 根据 path<sup>(2)</sup> 可知，完整路径信息为 <strong>V1—&gt;V2—&gt;V0</strong></p><ul><li>n-1：若允许在 V<sub>0</sub>、V<sub>1</sub>、V<sub>2</sub> ……V<sub>n-1</sub>中转，最短路径是?</li></ul><h3 id="算法实现-3">6.2.3. 算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始时A[][]=G[][]，path[][]=-1</span></span><br><span class="line"><span class="comment">//Vk作为中转点，n-顶点数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])&#123;</span><br><span class="line">        A[i][j]=A[i][k]+A[k][j];</span><br><span class="line">        path[i][j]=k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：O(|V|<sup>2</sup>)</p><p>时间复杂度：O(|V|<sup>3</sup>)</p><h3 id="用于负权图">6.2.4. 用于负权图</h3><p><img src="/2021/02/08/数据结构-图/floydfu.png" alt></p><h3 id="仍不能解决的问题">6.2.5. 仍不能解决的问题</h3><p>Floyd 算法不能解决带有“负权回路”的图(有负权值的边组成回路)，这种图有可能没有最短路径</p><h2 id="BFS—Dijkstra—Floyd">6.3. BFS—Dijkstra—Floyd</h2><table><thead><tr><th></th><th>BFS 算法</th><th>Dijkstra 算法</th><th><strong>Floyd 算法</strong></th></tr></thead><tbody><tr><td>无权图</td><td>☑️</td><td>☑️</td><td>☑️</td></tr><tr><td>带权图</td><td>✖️</td><td>☑️</td><td>☑️</td></tr><tr><td>带负权值的图</td><td>✖️</td><td>✖️</td><td>☑️</td></tr><tr><td>带负权回路的图</td><td>✖️</td><td>✖️</td><td>✖️</td></tr><tr><td>时间复杂度</td><td>O(|V|<sup>2</sup>)(邻接矩阵)或O(|V|+|E|)(邻接表)</td><td>O(|V|<sup>2</sup>)</td><td>O(|V|<sup>3</sup>)</td></tr><tr><td>通常用于</td><td>求无权图的单源最短路径</td><td>求带权图的单源最短路径</td><td>求带权图中各顶点间的最短路径</td></tr></tbody></table><h1 id="有向无环图描述表达式">7. 有向无环图描述表达式</h1><h2 id="有向无环图">7.1. 有向无环图</h2><p>若一个有向图中不存在环，则称为有向无环图，简称DAG图(Directed Acyclic Graph)</p><h2 id="DAG描述表达式">7.2. DAG描述表达式</h2><p><img src="/2021/02/08/数据结构-图/dag.png" alt></p><h2 id="解题方法">7.3. 解题方法</h2><p><img src="/2021/02/08/数据结构-图/dag1.png" alt></p><hr><p><img src="/2021/02/08/数据结构-图/dag2.png" alt></p><h1 id="拓扑排序">8. 拓扑排序</h1><h2 id="概念-2">8.1. 概念</h2><h3 id="AOV网">8.1.1. AOV网</h3><p>AOV(Activity On Vertex NetWork，用顶点表示活动的网)：用DAG图(有向无环图)表示一个工程。顶点表示活动，有向边&lt;V<sub>i</sub>， V<sub>j</sub>&gt;表示活动&lt;V<sub>i</sub>必须先于活动V<sub>j</sub>进行。</p><h3 id="拓扑排序-1">8.1.2. 拓扑排序</h3><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序</p><ol><li>每个顶点出现且只出现一次。</li><li>若顶点<strong>A</strong>在序列中排在顶点<strong>B</strong>的前面，则在图中不存在从顶点<strong>B</strong>到顶点<strong>A</strong>的路径。</li></ol><p>或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点<strong>A</strong> 到顶点<strong>B</strong>的路径，则在排序中顶点<strong>B</strong>出现在顶点<strong>A</strong>的后面。每个<strong>AOV</strong>网都有一个或多个拓扑排序序列。</p><p><code>找到做事的先后顺序</code></p><h2 id="实现思想-2">8.2. 实现思想</h2><ol><li>从<strong>AOV</strong>网中选择一个没有前驱(入度为<strong>0</strong>)的顶点并输出。</li><li>从网中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前的<strong>AOV</strong>网为空或当前网中<code>不存在无前驱的顶点(无回路)</code>为止。</li></ol><h2 id="算法代码-2">8.3. 算法代码</h2><p>邻接表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">  <span class="keyword">int</span> adjvex;</span><br><span class="line">  <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">  <span class="comment">//边权值</span></span><br><span class="line">  <span class="comment">//InfoType info</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">//顶点数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> char VertexType</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//顶点信息</span></span><br><span class="line">  VertexType data;</span><br><span class="line">  <span class="comment">//指向第一条依附该结点的弧的指针</span></span><br><span class="line">  ArcNode *firstarc;</span><br><span class="line">&#125;VNode,AdjList[MaxVertxNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//邻接表</span></span><br><span class="line">  AdjList vertices;</span><br><span class="line">  <span class="comment">//顶点数，弧数</span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><p>拓扑排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> print[MaxVertxNum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopplogicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexNum;i++)&#123;</span><br><span class="line">    <span class="comment">//所有入度为0的顶点入栈</span></span><br><span class="line">    <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">      Push(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//记录输出顶点数</span></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Pop(S,v);</span><br><span class="line">    <span class="comment">//输出顶点</span></span><br><span class="line">    print[count++]=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = G.vertices[v].firstarc;w=w-&gt;nextarc)&#123;</span><br><span class="line">      <span class="comment">//将所有v指向的顶点入度-1，并且将入度减为0的顶点入栈</span></span><br><span class="line">      <span class="keyword">int</span> p = w-&gt;adjvex;</span><br><span class="line">      indegree[p]--;</span><br><span class="line">      <span class="keyword">if</span>(indegree[p]==<span class="number">0</span>)&#123;</span><br><span class="line">        Push(S,p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//是否存在回路</span></span><br><span class="line">  <span class="keyword">if</span>(count&lt;G.vexnum)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(|V|+|E|)若采用邻接矩阵，则需O(|V|<sup>2</sup>)</p><h2 id="逆拓扑排序">8.4. 逆拓扑排序</h2><h3 id="实现思想-3">8.4.1. 实现思想</h3><ol><li>从<strong>AOV</strong>网中选择一个没有后继(<code>出度为0</code>)的顶点并输出。</li><li>从网中删除该顶点和所有以它为终点的有向边。</li><li>重复1和2直到当前的<strong>AOV</strong>网为空。</li></ol><h3 id="算法实现-DFS">8.4.2. 算法实现-DFS</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[VertexNum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    visited[i]=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">      DFS(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从结点v开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">  visited[v]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line">      <span class="comment">//w为u尚未访问的邻接顶点</span></span><br><span class="line">      <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">        DFS(G,w);</span><br><span class="line">      &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从底层开始输出顶点值</span></span><br><span class="line">  visit(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果存在回路，则不存在逆 拓扑排序序列，如何判断回路?</p><h1 id="关键路径">9. 关键路径</h1><h2 id="概念-3">9.1. 概念</h2><h3 id="AOE网">9.1.1. AOE网</h3><p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销(如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网 (Activity On Edge NetWork)</p><p><img src="/2021/02/08/数据结构-图/aoe.png" alt></p><p>AOE网具有以下两个性质:</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始; </li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。 另外，有些活动是可以并行进行的</li></ol><p>在AOE网中仅有一个入度为0的顶点，称为开始顶点(源点)，它表示整个工程的开始;</p><p>也仅有一个出度为0的顶点，称为结束顶点(汇点)，它表示整个工程的结束。</p><p>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径⻓度的路径称为<code>关键路径</code>，而把关键路径上的活动称为<code>关键活动</code></p><p>完成整个工程的最短时间就是关键路径的⻓度，若关键活动不能按时完成，则整个 工程的完成时间就会延⻓</p><h3 id="关键路径-1">9.1.2. 关键路径</h3><p>事件v<sub>k</sub>的最早发生时间 ve(k)——决定了所有从 v<sub>k</sub>开始的活动能够开工的最早时间 </p><p>事件v<sub>k</sub>的最迟发生时间 vl(k)——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p><p>活动a<sub>i</sub>的最早开始时间e(i)——指该活动弧的起点所表示的事件的最早发生时间</p><p>活动a<sub>i</sub>的最迟开始时间 l(i)——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</p><p>活动a<sub>i</sub>的时间余量 d(i)=l(i)-e(i)，表示在不增加完成整个工程所需总时间的情况下，活动a<sub>i</sub>可以拖延的时间 </p><p>若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)=0即 l(i) = e(i)的活动 a<sub>i</sub>是关键活动 </p><p>由关键活动组成的路径就是关键路径</p><h2 id="求关键路径的步骤">9.2. 求关键路径的步骤</h2><ol><li><p>求所有事件的最早发生时间 ve( )</p><p>按拓扑排序序列，依次求各个顶点的 ve(k):</p><p>ve(源点) = 0</p><p>ve(k) = Max{ ve(j) + Weight(v<sub>j</sub>, v<sub>k</sub>)}，v<sub>j</sub>为 v<sub>k</sub> 的任意前驱</p></li><li><p>求所有事件的最迟发生时间 vl( ) </p><p>按逆拓扑排序序列，依次求各个顶点的 vl(k):</p><p>vl(汇点) = ve(汇点)</p><p>vl(k) = Min{ vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>)}，v<sub>j</sub>为 v<sub>k</sub> 的任意后继</p></li><li><p>求所有活动的最早发生时间 e( )</p><p>若边&lt;v<sub>k</sub>, v<sub>j</sub>&gt;表示活动 a<sub>i</sub>，则有 e(i) = ve(k)</p></li><li><p>求所有活动的最迟发生时间 l( )</p><p>若边&lt;v<sub>k</sub>, v<sub>j</sub>&gt;表示活动 a<sub>i</sub>，则有 l(i) = vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>)</p></li><li><p>求所有活动的时间余量 d( )</p><p>d(i)=l(i)-e(i)</p></li></ol><p>d(i)=0的活动就是关键活动， 由关键活动可得关键路径</p><h3 id="所有事件的最早发生时间ve-拓扑">9.2.1. 所有事件的最早发生时间ve() - 拓扑</h3><p>ve(源点) = 0</p><p>ve(k) = Max{ ve(j) + Weight(v<sub>j</sub>, v<sub>k</sub>)}</p><p>计算ve()可以用拓扑排序，最初ve[1…n]=0；若ve[j]+weight(vj,vk)&gt;ve[k]，则ve[k]=ve[j]+weight(vj,vk)</p><p><img src="/2021/02/08/数据结构-图/path.png" alt></p><p>拓扑序列：V<sub>1</sub>、V<sub>3</sub>、V<sub>2</sub>、V<sub>5</sub>、V<sub>4</sub>、V<sub>6</sub>  </p><p>ve(1)=0</p><p>ve(3)=2</p><p>ve(2)=3</p><p>ve(5)=6</p><p>ve(4)=max{ve(2)+2,ve(3)+4}=6 </p><p>ve(6)=max{ve(5)+1, ve(4)+2, ve(3)+3}=8</p><h3 id="求所有事件的最迟发生时间-vl-逆拓扑">9.2.2. 求所有事件的最迟发生时间 vl( ) - 逆拓扑</h3><p>vl(汇点) = ve(汇点)</p><p>vl(k) = Min{ vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>)}，v<sub>j</sub>为 v<sub>k</sub> 的任意后继</p><p>计算vl()用逆拓扑排序，最初vl[1…n]=ve[汇点]；若vl[j]-weight(vk,vj)&lt;ve[k]，则ve[k]=ve[j]+weight(vk,vj)</p><p><img src="/2021/02/08/数据结构-图/path.png" alt></p><p>逆拓扑序列：V<sub>6</sub>、V<sub>5</sub>、V<sub>4</sub>、V<sub>2</sub>、V<sub>3</sub>、V<sub>1</sub>  </p><p>vl(6)=8</p><p>vl(5)=7</p><p>vl(4)=6</p><p>vl(2)=min{vl(5)-3, vl(4)-2}=4 </p><p>vl(3)=min{vl(4)-4, vl(6)-3}=2</p><p>vl(1)=0</p><h3 id="求所有活动的最早发生时间-e">9.2.3. 求所有活动的最早发生时间 e( )</h3><p>若边&lt;v<sub>k</sub>, v<sub>j</sub>&gt;表示活动 ai，则有 e(i) = ve(k)</p><p><img src="/2021/02/08/数据结构-图/path.png" alt></p><table><thead><tr><th></th><th>V<sub>1</sub></th><th>V<sub>2</sub></th><th>V<sub>3</sub></th><th>V<sub>4</sub></th><th>V<sub>5</sub></th><th>V<sub>6</sub></th></tr></thead><tbody><tr><td>ve(k)</td><td>0</td><td>3</td><td>2</td><td>6</td><td>6</td><td>8</td></tr><tr><td>vl(k)</td><td>0</td><td>4</td><td>2</td><td>6</td><td>7</td><td>8</td></tr></tbody></table><p>求e()</p><table><thead><tr><th></th><th>a<sub>1</sub></th><th>a<sub>2</sub></th><th>a<sub>3</sub></th><th>a<sub>4</sub></th><th>a<sub>5</sub></th><th>a<sub>6</sub></th><th>a<sub>7</sub></th><th>a<sub>8</sub></th></tr></thead><tbody><tr><td>e()</td><td>0</td><td>0</td><td>3</td><td>3</td><td>2</td><td>2</td><td>6</td><td>6</td></tr></tbody></table><h3 id="求所有活动的最迟发生时间-l">9.2.4. 求所有活动的最迟发生时间 l( )</h3><p>若边&lt;v<sub>k</sub>, v<sub>j</sub>&gt;表示活动 a<sub>i</sub>，则有 l(i) = vl(j) - Weight(v<sub>k</sub>, v<sub>j</sub>)</p><p><img src="/2021/02/08/数据结构-图/path.png" alt></p><table><thead><tr><th></th><th>V<sub>1</sub></th><th>V<sub>2</sub></th><th>V<sub>3</sub></th><th>V<sub>4</sub></th><th>V<sub>5</sub></th><th>V<sub>6</sub></th></tr></thead><tbody><tr><td>ve(k)</td><td>0</td><td>3</td><td>2</td><td>6</td><td>6</td><td>8</td></tr><tr><td>vl(k)</td><td>0</td><td>4</td><td>2</td><td>6</td><td>7</td><td>8</td></tr></tbody></table><p>求l()</p><table><thead><tr><th></th><th>a<sub>1</sub></th><th>a<sub>2</sub></th><th>a<sub>3</sub></th><th>a<sub>4</sub></th><th>a<sub>5</sub></th><th>a<sub>6</sub></th><th>a<sub>7</sub></th><th>a<sub>8</sub></th></tr></thead><tbody><tr><td>e()</td><td>0</td><td>0</td><td>3</td><td>3</td><td>2</td><td>2</td><td>6</td><td>6</td></tr><tr><td>l()</td><td>1</td><td>0</td><td>4</td><td>4</td><td>2</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><h3 id="求所有活动的时间余量-d">9.2.5. 求所有活动的时间余量 d( )</h3><p>d(i)=l(i)-e(i)</p><p><img src="/2021/02/08/数据结构-图/path1.png" alt="img"></p><table><thead><tr><th></th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th></tr></thead><tbody><tr><td>ve(k)</td><td>0</td><td>3</td><td>2</td><td>6</td><td>6</td><td>8</td></tr><tr><td>vl(k)</td><td>0</td><td>4</td><td>2</td><td>6</td><td>7</td><td>8</td></tr></tbody></table><p>求d()</p><table><thead><tr><th></th><th>a<sub>1</sub></th><th>a<sub>2</sub></th><th>a<sub>3</sub></th><th>a<sub>4</sub></th><th>a<sub>5</sub></th><th>a<sub>6</sub></th><th>a<sub>7</sub></th><th>a<sub>8</sub></th></tr></thead><tbody><tr><td>e()</td><td>0</td><td>0</td><td>3</td><td>3</td><td>2</td><td>2</td><td>6</td><td>6</td></tr><tr><td>l()</td><td>1</td><td>0</td><td>4</td><td>4</td><td>2</td><td>5</td><td>6</td><td>7</td></tr><tr><td>d()</td><td>1</td><td><font color="#f00">0</font></td><td>1</td><td>1</td><td><font color="#f00">0</font></td><td>3</td><td><font color="#f00">0</font></td><td>1</td></tr></tbody></table><p>关键活动：a<sub>2</sub>、a<sub>5</sub> 、a<sub>7</sub> </p><p>关键路径：V<sub>1</sub> —&gt; V<sub>3</sub> —&gt; V<sub>4</sub> —&gt;V<sub>6</sub></p><h2 id="关键活动、关键路径的特性">9.3. 关键活动、关键路径的特性</h2><p>若关键活动耗时增加，则整个工程的工期将增⻓ </p><p>缩短关键活动的时间，可以缩短整个工程的工期 </p><p>当缩短到一定程度时，关键活动可能会变成非关键活动</p><p>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工 期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;图的概念，图的存储【邻接矩阵，邻接表】，图的基本操作，图的遍历【DFS，BFS】，最小生成树，最短路径，拓扑排序，关键路径&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构05-树与二叉树</title>
    <link href="/2021/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <id>/2021/02/08/数据结构-树/</id>
    <published>2021-02-08T14:54:14.000Z</published>
    <updated>2021-05-24T08:23:43.184Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">树，森林，满二叉树，完全二叉树，二叉排序树，平衡二叉树，线索二叉树，森林与二叉树的转换，哈夫曼树</blockquote><a id="more"></a><p>视频讲解，习题讲解，思维导图，PPT资源</p><p>链接: <a href="https://pan.baidu.com/s/1A8aNDgNie4ANZF0gJJGwDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1A8aNDgNie4ANZF0gJJGwDA</a>  密码: wdio</p><h1 id="树">1. 树</h1><h2 id="定义">1.1. 定义</h2><p>从树根生长，逐级分支</p><p>空树——结点数为0的树</p><p>非空树的特性：</p><ul><li>有且仅有一个根节点 </li><li>没有后继的结点称为“叶子结点”(或终端结点) </li><li>有后继的结点称为“分支结点”(或非终端结点) </li><li>除了根节点外，任何一个结点都<code>有且仅有一个前驱</code></li><li>每个结点可以有0个或多个后继。</li><li>树是一种<code>递归</code>定义的数据结构</li></ul><p>树是n(n≥0)个结点的有限集合，n = 0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足:</p><ol><li>有且仅有一个特定的称为<code>根</code>的结点。</li><li>当n&gt; 1时，其余结点可分为m(m&gt; 0)个<code>互不相交</code>的<code>有限</code>集合T<sub>1</sub>, T<sub>2</sub>,…, T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根结点的子树。</li></ol><p>##基本术语</p><h3 id="结点之间的关系描述">1.1.1. 结点之间的关系描述</h3><p><img src="/2021/02/08/数据结构-树/def.png" alt></p><ul><li><p>什么是<code>祖先</code>结点?</p><p>根A到结点K的唯一路径上的任意结点，称为结点K的祖先。结点B是结点K的祖先。</p></li><li><p>什么是<code>子孙</code>结点?</p><p>结点K是结点B的子孙。</p></li><li><p>什么是<code>双亲</code>结点(父节点)?</p><p>路径上最接近结点K的结点E称为结点K的双亲结点，如结点E是结点K的父节点。根A是树中唯一没有双亲的结点。</p></li><li><p>什么是<code>孩子</code>结点?</p><p>结点K是结点E的祖先。</p></li><li><p>什么是<code>兄弟</code>结点?</p><p>有相同双亲的结点称为兄弟。如结点K和结点L有相同的双亲E，K和L是兄弟。</p></li><li><p>什么是<code>堂兄弟</code>结点?</p><p>位于同一层的结点为堂兄弟结点。如结点E，F，G，H，I，J</p></li><li><p>什么是两个结点之间的<code>路径</code>? </p><p>只能从上往下看结点之间的边情况。路径由两个结点之间所经过的结点序列构成。如结点A到结点K的路径为A-&gt;B-&gt;E-&gt;K。同一个双亲的两个孩子之间不存在路径。</p></li><li><p>什么是<code>路径长度</code>? </p><p>结点到结点经过几条边。如结点A到结点K经过边数为3</p></li><li><p>树的路径长度</p><p>树的路径长度是指树根到每个结点的路径长的<code>总和</code>。根到每个结点的路径长度的最大值应是树的高度-1。</p></li></ul><h3 id="结点，树的属性描述">1.1.2. 结点，树的属性描述</h3><ul><li><p>结点的层次(深度)——从上往下数</p><p>根结点为第1层，它的子结点为第2层，以此类推。双亲在同一层的结点互为堂兄弟。</p><p>深度为从根结点开始自顶向下逐层累加。</p></li><li><p>结点的高度——从下往上数 </p><p>从叶结点开始自底向上逐层累加。</p></li><li><p>树的高度(深度)——总共多少层 </p><p>树高为树中结点的最大层数。如上图树的高度为4</p></li><li><p>结点的度——有几个孩子(分支) </p></li><li><p>树的度——各结点的度的最大值</p></li></ul><h3 id="有序树vs无序树">1.1.3. 有序树vs无序树</h3><p>有序树——逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</p><p>无序树——逻辑上看，树中结点的各子树从左至右是无次序的，可以互换</p><h3 id="树-vs-森林">1.1.4. 树 vs 森林</h3><p>森林。森林是m(m≥0)棵互不相交的树的集合。m可为0，代表空森林</p><p>eg：全中国所有人家的家谱</p><p>考点：二叉树与森林的转换——左孩子右兄弟存储法</p><p><img src="/2021/02/08/数据结构-树/treetrans.png" alt></p><h2 id="常考性质">1.2. 常考性质</h2><h3 id="结点数-总度数-1">1.2.1. 结点数=总度数+1</h3><p>结点的度——结点有几个孩子(分支)</p><h3 id="度为m的树、m叉树的区别">1.2.2. 度为m的树、m叉树的区别</h3><p>树的度——各结点的度的最大值 </p><p>m叉树——每个结点最多只能有m个孩子的树</p><table><thead><tr><th>度为<strong>m</strong>的树</th><th><strong>m</strong>叉树</th></tr></thead><tbody><tr><td>任意结点的度 ≤ m(最多m个孩子)</td><td>任意结点的度 ≤ m(最多m个孩子)</td></tr><tr><td>至少有一个结点度 = m(有m个孩子)</td><td>允许所有结点的度都 &lt; m</td></tr><tr><td>一定是非空树，至少有m+1个结点</td><td>可以是空树</td></tr></tbody></table><h3 id="度为m的树第i层结点数">1.2.3. 度为m的树第i层结点数</h3><p>度为m的树第 i 层至多有 m<sup>i-1</sup> 个结点(i≥1) </p><p>m叉树第 i 层至多有 m<sup>i-1</sup> 个结点(i≥1)</p><h3 id="高度为h的m叉树至多有结点数">1.2.4. 高度为h的m叉树至多有结点数</h3><p>高度为h的m叉树至多有$\frac{m^{h}-1}{m-1}$ 个结点</p><p>等比数列求和公式：a+aq+aq$^{2}$+…+aq$^{n-1}$=$\frac{a(1-q^{n})}{1-q}$</p><p>###高度为h的m叉树至少有结点数</p><p>高度为h的m叉树至少有 h 个结点。 </p><p>高度为h、度为m的树至少有 h+m-1 个结点。</p><p><img src="/2021/02/08/数据结构-树/hm1.png" alt> <img src="/2021/02/08/数据结构-树/hm2.png" alt></p><h3 id="具有n个结点的m叉树的最小高度">1.2.5. 具有n个结点的m叉树的最小高度</h3><p>具有n个结点的m叉树的最小高度为$\left \lceil log_{m}(n(m - 1) + 1)\right \rceil$</p><p>高度最小的情况——所有结点都有m个孩子</p><p><img src="/2021/02/08/数据结构-树/log.png" alt></p><h2 id="树的存储结构">1.3. 树的存储结构</h2><h3 id="双亲表示法-顺序存储">1.3.1. 双亲表示法(顺序存储)</h3><p>每个结点中保存指向双亲的“指针”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//数据元素</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//双亲位置域</span></span><br><span class="line">  <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//双亲表示</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">  <span class="comment">//结点数</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-树/shuangqi.png" alt><img src="/2021/02/08/数据结构-树/shuangqin1.png" alt></p><p>新增数据元素，无需按逻辑上的次序存储</p><p>删除数据元素：</p><ol><li>不移动其他数据，对应结点的数组元素数据置空，parent=-1</li><li>移动后续数据，类同于数组的删除，数据元素前移</li></ol><p>优点：查指定结点的双亲很方便</p><p>缺点：查指定结点的孩子只能从头遍历</p><h3 id="孩子表示法-顺序-链式存储">1.3.2. 孩子表示法(顺序+链式存储)</h3><p>孩子表示法：顺序存储各个节点，每个结点中保存孩子链表头指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">  <span class="keyword">int</span> child;</span><br><span class="line">  <span class="comment">//下一个孩子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//第一个孩子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">  <span class="keyword">int</span> n,r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-树/shuangqi.png" alt><img src="/2021/02/08/数据结构-树/shuanglian.png" alt></p><h3 id="孩子兄弟表示法-链式存储">1.3.3. 孩子兄弟表示法(链式存储)</h3><p>左孩子右兄弟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//左指针-第一个孩子</span></span><br><span class="line">  <span class="comment">//右指针-右兄弟</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树与二叉树的转换">1.3.4. 树与二叉树的转换</h3><p>一个结点左指针为其第一个孩子，右指针为其右兄弟</p><p><img src="/2021/02/08/数据结构-树/shuangqi.png" alt><img src="/2021/02/08/数据结构-树/nextsibling.png" alt></p><h3 id="森林和二叉树的转换">1.3.5. 森林和二叉树的转换</h3><p>森林。森林是m(m≥0)棵互不相交的树的集合</p><p>各个树的根节点视为兄弟关系</p><p><img src="/2021/02/08/数据结构-树/sen.png" alt></p><p><code>森林中有n个非终端结点，对应转换的二叉树中右指针为空的结点数？</code></p><p>n个非终端结点的所有孩子结点中最后一个结点的右指针为空，每棵树相连后，最后一棵树的右指针必为空，一共<code>n+1</code>个空指针域。</p><p><code>森林F有15条边，25个结点，则F中包含多少颗树？</code></p><p>一棵树有n个结点n-1条边，每棵树结点数比边数少1，(25-15)10棵树25个结点比10条边数少10。</p><h2 id="树的遍历">1.4. 树的遍历</h2><h3 id="先根遍历">1.4.1. 先根遍历</h3><p>若树非空，先访问根结点，再依次对每棵子树进行先根遍历。</p><p><img src="/2021/02/08/数据结构-树/shuangqi.png" alt></p><p>先序遍历结果</p><p>A  B              C       D</p><p>A (B E      F) (C G) (D H I J) </p><p>A (B(E K) F) (C G) (D H I J)</p><p>对应的二叉树转换为：</p><p><img src="/2021/02/08/数据结构-树/nextsibling.png" alt></p><p>二叉树的先序遍历结果为：A B E K F C G D H I J</p><p><code>树的先根遍历序列与这棵树相应二叉树的先序序列相同</code>。</p><h3 id="后根遍历">1.4.2. 后根遍历</h3><p>若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。</p><p><img src="/2021/02/08/数据结构-树/shuangqi.png" alt></p><p>​               B       C           D  A </p><p>(     E  F  B) (G C) (H I J D) A </p><p>((K E) F  B) (G C) (H I J D) A</p><p><img src="/2021/02/08/数据结构-树/nextsibling.png" alt></p><p>中序遍历结果为：K E F B G C H I J D A</p><p><code>树的后根遍历序列与这棵树相应二叉树的中序序列相同</code>。</p><h3 id="层序遍历">1.4.3. 层序遍历</h3><p>广度优先遍历</p><ol><li>若树非空，则根节点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复2直到队列为空</li></ol><p><img src="/2021/02/08/数据结构-树/shuangqi.png" alt></p><p><img src="/2021/02/08/数据结构-树/queue.png" alt></p><h2 id="森林的遍历">1.5. 森林的遍历</h2><h3 id="先序遍历">1.5.1. 先序遍历</h3><p>若森林为非空，则按如下规则进行遍历:</p><ol><li>访问森林中第一棵树的根结点。 </li><li>先序遍历第一棵树中根结点的子树森林。 </li><li>先序遍历除去第一棵树之后剩余的树构成的森林。</li></ol><p><img src="/2021/02/08/数据结构-树/senxian.png" alt></p><p>B                   C        D<br>(B E          F) (C G) (D H        I J) </p><p>(B (E K L) F) (C G) (D (H M) I J)</p><p>效果等同于依次对各个树进行先根遍历</p><p>效果等同于依次对二叉树的先序遍历</p><h3 id="中序遍历">1.5.2. 中序遍历</h3><p>若森林为非空，则按如下规则进行遍历:</p><ol><li>中序遍历森林中第一棵树的根结点的子树森林。 </li><li>访问第一棵树的根结点。 </li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ol><p><img src="/2021/02/08/数据结构-树/senxian.png" alt></p><p>​                B       C                   D </p><p>(        E  F B) (G C) (      H I J  D) </p><p>((K L E) F B) (G C) ((M  H) I J D)</p><p>效果等同于依次对各个树进行后根遍历</p><p>效果等同于依次对二叉树的中序遍历</p><h2 id="树，二叉树，森林遍历对应">1.6. 树，二叉树，森林遍历对应</h2><table><thead><tr><th>树</th><th>森林</th><th>二叉树</th></tr></thead><tbody><tr><td>先根遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr><td>后根遍历</td><td>中序遍历</td><td>中序遍历</td></tr></tbody></table><h1 id="二叉树">2. 二叉树</h1><h2 id="基本概念">2.1. 基本概念</h2><p>二叉树是n(n≥0)个结点的有限集合：</p><ol><li><p>或者为空二叉树，即<em>n</em> = 0。</p></li><li><p>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</p></li></ol><p>特点：(不同于度为2的有序树)</p><ol><li>每个结点至多只有两棵子树 </li><li>左右子树不能颠倒(二叉树是有序树)。</li></ol><p>二叉树的五种状态：</p><p><img src="/2021/02/08/数据结构-树/binary.png" alt></p><h2 id="常考性质-1">2.2. 常考性质</h2><h3 id="n0-n2-1">2.2.1. n0=n2+1</h3><p>设非空二叉树中度为0,1,2的结点个数分别为n<sub>0</sub>,n<sub>1</sub>,n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1(叶子结点比二分支结点多一个)</p><p>假设树中结点总数为 n，则</p><ol><li>n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub></li><li>n =n<sub>1</sub>+2n<sub>2</sub>+1</li></ol><p>2-1得，n<sub>0</sub>=n<sub>2</sub>+1</p><h3 id="二叉树第i层至多结点数">2.2.2. 二叉树第i层至多结点数</h3><p>二叉树第 i 层至多有 2<sup>i</sup>-1 个结点(i≥1)</p><p>m叉树第 i 层至多有 m<sup>i</sup>-1 个结点(i≥1)</p><h3 id="高度为h的二叉树至多结点数">2.2.3. 高度为h的二叉树至多结点数</h3><p>满二叉树：至多有 2<sup>h</sup> − 1个结点</p><p>高度为h的二叉树，若树中只存在度为0或2的结点，结点个数为2h-1</p><h2 id="存储结构">2.3. 存储结构</h2><h3 id="顺序存储">2.3.1. 顺序存储</h3><p>定义一个长度为 MaxSize 的数组 t ，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//结点内数据元素</span></span><br><span class="line">  ElemType value;</span><br><span class="line">  <span class="comment">//结点是否为空</span></span><br><span class="line">  <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode t[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">  t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-树/shunxu.png" alt></p><p>几个重要常考的基本操作：</p><ul><li><p>i的左孩子 ——2i</p></li><li><p>i 的右孩子 ——2i+1</p></li><li><p>i的父节点 ——i/2</p></li><li><p>i 所在的层次 —— $\left \lceil log_{2}(n + 1)\right \rceil$ 或 $\left \lfloor log_{2}n \right \rfloor$ + 1</p></li></ul><p>若<code>完全二叉树</code>中共有n个结点，则</p><ul><li>判断 i 是否有左孩子? ——2i ≤ n </li><li>判断i是否有右孩子? ——2i+1≤n</li><li>判断i是否是叶子/分支结点?——i &gt; $\left \lfloor n/2 \right \rfloor$ </li></ul><p>如果不是完全二叉树，依然按层序将各节点顺序存储，那么无法从结点编号反映出结点间的逻辑关系</p><p>最坏情况：高度为 h 且只有 h 个结点的单支树(所有结点只有右孩子)，也至少需要 2<sup>h</sup>-1 个存储单元</p><p>结论：二叉树的顺序存储结构，<code>只适合存储完全二叉树</code></p><h3 id="链式存储">2.3.2. 链式存储</h3><p>n个结点的二叉链表共有 n+1 个空链域：</p><p>n个结点有2n个指针域，除根结点外n-1个结点都有被指向的指针(总分支数)，故空链域为2n-(n-1)=n+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data = <span class="number">1</span>;</span><br><span class="line">root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新节点-到右子树</span></span><br><span class="line">BiTNode *p = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = <span class="number">2</span>;</span><br><span class="line">p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild = p;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-树/lian.png" alt></p><p>找到指定结点 p 的左/右 孩子——超简单</p><p>如何找到指定结点 p 的 父结点? ——只能从根开始遍历寻找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="comment">//父节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历">2.4. 二叉树的遍历</h2><p>遍历：按照某种次序把所有结点都访问一遍</p><p>层序遍历：基于树的层次特性确定的次序规则</p><p>先/中/后序遍历：基于树的递归特性确定的次序规则，空间复杂度为O(n)</p><p><code>先</code>序遍历：<code>根</code>左右(<code>N</code>LR) </p><p><code>中序</code>遍历：左<code>根</code>右(L<code>N</code>R)</p><p><code>后序</code>遍历：左右<code>根</code>(LR<code>N</code>)</p><p><img src="/2021/02/08/数据结构-树/bianli.png" alt></p><hr><p><img src="/2021/02/08/数据结构-树/express.png" alt></p><h3 id="先序遍历-1">2.4.1. 先序遍历</h3><p><code>先序遍历</code>(PreOrder)的操作过程如下:</p><ol><li><p>若二叉树为空，则什么也不做; </p></li><li><p>若二叉树非空:</p><p><code>访问根结点</code>；</p><p>先序遍历左子树; </p><p>先序遍历右子树。</p></li></ol><h4 id="递归算法">2.4.1.1. 递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    visit(T);</span><br><span class="line">    PreOrder(T-&gt;lchild);</span><br><span class="line">    PreOrder(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法">2.4.1.2. 非递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  BiTree p = T;</span><br><span class="line">  <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">      visit(p);</span><br><span class="line">      Push(S,p);</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      Pop(S,p);</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-树/pre.png" alt></p><h3 id="中序遍历-1">2.4.2. 中序遍历</h3><p><code>中序遍历</code>(InOrder)的操作过程如下:</p><ol><li><p>若二叉树为空，则什么也不做; </p></li><li><p>若二叉树非空:</p><p>中序遍历左子树; </p><p><code>访问根结点</code>；</p><p>中序遍历右子树。</p></li></ol><h4 id="递归算法-1">2.4.2.1. 递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    InOrder(T-&gt;lchild);</span><br><span class="line">    visit(T);</span><br><span class="line">    InOrder(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法-1">2.4.2.2. 非递归算法</h4><ol><li><p>沿着根的左孩子开始，依次入栈，直到左孩子为空</p></li><li><p>栈顶元素出栈并访问该元素，若其右孩子为空，继续执行2，若其右孩子非空，则右子树转为执行1。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  BiTree p = T;</span><br><span class="line">  <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">      Push(S,p);</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      Pop(S,p);</span><br><span class="line">      visit(p);</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历">2.4.3. 后序遍历</h3><p><code>后序遍历</code>(PostOrder)的操作过程如下:</p><ol><li><p>若二叉树为空，则什么也不做; </p></li><li><p>若二叉树非空:</p><p>后序遍历左子树; </p><p>后序遍历右子树；</p><p><code>访问根结点</code>；</p></li></ol><h4 id="递归算法-2">2.4.3.1. 递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    PostOrder(T-&gt;lchild);</span><br><span class="line">    PostOrder(T-&gt;rchild);</span><br><span class="line">    visit(T);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法-2">2.4.3.2. 非递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  BiTree p = T;</span><br><span class="line">  <span class="comment">//指向最近访问的结点</span></span><br><span class="line">  BiTree r = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">      Push(S,p);</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      GetTop(S,p);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>&amp;&amp;p-&gt;rchild!=r)&#123;</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">      Pop(S,p);</span><br><span class="line">        r = p;</span><br><span class="line">        <span class="comment">//出栈访问完就完成了p为根的子树，p置空</span></span><br><span class="line">      p=<span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历-1">2.4.4. 层序遍历</h3><p>算法思想:</p><ol><li>初始化一个辅助队列</li><li>根结点入队 </li><li>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话) </li><li>重复3直至队列为空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//存指针</span></span><br><span class="line">  BiTNode *data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  LinkQueue Q;</span><br><span class="line">  InitQueue(Q);</span><br><span class="line">  BiTree p;</span><br><span class="line">  EnQueue(Q,T);</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">    DeQueue(Q,p);</span><br><span class="line">    visit(p);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      EnQueue(Q,p-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="由遍历序列构造二叉树">2.4.5. 由遍历序列构造二叉树</h3><p>若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树</p><p>前序、后序、层序序列的两两组合无法唯一 确定一科二叉树</p><h4 id="前序-中序遍历序列">2.4.5.1. 前序 + 中序遍历序列</h4><p>前序遍历：根结点、前序遍历左子树、前序遍历右子树</p><p>中序遍历：中序遍历左子树、根结点、中序遍历右子树</p><p><img src="/2021/02/08/数据结构-树/prein.png" alt></p><p>eg:</p><p><img src="/2021/02/08/数据结构-树/pre1.png" alt><img src="/2021/02/08/数据结构-树/pre2.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知先序遍历数组 pre[]</span></span><br><span class="line"><span class="comment">中序遍历数组 in[]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BiTNode * <span class="title">create</span><span class="params">(<span class="keyword">int</span> prel,<span class="keyword">int</span> prer,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prel&gt;prer)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BiTNode *root=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">  <span class="comment">//先序遍历都是从根开始</span></span><br><span class="line">  root-&gt;data = pre[prel];</span><br><span class="line">  <span class="keyword">int</span> i=inl;</span><br><span class="line">  <span class="comment">//求根在中序遍历中的位置</span></span><br><span class="line">  <span class="keyword">for</span>(;i&lt;=inr;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(in[i]==pre[prel])&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//得左子树数量</span></span><br><span class="line">  <span class="keyword">int</span> left = i-inl;</span><br><span class="line">  <span class="comment">//分别处理左右子树</span></span><br><span class="line">  root-&gt;lchild = create(prel+<span class="number">1</span>,prel+left,inl,i<span class="number">-1</span>);</span><br><span class="line">  root-&gt;rchild = create(prel+left+<span class="number">1</span>,prer,i+<span class="number">1</span>,inr);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序-中序遍历序列">2.4.5.2. 后序 + 中序遍历序列</h4><p>后序遍历：前序遍历左子树、前序遍历右子树、根结点</p><p>中序遍历：中序遍历左子树、根结点、中序遍历右子树</p><p><img src="/2021/02/08/数据结构-树/postin.png" alt></p><p>Eg:</p><p><img src="/2021/02/08/数据结构-树/post1.png" alt> <img src="/2021/02/08/数据结构-树/pre2.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知后序遍历数组 post[]</span></span><br><span class="line"><span class="comment">中序遍历数组 in[]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BiTNode * <span class="title">create</span><span class="params">(<span class="keyword">int</span> postl,<span class="keyword">int</span> postr,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(postl&gt;postr)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BiTNode *root=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">  <span class="comment">//后序遍历为左右根</span></span><br><span class="line">  root-&gt;data = post[postr];</span><br><span class="line">  <span class="keyword">int</span> i=inl;</span><br><span class="line">  <span class="comment">//求根在中序遍历中的位置</span></span><br><span class="line">  <span class="keyword">for</span>(;i&lt;=inr;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(in[i]==post[postr])&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//得左子树数量</span></span><br><span class="line">  <span class="keyword">int</span> left = i-inl;</span><br><span class="line">  <span class="comment">//分别处理左右子树</span></span><br><span class="line">  root-&gt;lchild = create(postl,postl+left<span class="number">-1</span>,inl,i<span class="number">-1</span>);</span><br><span class="line">  root-&gt;rchild = create(prel+left,prer<span class="number">-1</span>,i+<span class="number">1</span>,inr);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序-中序遍历序列">2.4.5.3. 层序 + 中序遍历序列</h4><p><img src="/2021/02/08/数据结构-树/level.png" alt></p><p>Eg:</p><p><img src="/2021/02/08/数据结构-树/level1.png" alt><img src="/2021/02/08/数据结构-树/pre2.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知层序遍历数组 level[]</span></span><br><span class="line"><span class="comment">中序遍历数组 in[]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BiTNode * <span class="title">create</span><span class="params">(<span class="keyword">int</span> levell,<span class="keyword">int</span> levelr,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(inl&gt;inr)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i = inl;</span><br><span class="line">  inr flag = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//每一个出现在中序中的元素为根</span></span><br><span class="line">  <span class="keyword">for</span>(;levell&lt;=levelr;levell++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=inr;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(in[i]==level[levell])&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  BiTNode *root=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">  root-&gt;data = in[i];</span><br><span class="line">  root-&gt;lchild = create(levell+<span class="number">1</span>,levelr,inl,i<span class="number">-1</span>);</span><br><span class="line">  root-&gt;rchild = create(levell+<span class="number">1</span>,levelr,i+<span class="number">1</span>,inr);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="满二叉树-得先序求后序">2.4.6. 满二叉树-得先序求后序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[],post[];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreToPost</span><span class="params">(<span class="keyword">int</span> prel,<span class="keyword">int</span> prer,<span class="keyword">int</span> postl,<span class="keyword">int</span> postr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(prel&gt;prer)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  post[postr]=pre[prel];</span><br><span class="line">  <span class="keyword">int</span> half = (prer-prel)/<span class="number">2</span>;</span><br><span class="line">  PreToPost(prel+<span class="number">1</span>,prel+half,postl,postl+half<span class="number">-1</span>);</span><br><span class="line">  PreToPost(prel+half+<span class="number">1</span>,prelr,postl+half,postr<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树的深度">2.5. 求二叉树的深度</h2><h3 id="递归版本">2.5.1. 递归版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">  <span class="keyword">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">  <span class="comment">//树深度=Max(左子树深度,右子树深度)+1</span></span><br><span class="line">  <span class="keyword">return</span> l&gt;r?(l+<span class="number">1</span>):(r+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归版本">2.5.2. 非递归版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  InitQueue(Q);</span><br><span class="line">  <span class="comment">//保留本层最后一个结点</span></span><br><span class="line">  BiTNode *last =T;</span><br><span class="line">  BiTNode *newNode = T;</span><br><span class="line">  EnQueue(Q,T);</span><br><span class="line">  <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">    BiTNode r;</span><br><span class="line">    DeQueue(Q,r);</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      EnQueue(Q,r-&gt;lchild);</span><br><span class="line">      newNode = r-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      EnQueue(Q,r-&gt;rchild);</span><br><span class="line">      newNode = r-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到达同层最后一个结点，更新到下一层最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span>(last==r)&#123;</span><br><span class="line">      depth++;</span><br><span class="line">      last = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="满二叉树">2.6. 满二叉树</h2><p>一棵高度为<em>h</em>，且含有2<sup>h</sup> - 1个结点的二叉树</p><p><img src="/2021/02/08/数据结构-树/man.png" alt></p><p>特点:</p><ol><li>只有最后一层有叶子结点</li><li>不存在度为 1 的结点</li><li>按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为2i+1；结点i的父节点为𝑖/2(如果有的话)</li></ol><h2 id="完全二叉树">2.7. 完全二叉树</h2><p>当且仅当其每个结点都与高度为h的满二叉树中编号为1~<em>n</em>的结点一一对应时，称为完全二叉树</p><p><img src="/2021/02/08/数据结构-树/wanquan.png" alt></p><p>特点:</p><ol><li>只有最后两层可能有叶子结点 </li><li>最多只有一个度为1的结点</li><li>按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为2i+1；结点i的父节点为𝑖/2(如果有的话)</li><li>i$\leq$$\left \lfloor n/2 \right \rfloor $为分支结点，i&gt;$\left \lfloor n/2 \right \rfloor $为叶子结点</li><li><code>如果某结点只有一个孩子， 那么一定是左孩子</code></li></ol><h3 id="常见考点">2.7.1. 常见考点</h3><h4 id="有n个结点的完全二叉树的高度h为">2.7.1.1. 有n个结点的完全二叉树的高度h为?</h4><p>具有<em>n</em>个(<em>n</em> &gt; 0)结点的完全二叉树的高度h为$\left \lceil log_{2}(n + 1) \right \rceil$或$\left \lfloor log_{2}n \right \rfloor$+ 1</p><p>高为h的满二叉树共有2<sup>h</sup> −1个结点 </p><p>高为h-1的满二叉树共有2<sup>h-1</sup>−1个结点</p><p><img src="/2021/02/08/数据结构-树/wanh.png" alt></p><p>第 <em>i</em> 个结点所在层次为 $\left \lceil log_{2}(n + 1) \right \rceil$ 或 $\left \lfloor log_{2}n \right \rfloor$+1</p><h4 id="由结点数n推出度为0-1-2的结点个数">2.7.1.2. 由结点数n推出度为0,1,2的结点个数</h4><p>完全二叉树最多只有一个度为1的结点，即 n<sub>1</sub>=0或1<br> n<sub>0</sub> = n<sub>2</sub> + 1 -&gt; n<sub>0</sub> + n<sub>2</sub> 一定是奇数</p><p>若完全二叉树有2k个(偶数)个结点，则必有n<sub>1</sub>=1，n<sub>0</sub> = k，n<sub>2</sub> = k-1</p><p>若完全二叉树有2k-1个(奇数)个结点，则必有n<sub>1</sub>=0，n<sub>0</sub> = k，n<sub>2</sub> = k-1</p><h2 id="线索二叉树">2.8. 线索二叉树</h2><p>传统的二叉链表仅体现一种父子关系，不能直接得到结点遍历中的前驱或后继。n个结点共n+1个空指针(度为1—1个空指针，度为2—2个空指针，总空指针数=n<sub>1</sub>+2n<sub>2</sub>=n<sub>1</sub>+n<sub>0</sub>+1+n<sub>2</sub>=n+1)。引入线索二叉树正是为了加快查找结点前驱和后继的速度。而二叉树的线索化就是将二叉链表的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化实质是遍历一次二叉树。</p><p><code>线索二叉树是一种物理结构</code>：二叉树是逻辑结构，线索二叉树是加上线索后的链表结构。</p><p>中序线索二叉树——线索 指向中序前驱、中序后继</p><p>先序线索二叉树——线索 指向先序前驱、先序后继</p><p>后序线索二叉树——线索 指向后序前驱、后序后继</p><table><thead><tr><th></th><th>中序线索二叉树</th><th>先序线索二叉树</th><th>后序线索二叉树</th></tr></thead><tbody><tr><td>找前驱</td><td>☑️</td><td>$\times$</td><td>☑️</td></tr><tr><td>找后继</td><td>☑️</td><td>☑️</td><td>$\times$</td></tr></tbody></table><h3 id="中序线索二叉树">2.8.1. 中序线索二叉树</h3><p><img src="/2021/02/08/数据结构-树/zhongsuo1.png" alt></p><h4 id="存储结构-1">2.8.1.1. 存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="comment">//左，右线索标志</span></span><br><span class="line">  <span class="comment">//tag==0，表示指针指向孩子 </span></span><br><span class="line">  <span class="comment">//tag==1，表示指针是“线索”</span></span><br><span class="line">  <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-树/suotag.png" alt></p><p><img src="/2021/02/08/数据结构-树/tag.png" alt></p><p><img src="/2021/02/08/数据结构-树/lrtag.png" alt></p><h4 id="概述">2.8.1.2. 概述</h4><p>二叉树的中序遍历序列如何找到指定结点p在中序遍历序列中的前驱？如何找到p的中序后继？</p><p><img src="/2021/02/08/数据结构-树/zhongsuo.png" alt></p><p>思路:</p><p>从根节点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针 pre 记录上一个被访问的结点 </p><ol><li><p>当q==p时，pre为前驱</p></li><li><p>当pre==p时，q为后继</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局遍历，用于查找结点p的前驱</span></span><br><span class="line"><span class="comment">//p指向目标结点</span></span><br><span class="line">BiTNode *p;</span><br><span class="line"><span class="comment">//指向当前访问结点的前驱</span></span><br><span class="line">BiTNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//用于记录最终结果</span></span><br><span class="line">BiTNode *final = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(BiTNode *q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当前访问结点刚好是结点p</span></span><br><span class="line">  <span class="keyword">if</span>(q==p)&#123;</span><br><span class="line">    <span class="comment">//找到p的前驱</span></span><br><span class="line">    final = pre;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">    pre=q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPre</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    findPre(T-&gt;lchild);</span><br><span class="line">    visit(T);</span><br><span class="line">    findPre(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序线索化">2.8.1.3. 中序线索化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    InThread(T-&gt;lchild);</span><br><span class="line">    visit(T);</span><br><span class="line">    InThread(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">  <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    q-&gt;lchild=pre;</span><br><span class="line">    q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">    pre-&gt;rchild=q;</span><br><span class="line">    pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//中序线索化</span></span><br><span class="line">    InTread(T);</span><br><span class="line">    <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="comment">//处理最后一个结点</span></span><br><span class="line">      pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找后继">2.8.1.4. 找后继</h4><p>在中序线索二叉树中找到指定结点 p 的中序后继 next</p><ol><li><p>若 p-&gt;rtag==1，则 next = p-&gt;rchild </p></li><li><p>若 p-&gt;rtag==0</p><p>左 根 <code>右</code></p><p>左 根 (<code>左</code> 根 右)</p><p>左 根 ((<code>左</code> 根 右) 根 右)</p><p>next = p的右子树中最左下结点</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索二叉树第一个结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="comment">//找到最左下结点，可能为非叶子结点</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">    p=p-&gt;lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树中找到p的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> FirstNode(p-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(TreadNode *p=FirstNode(T);p!=<span class="literal">NULL</span>;p=NextNode(p))&#123;</span><br><span class="line">    visit(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找前驱">2.8.1.5. 找前驱</h4><p>在中序线索二叉树中找到指定结点p 的中序前驱 pre</p><ol><li><p>若 p-&gt;ltag==1，则 pre = p-&gt;lchild </p></li><li><p>若 p-&gt;ltag==0</p><p>  <code>左</code> 根 右<br> (左 根 <code>右</code>)  根 右</p><p>(左 根 (左 根 <code>右</code>) ) 根 右</p><p>pre = p 的左子树中最右下结点</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序线索二叉树最后一个结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="comment">//找到最右下结点，可能为非叶子结点</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">    p=p-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树中找到p的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> LastNode(p-&gt;lchild);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(TreadNode *p=LastNode(T);p!=<span class="literal">NULL</span>;p=preNode(p))&#123;</span><br><span class="line">    visit(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先序线索二叉树">2.8.2. 先序线索二叉树</h3><p><img src="/2021/02/08/数据结构-树/xiansuo.png" alt></p><h4 id="存储结构-2">2.8.2.1. 存储结构</h4><p><img src="/2021/02/08/数据结构-树/xiansuo1.png" alt></p><h4 id="先序线索化">2.8.2.2. 先序线索化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    visit(T);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不加T-&gt;ltag==0，</span></span><br><span class="line"><span class="comment">    将与visit中的q-&gt;lchild=pre;</span></span><br><span class="line"><span class="comment">    再次访问又将是q-&gt;lchild,</span></span><br><span class="line"><span class="comment">    会导致线索成圈</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">    PreThread(T-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    PreThread(T-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">  <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    q-&gt;lchild=pre;</span><br><span class="line">    q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">    pre-&gt;rchild=q;</span><br><span class="line">    pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//中序线索化</span></span><br><span class="line">    InTread(T);</span><br><span class="line">    <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="comment">//处理最后一个结点</span></span><br><span class="line">      pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找后继-1">2.8.2.3. 找后继</h4><p>在先序线索二叉树中找到指定结点p 的先序后继 next</p><ol><li><p>若 p-&gt;rtag==1，则 next = p-&gt;rchild </p></li><li><p>若 p-&gt;rtag==0：</p><p>若p有左孩子， 则先序后继为左孩子</p><p> 根 <code>左</code> 右<br> 根 (<code>根</code> 左 右) 右</p><p>若p没有左孩子，则先序后继为右孩子</p><p>根 <code>右</code></p><p>根 (<code>根</code> 左 右)</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="comment">//有左孩子</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//有后继指针or有右孩子</span></span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找前驱-1">2.8.2.4. 找前驱</h4><p>在先序线索二叉树中找到指定结点p 的先序前驱 pre</p><ol><li><p>若 p-&gt;ltag==1，则 next = p-&gt;lchild </p></li><li><p>若 p-&gt;ltag==0</p><p><code>根</code> 左 右</p><p>先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱</p><p>除非用土办法从头开始先序遍历</p></li></ol><p>改用<code>三叉链表</code>可以找到父节点</p><ol><li><p>如果能找到 p 的父节点， 且p是左孩子</p><p><code>根</code> 左 右</p><p> 根 (<code>根</code> 左 右) 右 </p><p>p的父节点即为其前驱</p></li><li><p>如果能找到 p 的父节点，且 p是右孩子，其左兄弟为空</p><p><code>根</code> 右<br>根 (<code>根</code> 左 右)</p><p>p的父节点即为其前驱</p></li><li><p>如果能找到 p 的父节点，且p是右孩子，其左兄弟非空</p><p>根 <code>左</code> 右</p><p>p的前驱为左兄弟子树中最后一个被先序遍历的结点   </p></li></ol><h3 id="后序线索二叉树">2.8.3. 后序线索二叉树</h3><p><img src="/2021/02/08/数据结构-树/housuo.png" alt></p><h4 id="存储结构-3">2.8.3.1. 存储结构</h4><p><img src="/2021/02/08/数据结构-树/housuo1.png" alt></p><h4 id="后序线索化">2.8.3.2. 后序线索化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    PostThread(T-&gt;lchild);</span><br><span class="line">    PostThread(T-&gt;rchild);</span><br><span class="line">    visit(T);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">  <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    q-&gt;lchild=pre;</span><br><span class="line">    q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">    pre-&gt;rchild=q;</span><br><span class="line">    pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//中序线索化</span></span><br><span class="line">    InTread(T);</span><br><span class="line">    <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="comment">//处理最后一个结点</span></span><br><span class="line">      pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找前驱-2">2.8.3.3. 找前驱</h4><p>在后序线索二叉树中找到指定结点p 的后序前驱 pre</p><ol><li><p>若 p-&gt;ltag==1，则 pre = p-&gt;lchild </p></li><li><p>若 p-&gt;ltag==0</p><p>若p有右孩子，则后序前驱为右孩子</p><p>左 <code>右</code> 根</p><p>左 (左 右 <code>根</code>) 根</p><p>若p没有右孩子，则后序前驱为左孩子</p><p><code>左</code> 根</p><p>(左 右 <code>根</code>) 根</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找后继-2">2.8.3.4. 找后继</h4><p>在后序线索二叉树中找到指定结点p 的后序后继 next</p><ol><li><p>若 p-&gt;rtag==1，则 next = p-&gt;rchild </p></li><li><p>若 p-&gt;rtag==0</p><p>左 右 根</p><p>后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继</p></li></ol><p>改用<code>三叉链表</code>可以找到父节点</p><ol><li><p>如果能找到 p 的父节点， 且p是右孩子</p><p>左 右 <code>根</code></p><p>左 (左 右 <code>根</code>) 根 </p><p>p的父节点即为其后继</p></li><li><p>如果能找到 p 的父节点，且 p是左孩子，其右兄弟为空</p><p><code>左</code> 根<br> (左 右 <code>根</code>) 根</p><p>p的父节点即为其后继</p></li><li><p>如果能找到 p 的父节点，且 p是左孩子，其右兄弟非空</p><p>p的后继为右兄弟子树中第一个被后序遍历的结点</p></li></ol><h4 id="后序线索树仍需栈的支持">2.8.3.5. 后序线索树仍需栈的支持</h4><p><img src="/2021/02/08/数据结构-树/houxian.png" alt></p><p>结点6的rchild指向的是其右孩子结点7，而其后继实际为双亲结点4</p><h2 id="二叉排序树">2.9. 二叉排序树</h2><p>二叉排序树，又称二叉查找树 (BST，Binary Search Tree)，可用于元素的排序、搜索</p><p>一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ol><li><p>左子树上所有结点的关键字均小于根结点的关键字 </p></li><li><p>右子树上所有结点的关键字均大于根结点的关键字</p></li><li><p>左子树和右子树又各是一棵二叉排序树。</p></li></ol><p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值 -&gt; 进行中序遍历，可以得到一个递增的有序序列</p><h3 id="查找">2.9.1. 查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度 - O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">    <span class="comment">//小于根结点，在左子树查找</span></span><br><span class="line">    <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line">      T=T-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//大于根结点，在右子树查找</span></span><br><span class="line">      T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归实现——空间复杂度为O(h)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(key==T-&gt;key)&#123;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line">    <span class="comment">//小于根结点，在左子树查找</span></span><br><span class="line">     BST_Search(T-&gt;lchild,key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//大于根结点，在右子树查找</span></span><br><span class="line">     BST_Search(T-&gt;rchild,key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树的插入">2.9.2. 二叉排序树的插入</h3><p>若原二叉排序树为空，则直接插入结点;否则，若关键字k小于根结 点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树</p><p>新插入的结点一定是叶子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    T=(BSTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    T-&gt;key=k;</span><br><span class="line">    T-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line">    <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树的构造">2.9.3. 二叉排序树的构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBST</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> str[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  BSTree T=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    BST_Insert(T,str[i]);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>不同的关键字序列可能得到同款二叉排序树</code></p><p>按照序列str={50, 26, 21, 30, 66, 60, 70, 68}建立BST</p><p><img src="/2021/02/08/数据结构-树/bst1.png" alt></p><p>按照序列str={26, 21, 30, 50, 60, 66, 68, 70}建立BST</p><p><img src="/2021/02/08/数据结构-树/bst2.png" alt></p><h3 id="二叉排序树的删除">2.9.4. 二叉排序树的删除</h3><ol><li><p>若被删除结点是叶结点，则直接删除，不会破坏二叉排序树的性质。</p></li><li><p>若结点只有一棵左子树或右子树，则让其子树成为其父结点的子树，替代结点的位置。</p></li><li><p>若结点有左、右两棵子树，则令其直接后继(或直接前驱)替代，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况</p><p>中序遍历中：</p><ul><li><p>取结点的后继：取其右子树中最左下结点(该节点一定没有左子树)</p><p><img src="/2021/02/08/数据结构-树/shushan1.png" alt><img src="/2021/02/08/数据结构-树/shushan2.png" alt></p></li><li><p>取结点的前驱：取其左子树中最右下结点(该节点一定没有右子树)</p><p><img src="/2021/02/08/数据结构-树/ershan1.png" alt><img src="/2021/02/08/数据结构-树/ershan2.png" alt></p></li></ul></li></ol><h3 id="查找效率分析">2.9.5. 查找效率分析</h3><p>查找长度——在查找运算中，需要对比关键字的次数称为查找长度。</p><p><img src="/2021/02/08/数据结构-树/xiaolv.png" alt></p><p>查找失败的平均查找长度 <strong>ASL</strong>(<strong>Average Search Length</strong>) </p><p>ASL<sub>失败</sub> = $\frac{(3<em>7 + 4</em>2)}{9}$ = 3.22</p><p>ASL<sub>成功</sub> = $\frac{1<em>1+2</em>2+3<em>4+4</em>1}{8}$ = 2.625</p><h2 id="平衡二叉树">2.10. 平衡二叉树</h2><h3 id="定义-1">2.10.1. 定义</h3><p>平衡二叉树(Balanced Binary Tree)，G. M. Adelson-Velsky和 E. M. Landis - AVL树</p><p>树上任一结点的左子树和右子树的深度之差不超过1。能有更高的搜索效率</p><p>结点的平衡因子=左子树高-右子树高。</p><p>平衡二叉树结点的平衡因子的值只可能是−1、0或1。</p><h3 id="存储结构-4">2.10.2. 存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树的插入">2.10.3. 平衡二叉树的插入</h3><p>在二叉排序树中插入新结点后，从插入点往回找到第一个不平衡结点，调整以该结点为根的子树。即每次调整的对象都是“最小不平衡子树”。</p><h4 id="调整最小不平衡子树LL">2.10.3.1. 调整最小不平衡子树LL</h4><p><img src="/2021/02/08/数据结构-树/ll.png" alt></p><p>LL平衡旋转(<code>右单旋转</code>)。由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子<code>B向右上旋转</code>代替A成为根结点，将<code>A结点向右下旋转</code>成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。</p><p><strong>代码实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现根右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(AVLNode* &amp;root)</span></span>&#123;</span><br><span class="line">AVLNode *B = root-&gt;lchild;</span><br><span class="line">root-&gt;lchild = B-&gt;rchild;</span><br><span class="line">B-&gt;rchild = root;</span><br><span class="line">root = B;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eg:</p><p><img src="/2021/02/08/数据结构-树/avl.png" alt><img src="/2021/02/08/数据结构-树/avl1.png" alt></p><p><img src="/2021/02/08/数据结构-树/avl2.png" alt></p><h4 id="调整最小不平衡子树RR">2.10.3.2. 调整最小不平衡子树RR</h4><p><img src="/2021/02/08/数据结构-树/rr.png" alt></p><p>RR平衡旋转(<code>左单旋转</code>)。由于在结点A的右孩子(R)的右子树(R)上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将<em>A</em>的右孩子<code>B向左上旋转</code>代替A成为根结点，将<code>A结点向左下旋转</code>成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现根左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(AVLNode* &amp;root)</span></span>&#123;</span><br><span class="line">AVLNode *B = root-&gt;rchild;</span><br><span class="line">root-&gt;rchild = B-&gt;lchild;</span><br><span class="line">B-&gt;lchild = root;</span><br><span class="line">root = B;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整最小不平衡子树-LR">2.10.3.3. 调整最小不平衡子树(LR)</h4><p><img src="/2021/02/08/数据结构-树/lr.png" alt></p><p><img src="/2021/02/08/数据结构-树/lr2.png" alt></p><p>LR平衡旋转(<code>先左后右双旋转</code>)。由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.先右子树左旋——L(root-&gt;lchild);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(AVLNode* &amp;root)</span></span>&#123;</span><br><span class="line">AVLNode *B = root-&gt;rchild;</span><br><span class="line">root-&gt;rchild = B-&gt;lchild;</span><br><span class="line">B-&gt;lchild = root;</span><br><span class="line">root = B;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 再根右旋——R(root);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(AVLNode* &amp;root)</span></span>&#123;</span><br><span class="line">AVLNode *B = root-&gt;lchild;</span><br><span class="line">root-&gt;lchild = B-&gt;rchild;</span><br><span class="line">B-&gt;rchild = root;</span><br><span class="line">root = B;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整最小不平衡子树-RL">2.10.3.4. 调整最小不平衡子树(RL)</h4><p><img src="/2021/02/08/数据结构-树/rl1.png" alt></p><p><img src="/2021/02/08/数据结构-树/rl2.png" alt></p><p>RL平衡旋转(<code>先右后左双旋转</code>)。由于在A的右孩子(R)的左子树(L)上插入新结点，<em>A</em>的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.先左子树右旋——R(root-&gt;rchild);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(AVLNode* &amp;root)</span></span>&#123;</span><br><span class="line">AVLNode *B = root-&gt;lchild;</span><br><span class="line">root-&gt;lchild = B-&gt;rchild;</span><br><span class="line">B-&gt;rchild = root;</span><br><span class="line">root = B;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 再根左旋——L(root);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(AVLNode* &amp;root)</span></span>&#123;</span><br><span class="line">AVLNode *B = root-&gt;rchild;</span><br><span class="line">root-&gt;rchild = B-&gt;lchild;</span><br><span class="line">B-&gt;lchild = root;</span><br><span class="line">root = B;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找效率分析-1">2.10.4. 查找效率分析</h3><p>《An algorithm for the organizaSon of informaSon》——G.M. Adelson- Velsky 和 E.M. Landis ,1962</p><p>若树高为h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能超过 O(h)</p><p>平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1。 假设以n<sub>h</sub>表示深度为<em>h</em>的平衡树中含有的最少结点数。</p><p>则有n<sub>0</sub> =0，n<sub>1</sub> =1，n<sub>2</sub>=2，并且有 ${\color{Red} n_{h}=n_{h−1}+n_{h−2}+1}$</p><p>可以证明含有n个结点的平衡二叉树的最大深度为O(log<sub>2</sub>n) ，平衡二叉树的平均查找长度为O(log<sub>2</sub>n)</p><h2 id="哈夫曼树">2.11. 哈夫曼树</h2><h3 id="带权路径长度">2.11.1. 带权路径长度</h3><p>结点的<code>权</code>：有某种现实含义的数值(如:表示结点的重要性等)</p><p><code>结点的带权路径长度</code>：从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积</p><p><code>树的带权路径长度</code>：树中所有叶结点的带权路径长度之和 (WPL, Weighted Path Length)</p><p>WPL = $\sum_{i=1}^{n}w_{i}l_{i}$</p><p><img src="/2021/02/08/数据结构-树/wpl.png" alt></p><p>WPL = (5+1+10+3)x3=57</p><h3 id="哈夫曼树的定义">2.11.2. 哈夫曼树的定义</h3><p>在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树</p><h3 id="哈夫曼树的构造">2.11.3. 哈夫曼树的构造</h3><p>给定n个权值分别为w<sub>1</sub>, w<sub>2</sub>,…, w<sub>n</sub>的结点，构造哈夫曼树的算法描述如下: </p><ol><li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 </li><li>构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。 </li><li>从<em>F</em>中删除刚才选出的两棵树，同时将新得到的树加入<em>F</em>中。 </li><li>重复步骤2和3，直至F中只剩下一棵树为止。</li></ol><p>Eg:</p><p><img src="/2021/02/08/数据结构-树/ha1.png" alt><img src="/2021/02/08/数据结构-树/ha2.png" alt><img src="/2021/02/08/数据结构-树/ha3.png" alt><img src="/2021/02/08/数据结构-树/ha4.png" alt></p><p>WPL<sub>min</sub>=1x7+2x3+3x2+4x1+4x2=31</p><h3 id="哈夫曼树特点">2.11.4. 哈夫曼树特点</h3><ol><li><p>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大 </p></li><li><p>哈夫曼树的结点总数为2<em>n</em> − 1</p></li><li><p>哈夫曼树中不存在度为1的结点。 </p></li><li><p>哈夫曼树并不唯一，但WPL必然相同且为最优(结点放置顺序左右任意)</p></li></ol><h3 id="哈夫曼编码">2.11.5. 哈夫曼编码</h3><p>有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点 的权值，根据之前介绍的方法构造哈夫曼树</p><p>电报——点、划 两个信号(二进制0/1)</p><p><strong>假设，100题中有80题选C，10题选A，8题选B，2题选D</strong> </p><h4 id="固定长度编码">2.11.5.1. 固定长度编码</h4><p>每个字符用相等长度的二进制位表示</p><p>构造树——并不是哈夫曼树：</p><p><img src="/2021/02/08/数据结构-树/acii.png" alt></p><p>每个字符用长度为2的二进制表示：</p><p>A——00 </p><p>B——01 </p><p>C——10 </p><p>D——11</p><p>故所有答案的二进制长度(WPL)=80x2+10x2+8x2+2x2=200 bit</p><h4 id="可变长度编码">2.11.5.2. 可变长度编码</h4><p>允许对不同字符用不等长的二进制位表示</p><p>若没有一个编码是另一个编码的前缀，则称这样的编码为<code>前缀编码</code></p><p>构造哈夫曼树</p><p><img src="/2021/02/08/数据结构-树/acii2.png" alt></p><p>每个字符用长度为2的二进制表示：</p><p>C——0 </p><p>A——10 </p><p>B——111 </p><p>D——110</p><p>所有答案的二进制长度(WPL)= 80x1+10x2+2x3+8x3=130bit</p><p>前缀码解码无歧义：任何字符码都不是其他码的前缀</p><p>CAAABD：0101010111110 没有歧义</p><h4 id="哈夫曼编码不唯一">2.11.5.3. 哈夫曼编码不唯一</h4><p>哈夫曼树不唯一，因此哈夫曼编码不唯一</p><p><img src="/2021/02/08/数据结构-树/acii3.png" alt></p><p>C——1 </p><p>A——00 </p><p>B——011 </p><p>D——010</p><p>WPL= 80x1+10x2+2x3+8x3=130</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;树，森林，满二叉树，完全二叉树，二叉排序树，平衡二叉树，线索二叉树，森林与二叉树的转换，哈夫曼树&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构04-串</title>
    <link href="/2021/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/"/>
    <id>/2021/02/08/数据结构-串/</id>
    <published>2021-02-08T14:54:03.000Z</published>
    <updated>2021-05-22T05:08:22.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">字符串的朴素匹配与KMP模式匹配</blockquote><a id="more"></a><p>视频讲解，习题讲解，思维导图，PPT资源</p><p>链接: <a href="https://pan.baidu.com/s/15c5BVuCkY1lSOmIoDM1XxA" target="_blank" rel="noopener">https://pan.baidu.com/s/15c5BVuCkY1lSOmIoDM1XxA</a>  密码: v4pc</p><h1 id="串的基本定义">1. 串的基本定义</h1><p>串，即字符串(String)是由零个或多个字符组成的有限序列。一般记为 S = ‘a<sub>1</sub> a<sub>2</sub>······a<sub>n</sub>‘ (n≥0) </p><p>其中，S是串名，单引号括起来的字符序列是串的值；a<sub>i</sub>可以是字母、数字或其他字符；串中字符的个数n称为串的长度。n= 0时的串称为空串(用∅表示)。</p><p>例:</p><p>有的地方用双引号(如Java、C)，有的地方用单引号(如python)</p><p>S=”HelloWorld!”</p><p>T=”iPhone 11 Pro Max?”</p><p><code>子串</code>：串中任意个连续的字符组成的子序列。                     Eg：’iPhone’，’Pro M’ 是串T 的子串</p><p><code>主串</code>：包含子串的串。                                                           Eg：T 是子串’iPhone’的主串</p><p><code>字符在主串中的位置</code>：字符在串中的序号。                            Eg：‘1’在T中的位置是8(第一次出现)</p><p><code>子串在主串中的位置</code>：子串的第一个字符在主串中的位置 。Eg：’11 Pro’在 T 中的位置为8</p><p><strong>空串 <em>V.S</em> 空格串:</strong></p><p>M=‘’“ 是空串</p><p>N=‘   ’  是由三个空格字符组成的空格串，每个空格字符占1B</p><p>串是一种特殊的线性表，数据元素之间呈线性关系</p><p>串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符等)</p><p>串的基本操作，如增删改查等通常以子串为操作对象</p><h1 id="串的基本操作">2. 串的基本操作</h1><p>假设有串T=“”，S=”iPhone 11 Pro Max?”，W=“Pro”</p><p>StrAssign(&amp;T,chars)：<code>赋值</code>操作。把串T赋值为chars。</p><p>StrCopy(&amp;T,S)：<code>复制</code>操作。由串S复制得到串T。</p><p>StrEmpty(S)：<code>判空</code>操作。若S为空串，则返回TRUE，否则返回FALSE。 </p><p>StrLength(S)：求<code>串长</code>。返回串S的元素个数。</p><p>ClearString(&amp;S)：<code>清空</code>操作。将S清为空串。 </p><p>DestroyString(&amp;S)：<code>销毁</code>串。将串S销毁(回收存储空间)。 </p><p>Concat(&amp;T,S1,S2)：串<code>联接</code>。用T返回由S1和S2联接而成的新串 </p><p>SubString(&amp;Sub,S,pos,len)：求<code>子串</code>。用Sub返回串S的第pos个字符起长度为len的子串。 </p><p>Index(S,T)：<code>定位</code>操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的 位置;否则函数值为0。 </p><p>StrCompare(S,T)：<code>比较</code>操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0;若S&lt;T，则返回值&lt;0。</p><ul><li><p>“abandon” &lt; “aboard” ：从第一个字符开始往后依次对比， 先出现更大字符的串就更大</p></li><li><p>“abstract” &lt; “abstraction”：长串的前缀与短串相同时，长串更大</p></li><li><p>“academic”=“academic”：只有两个串完全相同时，才相等</p></li></ul><p>Eg：</p><p>执行基本操作 Concat(&amp;T, S, W) 后，T=“iPhone 11 Pro Max?Pro” – 存储空间扩展? </p><p>执行基本操作 SubString(&amp;T ,S, 4, 6)后，T=“one 11”</p><p>执行基本操作 Index(S, W)后，返回值为 11</p><h1 id="字符集编码">3. 字符集编码</h1><p><img src="/2021/02/08/数据结构-串/ascii.png" alt></p><p>任何数据存到计算机中一定是二进制数。</p><p>需要确定一个字符和二进制数的对应规则，这就是“编码”</p><p>对应y = f(x) —— 字符集：函数定义域 —— 编码：函数映射规则f —— y：对应的二进制数</p><p>“字符集”：英文字符—ASCII字符集，中英文—Unicode字符集</p><p>基于同一个字符集， 可以有多种编码方案， 如：UTF-8，UTF-16</p><p>注：采用不同的编码方 式，每个字符所占空间不同，考研中只需默认每个字符占1B即可</p><p><strong>乱码问题</strong></p><p>在你的文件中，原本采用某一套编码规则y=f(x)，如 : ‘码’↔0001010100010101010010 </p><p>打开文件时，你的软件以为你采用的是另一套编码规则y=g(x)，如: 0001010100010101010010</p><h1 id="串的存储结构">4. 串的存储结构</h1><h2 id="顺序存储">4.1. 顺序存储</h2><h3 id="静态数组-定长顺序存储">4.1.1. 静态数组-定长顺序存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预定义最大串长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//每个分量存储一个字符-定长顺序存储</span></span><br><span class="line">  <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">  <span class="comment">//串的实际长度</span></span><br><span class="line">  intlength;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-串/shunxu.png" alt></p><h3 id="动态数组-堆分配存储">4.1.2. 动态数组-堆分配存储</h3><p>在C语言中，存在一个称之为“堆”的自由存储区，并用malloc()和free()函数来完成动态存储管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">  <span class="keyword">char</span> *ch;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(MAXLEN*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">S.length=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="如何记录串长length">4.1.3. 如何记录串长length</h3><p><img src="/2021/02/08/数据结构-串/length.png" alt></p><h2 id="链式存储">4.2. 链式存储</h2><p>存储密度低，每个字符1B，每个指针4B</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//每个结点存1个字符</span></span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-串/lian1.png" alt></p><p>提高存储密度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//每个结点存1个字符</span></span><br><span class="line">  <span class="keyword">char</span> ch[<span class="number">4</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/08/数据结构-串/lian2.png" alt></p><h2 id="基于顺序存储实现基本操作">4.3. 基于顺序存储实现基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">  intlength;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h3 id="SubString-amp-Sub-S-pos-len">4.3.1. SubString(&amp;Sub,S,pos,len)</h3><p>求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p><p>S.ch=”wangdao”  S.length=7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="keyword">int</span> pos,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="comment">//子串范围越界</span></span><br><span class="line">  <span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;pos+len;i++)&#123;</span><br><span class="line">    Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">  &#125;</span><br><span class="line">  Sub.length=len;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StrCompare-S-T">4.3.2. StrCompare(S,T)</h3><p>比较操作。若S&gt;T，则返回值&gt;0;若S=T，则返回值=0;若S&lt;T，则返回值&lt;0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SString s,SString T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S.length&amp;&amp;i&lt;=T.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.ch[i]!=T.ch[i])&#123;</span><br><span class="line">      <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Index-S-T">4.3.3. Index(S,T)</h3><p>定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置;否则函数值为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>,n=StrLength(S),m=Strlength(T);</span><br><span class="line">  SString sub;</span><br><span class="line">  <span class="comment">//最多对比 n-m+1 个子串</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//取出从位置i开始，⻓度为m的子串</span></span><br><span class="line">    SubString(sub,S,i,m);</span><br><span class="line">    <span class="comment">//子串和模式串对比，若不匹配，则匹配下一个子串</span></span><br><span class="line">    <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)&#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//S中不存在与T相等的子串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模式匹配">5. 模式匹配</h1><p>主串：‘嘿嘿嘿红红火火恍恍惚惚嗨皮开森猴开森<code>笑出猪叫</code>哈哈哈哈嗨森哈哈哈哈哈哈嗝’</p><p>子串：‘<code>笑出猪叫</code>’</p><p>子串<strong>——</strong>主串的一部分，一定存在 </p><p>模式串<strong>——</strong>不一定能在主串中找到</p><p>字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</p><h2 id="朴素模式匹配算法">5.1. 朴素模式匹配算法</h2><p>将主串中与模式串长度相同的子串搞出来，挨个与模式串对比 </p><p>当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串</p><p><img src="/2021/02/08/数据结构-串/pusu.png" alt></p><p>主串⻓度为<strong>n</strong>，模式串⻓度为 <strong>m</strong> 最多对比 n-m+1 个子串</p><p>朴素模式匹配算法：将主串中所有⻓度为<strong>m</strong>的子串依次与模式串对比，直到找到一个完全匹配的子串， 或所有的子串都不匹配为止。最多对比 n-m+1 个子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      k++;</span><br><span class="line">      i=k; <span class="comment">//i=i-j+2;</span></span><br><span class="line">      j=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j&gt;T.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> k;<span class="comment">//i-T.length</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若模式串长度为m,主串长度为n，很多时候，n &gt;&gt; m</p><p>匹配成功最好 = O(m)</p><p>匹配失败最好 = O(n-m+1) = O(n) 每次模式串第一个字符就不匹配，长度为n的主串有n-m+1个长度为m的子串</p><p>匹配失败最坏 = O(m(n-m+1)) = O(nm)，每次模式串前m-1个字符匹配，只有第m个字符不匹配，长度为n的主串每次需要回溯n-m+1次</p><p>朴素模式匹配算法的缺点: 当某些子串与模式串能部分匹配时，主串的扫􏰁指针 i 经常回溯，导致时间开销增加</p><h2 id="KMP算法">5.2. KMP算法</h2><p>由D.E.Knuth，J.H.Morris和V.R.Pratt􏰀出，因此称为 KMP算法</p><p>已匹配相等的序列就是模式串的某个前缀，因此每次回溯就是模式串与模式串某个前缀在比较，这种频繁的重复比较是效率低的原因所在，当匹配到某个字符不等时，滑到已匹配相等的前缀和模式串若有首尾重合位置，对齐它们，对齐部分显然不需要再比较，下一步直接从主串的当前位置继续比较。</p><p>使其区别与朴素模式匹配算法，主串指针不回溯</p><h3 id="前后缀，部分匹配值">5.2.1. 前后缀，部分匹配值</h3><p>串的前缀：包含第一个字符，且不包含最后一个字符的子串 </p><p>串的后缀：包含最后一个字符，且不包含第一个字符的子串</p><p>部分匹配值：字符串的前缀和后缀的最长相等前后缀长度</p><p><strong>对于’ababa’：</strong></p><ul><li>‘a’ 前缀和后缀为空集，最长相等前后缀长度为0</li><li>‘ab’ 前缀为{a}，后缀为{b}，{a}$\bigcap ${b}=$\phi$ ，最长相等前后缀长度为0</li><li>‘aba’ 前缀为{a,ab}，后缀为{a,ba}，{a,ab}$\bigcap ${a,ba}={a} ，最长相等前后缀长度为1</li><li>‘abab’ 前缀为{a,ab,aba}，后缀为{b,ab,bab}，{a,ab,aba}$\bigcap ${b,ab,bab}={ab} ，最长相等前后缀长度为2</li><li>‘ababa’ 前缀为{a,ab,aba,abab}，后缀为{a,ba,aba,baba}，{a,ab,aba,abab}$\bigcap ${a,ba,aba,baba}={aba} ，最长相等前后缀长度为3</li></ul><p>故字符串’ababa’的部分匹配值为00123</p><p><img src="/2021/02/08/数据结构-串/pm.png" alt></p><h3 id="next数组">5.2.2. next数组</h3><table><thead><tr><th>编号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>S</td><td>a</td><td>b</td><td>c</td><td>a</td><td>c</td></tr><tr><td>PM</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>已知：<code>右移动位数=已匹配的字符数-对应的部分匹配值</code></p><p>写成：<code>Move = (j-1)-PM[j-1];</code></p><p>PM表右移一位，元素匹配失败时，直接看自己的部分匹配值，得到next数组</p><table><thead><tr><th>编号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>S</td><td>a</td><td>b</td><td>c</td><td>a</td><td>c</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>第一个元素以-1填充，因为若第一个元素匹配失败，需要子串向右移动一位，不需要计算子串移动位数</p><p>最后一个元素在右移过程中溢出，其部分匹配值时其下一个元素使用的，显然已没有下一个元素，故可以舍去。</p><p>改写：<code>Move=(j-1)-next[j];</code></p><p>指针j：<code>j=j-Move=next[j]+1;</code></p><p>将next[j]整体+1，则j=next[j]，next[j]表示在子串的第j个字符与主串发生失配时，跳到子串的next[j]位置重新与主串当前位置进行比较。</p><p>当模式串的第 j 个字符匹配失败时，令模式串跳到 next[j] 再继续匹配</p><p>当第j个字符匹配失败，由前 1~j-1 个字符组成的串记为S，则: next[j]=S的最长相等前后缀长度+1</p><p>特别地，next[1]=0</p><table><thead><tr><th>序号j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>模式串</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>next[j]</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p><img src="/2021/02/08/数据结构-串/next.png" alt></p><ul><li>当模式串第一个字符与主串的当前字符比较不相等时，next[1]=0，表示模式串应右移一位，主串当前指针后移一位，再和模式串的第一个字符进行比较。</li><li>当主串的第i个字符与模式串的第j个字符失配时，主串i不回溯，则假定模式串的第k个字符与主串的第i个字符比较，k值应该满足条件1&lt;k&lt;j且’p<sub>1</sub>…p<sub>k-1</sub>‘=’p<sub>j-k+1</sub>…p<sub>j-1</sub>‘，k为模式串的下次比较位置。k值可能有多个，为了不使向右移动丢失可能的匹配，右移距离应该取最小，由于j-k表示右移距离，所以取max(k)。</li><li>除了上面两种情况外，发生失配时，主串指针i不回溯，在最坏情况下，模式串从第一个字符开始与主串的第i个字符进行比较。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_Next</span><span class="params">(SString T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=T.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">      next[i]=j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法-1">5.2.3. KMP算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,SString T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">  get_Next(T,next);</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j&gt;T.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> i-T.length;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏时间复杂度 O(m+n)</p><p>其中，求 next数组时间复杂度 <strong>O(m)</strong></p><p>模式匹配过程最坏时间复杂度 <strong>O(n)</strong></p><h3 id="KMP算法优化">5.2.4. KMP算法优化</h3><p>减少无意义的对比</p><p>当子串和模式串不匹配时j=nextval[j];</p><table><thead><tr><th>序号j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>模式串</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>next[j]</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>nextval[i]</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>4</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nextval数组的求法: </span></span><br><span class="line"><span class="comment">//先算出next数组 </span></span><br><span class="line"><span class="comment">//先令nextval[1]=0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=T.length; j++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])&#123;</span><br><span class="line">    nextval[j]=nextval[next[j]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">nextval[j]=next[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王道版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_Next</span><span class="params">(SString T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=T.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">      <span class="keyword">if</span>(T.ch[i]!=T.ch[j])&#123;</span><br><span class="line">      nextval[i]=j;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        nextval[i]=nextval[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      j=nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">5.3. 总结</h2><p>朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加。最坏时间复杂度O(nm)</p><p>KMP算法：当子串和模式串不匹配时，主串指针 i 不回溯，模式串指针 j=next[j]，算法平均时间复杂度：O(n+m)</p><p>next数组手算方法：当第j个字符匹配失败，由前 1~ j-1 个字符组成的串记为S，则: next[j]=S的最长相等前后缀长度+1。特别地，next[1]=0</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;字符串的朴素匹配与KMP模式匹配&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>dfs算法选择k个数使和为m元素平方和最大</title>
    <link href="/2020/09/02/dfs%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9k%E4%B8%AA%E6%95%B0%E4%BD%BF%E5%92%8C%E4%B8%BAm%E5%85%83%E7%B4%A0%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/"/>
    <id>/2020/09/02/dfs算法选择k个数使和为m元素平方和最大/</id>
    <published>2020-09-02T08:53:37.000Z</published>
    <updated>2020-09-02T09:01:27.908Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">dfs算法应用，n个元素中选择k个数，使其和为m，并且每个元素的平方和最大</blockquote><a id="more"></a><h1 id="原文">1. 原文</h1><p>输入n,m,k。分别为数组个数，选择的数之和，选择的元素个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 6 2</span><br><span class="line">2 3 3 4</span><br></pre></td></tr></table></figure><h1 id="解析思路">2. 解析思路</h1><p>分为选index号元素的 <code>dfs(idx+1,cnt+1,sum+num[idx],squ+num[idx]*num[idx]);</code> </p><p>和不选择index号的<code>dfs(idx+1,cnt,sum,squ);</code></p><p>当元素个数为k，和为m，比较选择最大的平方和保留</p><p>tempath只有在选择index号时才加入num[index]，而后及时剔除，以免影响不选index号的分支</p><h1 id="代码">3. 代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempath,path;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> maxsqu = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> cnt,<span class="keyword">int</span> sum,<span class="keyword">int</span> squ)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt==k&amp;&amp;sum==m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (squ&gt;maxsqu)</span><br><span class="line">&#123;</span><br><span class="line">maxsqu=squ;</span><br><span class="line">path = tempath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (idx==n||cnt&gt;k||sum&gt;m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tempath.push_back(num[idx]);</span><br><span class="line">dfs(idx+<span class="number">1</span>,cnt+<span class="number">1</span>,sum+num[idx],squ+num[idx]*num[idx]);</span><br><span class="line">tempath.pop_back();</span><br><span class="line"></span><br><span class="line">dfs(idx+<span class="number">1</span>,cnt,sum,squ);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"A0000.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,path[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;dfs算法应用，n个元素中选择k个数，使其和为m，并且每个元素的平方和最大&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PAT" scheme="/categories/PAT/"/>
    
    
      <category term="PAT" scheme="/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT线上测试赛真题</title>
    <link href="/2020/05/02/PAT%E7%BA%BF%E4%B8%8A%E6%B5%8B%E8%AF%95%E8%B5%9B%E7%9C%9F%E9%A2%98/"/>
    <id>/2020/05/02/PAT线上测试赛真题/</id>
    <published>2020-05-02T08:00:36.000Z</published>
    <updated>2021-03-01T13:43:18.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><a href="https://pintia.cn/market/item/1256233770241036288" target="_blank" rel="noopener">PAT 线上测试赛真题（2020-05-01）史上首场 PAT 线上比赛，17分钟出现第一个满分！你能比他快吗？</a></blockquote><a id="more"></a><h1 id="Knuth洗牌法-20分">1. Knuth洗牌法 (20分)</h1><p>Knuth 洗牌法是生成 { 1, 2, …, n } 的一个随机重排列的算法。与每次反复随机生成一个数字，直到获得一个不重复的新数字的算法不同，Knuth 洗牌法从原始序列 { 1, 2, …, n } 开始，逐次洗牌。洗牌的方法是从左到右，每轮从没确定的数字中随机抽取一个数，把它放到确定的位置上。</p><p>例如令 n 等于 4。我们从 { 1, 2, 3, 4 } 开始。记 i 到 N 之间的随机抽牌数为 random(i,N)。假设我们生成的随机数序列 random(i,4) (i=1, 2, 3, 4) 为 { 2, 4, 3, 4 }。则 Knuth 洗牌法是这样执行的：</p><ul><li>random(1,4) = 2; 将位置 1 与位置 2 的数字交换，得到 { 2, 1, 3, 4 }</li><li>random(2,4) = 4; 将位置 2 与位置 4 的数字交换，得到 { 2, 4, 3, 1 }</li><li>random(3,4) = 3; 将位置 3 与位置 3 的数字交换，得到 { 2, 4, 3, 1 }</li><li>random(4,4) = 4; 将位置 4 与位置 4 的数字交换，得到 { 2, 4, 3, 1 }</li></ul><p>现给定随机抽牌数字序列，请你输出 Knuth 洗牌法的结果序列。</p><p><strong>输入格式：</strong></p><p>输入在第一行中给出一个正整数 N（≤ 1000）。随后一行给出 N 个随机抽牌数字，数字间以空格分隔。题目保证第 i 个数在 i 到 N 之间。</p><p><strong>输出格式：</strong></p><p>在第一行中输出 Knuth 洗牌法的结果序列。数字间必须以 1 个空格分隔，行首尾不得有多余空格。</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">7 4 4 5 10 6 9 9 10 10</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 4 2 5 10 6 9 1 3 8</span><br></pre></td></tr></table></figure><h2 id="代码">1.1. 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1010</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">num[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">swap(num[i],num[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,num[i]);</span><br><span class="line"><span class="keyword">if</span> (i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三阶幸福数-20分">2. 三阶幸福数 (20分)</h1><p>对一个十进制数的各位数字做一次立方和，称作一次迭代。如果一个十进制数能通过 <em>h 次迭代得到 1，就称该数为三阶幸福数，迭代的次数 \</em>h 称为幸福度。例如 1579 经过 1 次迭代得到 1198，2 次迭代后得到 1243，3 次迭代后得到 100，最后得到 1。则 1579 是幸福数，其幸福度为 4。**</p><p>另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 97 迭代得到 1072、352、160、217、352、…… 可见 352 到 217 形成了死循环，所以 97 就不幸福，而 352 就是它最早遇到的循环点。</p><p>本题就要求你编写程序，判断一个给定的数字是否有三阶幸福。</p><p><strong>输入格式：</strong></p><p>输入在第一行给出一个不超过 100 的正整数 <em>N，随后 \</em>N 行，每行给出一个不超过 1 的正整数。**</p><p><strong>输出格式：</strong></p><p>对于每一个输入的数字，如果其是三阶幸福数，则在一行中输出它的幸福度；否则输出最早遇到的循环点。</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1579</span><br><span class="line">97</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">352</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="代码-1">2.1. 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; exist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">exist[a]++;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">ans+=<span class="built_in">pow</span>((a%<span class="number">10</span>),<span class="number">3</span>);</span><br><span class="line">a/=<span class="number">10</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(a!=<span class="number">0</span>);</span><br><span class="line">a = ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exist[ans]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = ans;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">exist[ans]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag &gt;<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flag);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="垃圾分类-20分">3. 垃圾分类 (20分)</h1><p>[<img src="/2020/05/02/PAT线上测试赛真题/0503.jpg" alt="ljfl.jpg"></p><p>据香港《南华早报》2019年7月15日文章，上海严格的垃圾分类新规令不少居民抓狂。这催生出大量帮助找出正确分类答案的App和小程序。目前仅微信上就至少有280种与垃圾处理有关的App，在苹果应用商店也达130种。支付宝表示，已有60多家独立App开发商申请为该平台提供类似服务。</p><p>本题就请你现场实现一个简单的垃圾分类小助手。</p><p><strong>输入格式：</strong></p><p>输入首先给出官方分类指南中每种物品的归属。在一行中给出一个正整数 N（≤），即物品数量；随后 N 行，每行给出一个物品名称（长度不超过 10 的、由小写英文字母和下划线组成的字符串）和该物品所属的分类（1 代表干垃圾、2 代表湿垃圾、3 代表可回收物、4 代表有害垃圾）。题目保证所有物品名称无重复。</p><p>随后每行给出一个查询物品的名称（格式与指南物品名称相同）。最后一行给出结束符 <code>#</code>，表示查询终止，这一行不需要查询。</p><p><strong>输出格式：</strong></p><p>对每个查询的物品，在一行中给出其所属分类：<code>Gan laji</code> 代表干垃圾；<code>Shi laji</code> 代表湿垃圾；<code>Ke Hui Shou</code> 代表可回收物；<code>You Hai laji</code> 代表有害垃圾。如果查询的物品不在指南中，则输出 <code>?</code> 表示不知道。</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">bao_zhi 3</span><br><span class="line">dian_chi 4</span><br><span class="line">dan_ke 2</span><br><span class="line">bei_ke 1</span><br><span class="line">dan_ke</span><br><span class="line">dian_chi</span><br><span class="line">ren_zha</span><br><span class="line">bao_zhi</span><br><span class="line">bei_ke</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shi laji</span><br><span class="line">You Hai laji</span><br><span class="line">?</span><br><span class="line">Ke Hui Shou</span><br><span class="line">Gan laji</span><br></pre></td></tr></table></figure><h2 id="代码-2">3.1. 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; exist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str&gt;&gt;cnt;</span><br><span class="line">exist[str]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line"><span class="keyword">if</span> (str[<span class="number">0</span>]==<span class="string">'#'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (exist[str]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Gan laji"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (exist[str]==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Shi laji"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (exist[str]==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Ke Hui Shou"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (exist[str]==<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"You Hai laji"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;a href=&quot;https://pintia.cn/market/item/1256233770241036288&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PAT 线上测试赛真题（2020-05-01）史上首场 PAT 线上比赛，17分钟出现第一个满分！你能比他快吗？&lt;/a&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PAT" scheme="/categories/PAT/"/>
    
    
      <category term="PAT" scheme="/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>压力测试工具-ApacheAB</title>
    <link href="/2020/04/19/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-ApacheAB/"/>
    <id>/2020/04/19/压力测试工具-ApacheAB/</id>
    <published>2020-04-19T07:43:38.000Z</published>
    <updated>2021-03-01T14:00:45.086Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Apache AB 模拟并发请求，测试服务器在并发请求下的运行效率</blockquote><a id="more"></a><h1 id="压力测试Apache-AB">1. 压力测试Apache AB</h1><h2 id="下载Apache-HTTP-Server">1.1. 下载Apache HTTP Server</h2><p><a href="http://httpd.apache.org/download.cgi" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi</a></p><p>打开终端，进入到刚刚解压完的http server目录</p><p>执行 ./configure （根据官方文档说明，不加prefix会有默认的路径）</p><p>可能你会见到如下错误，找不到APR</p><h2 id="安装APR-Apache-Portable-Runtime">1.2. 安装APR (Apache Portable Runtime)</h2><p><a href="http://apr.apache.org/download.cgi" target="_blank" rel="noopener">http://apr.apache.org/download.cgi</a></p><p>安装 APR，prefix后面跟着的是你想要安装APR的路径，前提：进入到解压后的APR路径</p><p>./configure –prefix=/usr/local/apr<br>make<br>make install</p><h2 id="安装APR-Util">1.3. 安装APR-Util</h2><p>前提：进入到解压后的APR-Util路径，prefix后面跟着的是你想要安装APR的路径，-with-apr是指向我们安装apr的路径</p><p>./configure –prefix=/usr/local/apr-util -with-apr=/usr/local/apr/<br>make<br>make install</p><h2 id="重新安装Apache-HTTP-Server">1.4. 重新安装Apache HTTP Server</h2><p>进入到http server的解压路径，执行下列命令<br>前提：记得创建/usr/local/httpd/这个路径</p><p>./configure –prefix=/usr/local/httpd/ -with-apr=/usr/local/apr -with-apr-util=/usr/local/apr-util/<br>make</p><p>make install</p><p>进入到httpd的安装目录，启动服务</p><p>cd /usr/local/httpd/bin<br>apachectl -k start</p><p><font color="#f00">遇到“AH00558: httpd: Could not reliably determine the server’s fully qualified domain name”错误</font></p><p><strong>进入到/usr/local/httpd/conf目录</strong></p><p>编辑httpd.conf文件，搜索”#ServerName”，添加ServerName localhost:80</p><p>重新进入/usr/local/httpd/bin </p><p>apachectl -k start</p><p><strong>在浏览器中输入localhost:80</strong></p><p><img src="/2020/04/19/压力测试工具-ApacheAB/ab.png" alt></p><h1 id="开启ab测试">2. 开启ab测试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ab</span></span><br><span class="line">ab: wrong number of arguments</span><br><span class="line">Usage: ab [options] [http[s]://]hostname[:port]/path</span><br><span class="line">Options are:</span><br><span class="line">    -n requests     Number of requests to perform</span><br><span class="line">    -c concurrency  Number of multiple requests to make at a time</span><br><span class="line">    -t timelimit    Seconds to max. to spend on benchmarking</span><br><span class="line">                    This implies -n 50000</span><br><span class="line">    -s timeout      Seconds to max. wait for each response</span><br><span class="line">                    Default is 30 seconds</span><br><span class="line">    -b windowsize   Size of TCP send/receive buffer, in bytes</span><br><span class="line">    -B address      Address to bind to when making outgoing connections</span><br><span class="line">    -p postfile     File containing data to POST. Remember also to set -T</span><br><span class="line">    -u putfile      File containing data to PUT. Remember also to set -T</span><br><span class="line">    -T content-type Content-type header to use for POST/PUT data, eg.</span><br><span class="line">                    'application/x-www-form-urlencoded'</span><br><span class="line">                    Default is 'text/plain'</span><br><span class="line">    -v verbosity    How much troubleshooting info to print</span><br><span class="line">    -w              Print out results in HTML tables</span><br><span class="line">    -i              Use HEAD instead of GET</span><br><span class="line">    -x attributes   String to insert as table attributes</span><br><span class="line">    -y attributes   String to insert as tr attributes</span><br><span class="line">    -z attributes   String to insert as td or th attributes</span><br><span class="line">    -C attribute    Add cookie, eg. 'Apache=1234'. (repeatable)</span><br><span class="line">    -H attribute    Add Arbitrary header line, eg. 'Accept-Encoding: gzip'</span><br><span class="line">                    Inserted after all normal header lines. (repeatable)</span><br><span class="line">    -A attribute    Add Basic WWW Authentication, the attributes</span><br><span class="line">                    are a colon separated username and password.</span><br><span class="line">    -P attribute    Add Basic Proxy Authentication, the attributes</span><br><span class="line">                    are a colon separated username and password.</span><br><span class="line">    -X proxy:port   Proxyserver and port number to use</span><br><span class="line">    -V              Print version number and exit</span><br><span class="line">    -k              Use HTTP KeepAlive feature</span><br><span class="line">    -d              Do not show percentiles served table.</span><br><span class="line">    -S              Do not show confidence estimators and warnings.</span><br><span class="line">    -q              Do not show progress when doing more than 150 requests</span><br><span class="line">    -l              Accept variable document length (use this for dynamic pages)</span><br><span class="line">    -g filename     Output collected data to gnuplot format file.</span><br><span class="line">    -e filename     Output CSV file with percentages served</span><br><span class="line">    -r              Don't exit on socket receive errors.</span><br><span class="line">    -m method       Method name</span><br><span class="line">    -h              Display usage information (this message)</span><br><span class="line">    -I              Disable TLS Server Name Indication (SNI) extension</span><br><span class="line">    -Z ciphersuite  Specify SSL/TLS cipher suite (See openssl ciphers)</span><br><span class="line">    -f protocol     Specify SSL/TLS protocol</span><br><span class="line">                    (TLS1, TLS1.1, TLS1.2 or ALL)</span><br><span class="line">    -E certfile     Specify optional client certificate chain and private key</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ab -n 10000 http://localhost:9500/edu-teacher/listTeachers</span></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line">Completed 1000 requests</span><br><span class="line">Completed 2000 requests</span><br><span class="line">Completed 3000 requests</span><br><span class="line">Completed 4000 requests</span><br><span class="line">Completed 5000 requests</span><br><span class="line">Completed 6000 requests</span><br><span class="line">Completed 7000 requests</span><br><span class="line">Completed 8000 requests</span><br><span class="line">Completed 9000 requests</span><br><span class="line">Completed 10000 requests</span><br><span class="line">Finished 10000 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        </span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            9500</span><br><span class="line"></span><br><span class="line">Document Path:          /edu-teacher/listTeachers</span><br><span class="line">Document Length:        5685 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   39.782 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        9885</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 9885, Exceptions: 0)</span><br><span class="line">Total transferred:      59491075 bytes</span><br><span class="line">HTML transferred:       56781075 bytes</span><br><span class="line">Requests per second:    251.37 [#/sec] (mean)</span><br><span class="line">Time per request:       397.820 [ms] (mean)</span><br><span class="line">Time per request:       3.978 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1460.38 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    1   6.5      0      83</span><br><span class="line">Processing:    44  371 250.6    309    6235</span><br><span class="line">Waiting:       41  366 245.3    306    6117</span><br><span class="line">Total:         44  372 254.0    309    6235</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">  50%</span><span class="bash">    309</span></span><br><span class="line"><span class="meta">  66%</span><span class="bash">    349</span></span><br><span class="line"><span class="meta">  75%</span><span class="bash">    386</span></span><br><span class="line"><span class="meta">  80%</span><span class="bash">    415</span></span><br><span class="line"><span class="meta">  90%</span><span class="bash">    544</span></span><br><span class="line"><span class="meta">  95%</span><span class="bash">    710</span></span><br><span class="line"><span class="meta">  98%</span><span class="bash">    964</span></span><br><span class="line"><span class="meta">  99%</span><span class="bash">   1313</span></span><br><span class="line"><span class="meta"> 100%</span><span class="bash">   6235 (longest request)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Apache AB 模拟并发请求，测试服务器在并发请求下的运行效率&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Parallels Desktop 15 For Mac 破解版</title>
    <link href="/2020/03/30/Parallels%E5%AE%89%E8%A3%85/"/>
    <id>/2020/03/30/Parallels安装/</id>
    <published>2020-03-30T14:36:10.000Z</published>
    <updated>2021-03-01T14:07:59.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Parallels安装 CentOS7安装</blockquote><a id="more"></a><h1 id="Parallels-Desktop-15-安装">1. Parallels Desktop 15 安装</h1><p>官网 <a href="https://www.parallels.cn/products/desktop/buy/" target="_blank" rel="noopener">https://www.parallels.cn/products/desktop/buy/</a></p><p>链接: <a href="https://pan.baidu.com/s/1A4F2RhT4bT-SLK70jLXAoQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1A4F2RhT4bT-SLK70jLXAoQ</a>  密码: 08f0</p><p>安装不要联网！不要联网！</p><p>双击安装</p><p><img src="/2020/03/30/Parallels安装/setup.png" alt></p><p>出现 <font color="#f00">无法打开“Parallels Desktop.app”,因为Apple无法检查其是否包含恶意软件</font></p><p>终端输入 <code>sudo spctl --master-disable</code>  允许任何来源的安装</p><p>而后不检查更新，这就是不联网的原因，安装当前版</p><p>最终</p><p><img src="/2020/03/30/Parallels安装/active.png" alt></p><p>关闭检查</p><p><img src="/2020/03/30/Parallels安装/nocheck.png" alt></p><p>同样不联网，安装Parallels Tools</p><p><img src="/2020/03/30/Parallels安装/tools.png" alt></p><p>禁用</p><p><img src="/2020/03/30/Parallels安装/tooldis.png" alt></p><h1 id="安装win10">2. 安装win10</h1><p>ed2k://|file|cn_windows_10_multi-edition_vl_version_1709_updated_sept_2017_x64_dvd_100090774.iso|4630972416|8867C5E54405FF9452225B66EFEE690A|/</p><h1 id="CentOS-7下载及配置">3. CentOS 7下载及配置</h1><p><a href="http://mirrors.aliyun.com/centos/7.7.1908/isos/x86_64/" target="_blank" rel="noopener">http://mirrors.aliyun.com/centos/7.7.1908/isos/x86_64/</a></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">CentOS-7-x86_64-DVD-1908.iso</span>                       <span class="string">没有桌面(选择☑️)</span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-DVD-1908.torrent</span>                   <span class="string"></span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-Everything-1908.iso</span>                <span class="string">完整版，集成所有软件</span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-Everything-1908.torrent</span>            <span class="string"></span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-LiveGNOME-1908.iso</span>                 <span class="string">有桌面版         </span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-LiveGNOME-1908.torrent</span>             <span class="string"></span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-LiveKDE-1908.iso</span>                   <span class="string">有桌面版</span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-LiveKDE-1908.torrent</span>               <span class="string"></span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-Minimal-1908.iso</span>                   <span class="string">精简版，自带的软件最少</span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-Minimal-1908.torrent</span>               <span class="string"></span></span><br><span class="line"><span class="meta">CentOS-7-x86_64-NetInstall-1908.iso</span>                <span class="string">网络安装版</span></span><br><span class="line"><span class="attr">CentOS-7-x86_64-NetInstall-1908.torrent</span></span><br></pre></td></tr></table></figure><h2 id="查看ip-固定ip">3.1. 查看ip-固定ip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip address</span></span><br></pre></td></tr></table></figure><h2 id="ip相关配置文件">3.2. ip相关配置文件</h2><p>/etc/sysconfig/network-scripts/ifcfg-eth0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost network-scripts]$ cd /etc/sysconfig/network-scripts</span><br><span class="line">[linux@localhost network-scripts]$ ls</span><br><span class="line">ifcfg-eth0  ifdown-bnep  ifdown-ipv6  ifdown-ppp     ifdown-Team      ifup          ifup-eth   ifup-isdn   ifup-post    ifup-sit       ifup-tunnel       network-functions</span><br><span class="line">ifcfg-lo    ifdown-eth   ifdown-isdn  ifdown-routes  ifdown-TeamPort  ifup-aliases  ifup-ippp  ifup-plip   ifup-ppp     ifup-Team      ifup-wireless     network-functions-ipv6</span><br><span class="line">ifdown      ifdown-ippp  ifdown-post  ifdown-sit     ifdown-tunnel    ifup-bnep     ifup-ipv6  ifup-plusb  ifup-routes  ifup-TeamPort  init.ipv6-global</span><br><span class="line">[linux@192 network-scripts]$ vi ifcfg-eth0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">默认配置</span></span><br><span class="line">TYPE="Ethernet"</span><br><span class="line">PROXY_METHOD="none"</span><br><span class="line">BROWSER_ONLY="no"</span><br><span class="line">BOOTPROTO="static"</span><br><span class="line">DEFROUTE="yes"</span><br><span class="line">IPV4_FAILURE_FATAL="no"</span><br><span class="line">IPV6INIT="yes"</span><br><span class="line">IPV6_AUTOCONF="yes"</span><br><span class="line">IPV6_DEFROUTE="yes"</span><br><span class="line">IPV6_FAILURE_FATAL="no"</span><br><span class="line">IPV6_ADDR_GEN_MODE="stable-privacy"</span><br><span class="line">NAME="eth0"</span><br><span class="line">UUID="0ae56f0b-16f1-42cd-adc0-b3bc4daa57c2"</span><br><span class="line">DEVICE="eth0"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改配置</span></span><br><span class="line">TYPE="Ethernet" #网关类型：以太网</span><br><span class="line">BOOTPROTO="static" #ip设置：静态ip</span><br><span class="line">DEVICE="eth0" #网卡名</span><br><span class="line">ONBOOT="yes" #随系统启动</span><br><span class="line">IPADDR="192.168.0.101" #ip地址</span><br><span class="line">GATEWAY="192.168.0.1" #网关</span><br><span class="line">NETMASK="255.255.255.0" #子网掩码</span><br><span class="line">DNS1="8.8.8.8" #谷歌免费dns</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line">[linux@localhost network-scripts]$ reboot</span><br></pre></td></tr></table></figure><h2 id="Mac-连接linux">3.3. Mac 连接linux</h2><p><code>ssh 用户名@ip</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LearningtekiMacBook-Air:myblog Learning$ ssh linux@192.168.0.101</span><br><span class="line">[linux@192 ~]$ </span><br><span class="line">[linux@192 ~]$ ip addr</span><br><span class="line">2: eth0: inet 192.168.0.101/24 </span><br><span class="line">[linux@192 ~]$ </span><br><span class="line">[linux@192 ~]$</span><br></pre></td></tr></table></figure><h2 id="防火墙">3.4. 防火墙</h2><p>查看防火墙状态： service firewalld status</p><p>启动防火墙：  systemctl start firewalld</p><p>停止防火墙：  systemctl stop firewalld </p><p>禁用防火墙：  systemctl disable firewalld</p><hr><p>查看版本： firewall-cmd –version</p><p>查看帮助： firewall-cmd –help </p><p>显示状态： firewall-cmd –state</p><p>开启端口：firewall-cmd –zone=public(作用域) –add-port=80/tcp(端口和访问类型) –permanent(永久生效)</p><p>更新防火墙：firewall-cmd –reload</p><p>查看该端口是否开启：firewall-cmd –zone= public –query-port=80/tcp </p><p>关闭端口：firewall-cmd –zone= public –remove-port=80/tcp –permanent </p><h2 id="yum源中加入阿里云源">3.5. yum源中加入阿里云源</h2><ol><li><p>打开centos的yum文件夹 </p><p>cd  /etc/yum.repos.d/</p></li><li><p>用wget下载repo文件 </p><p>wget  <a href="http://mirrors.aliyun.com/repo/Centos-7.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-7.repo</a></p><p>如果wget命令不生效</p><p>yum -y install wget</p></li><li><p>备份系统原来的repo文件 </p><p>mv  CentOS-Base.repo CentOs-Base.repo.bak</p></li><li><p>替换系统原理的repo文件</p><p>mv Centos-7.repo CentOS-Base.repo</p></li><li><p>执行yum源更新命令</p><p>yum clean all</p><p>yum makecache</p><p>yum update</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ su</span><br><span class="line">Password:</span><br><span class="line">[root@localhost linux]# cd /etc/yum.repos.d/</span><br><span class="line">[root@localhost yum.repos.d]# ls</span><br><span class="line">CentOS-Base.repo      CentOS-CR.repo         CentOS-fasttrack.repo  CentOS-Sources.repo</span><br><span class="line">CentOS-Debuginfo.repo  CentOS-Media.repo      CentOS-Vault.repo</span><br><span class="line">[root@localhost yum.repos.d]# yum -y install wget</span><br><span class="line">[root@localhost yum.repos.d]# wget  http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOs-Base.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]# mv Centos-7.repo CentOs-Base.repo</span><br><span class="line">[root@localhost yum.repos.d]# yum clean all</span><br><span class="line">[root@localhost yum.repos.d]# yum makecache</span><br><span class="line">[root@localhost yum.repos.d]# yum update</span><br></pre></td></tr></table></figure><h1 id="安装docker">4. 安装docker</h1><p><a href="https://www.runaccepted.com/2019/10/21/Docker/" target="_blank" rel="noopener">https://www.runaccepted.com/2019/10/21/Docker/</a></p><h1 id="重启后docker无法启动">5. 重启后docker无法启动</h1><p><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></p><p>解决：</p><p><code>systemctl daemon-reload</code></p><p><code>service docker restart</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ docker ps</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$</span><br><span class="line">[linux@localhost ~]$ systemctl daemon-reload</span><br><span class="line">==== AUTHENTICATING FOR org.freedesktop.systemd1.reload-daemon ===</span><br><span class="line">Authentication is required to reload the systemd state.</span><br><span class="line">Authenticating as: root</span><br><span class="line">Password: </span><br><span class="line">==== AUTHENTICATION COMPLETE ===</span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ service docker restart</span><br><span class="line">Redirecting to /bin/systemctl restart docker.service</span><br><span class="line">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</span><br><span class="line">Authentication is required to manage system services or units.</span><br><span class="line">Authenticating as: root</span><br><span class="line">Password: </span><br><span class="line">==== AUTHENTICATION COMPLETE ===</span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ docker ps</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/containers/json: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ su</span><br><span class="line">密码：</span><br><span class="line">[root@localhost linux]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@localhost linux]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS                       PORTS               NAMES</span><br><span class="line">19d9ac40ba76        elasticsearch:5.6.11   "/docker-entrypoint.…"   8 hours ago         Exited (143) 6 minutes ago                       elasticsearch</span><br><span class="line">c7473e2145bc        logstash:5.6.11        "/docker-entrypoint.…"   9 hours ago         Exited (137) 8 hours ago                         logstash</span><br><span class="line">7122d84209e4        kibana:5.6.11          "/docker-entrypoint.…"   10 hours ago        Exited (143) 8 hours ago                         kibana</span><br><span class="line">[root@localhost linux]#</span><br></pre></td></tr></table></figure><h1 id="克隆linux">6. 克隆linux</h1><p>在关机情况下操作</p><p><img src="/2020/03/30/Parallels安装/kelong.png" alt></p><p>修改IP地址 为192.168.0.102</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ cd /etc/sysconfig/network-scripts</span><br><span class="line">[linux@localhost network-scripts]$ nano ifcfg-eth0</span><br><span class="line"></span><br><span class="line">TYPE="Ethernet"</span><br><span class="line">BOOTPROTO="static"</span><br><span class="line">DEVICE="eth0"</span><br><span class="line">ONBOOT="yes"</span><br><span class="line">IPADDR="192.168.0.102"</span><br><span class="line">GATEWAY="192.168.0.1"</span><br><span class="line">NETMASK="255.255.255.0"</span><br><span class="line">DNS1="8.8.8.8"</span><br><span class="line"></span><br><span class="line">[linux@localhost network-scripts]$</span><br></pre></td></tr></table></figure><p>删除Linux物理地址绑定的文件（该文件会在操作系统重启并生成物理地址以后将物理地址绑定到IP上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost network-scripts]$ rm -rf /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line">[linux@localhost network-scripts]$ reboot</span><br></pre></td></tr></table></figure><h2 id="Mac-连接linux2">6.1. Mac 连接linux2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LearningtekiMacBook-Air:myblog Learning$ ssh linux@192.168.0.102</span><br><span class="line">[linux@localhost ~]$ </span><br><span class="line">[linux@localhost ~]$ ip addr</span><br><span class="line">2: eth0: inet 192.168.0.102/24 </span><br><span class="line">[linux@localhost ~]$</span><br></pre></td></tr></table></figure><p>启动elasticsearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost network-scripts]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">19d9ac40ba76        elasticsearch:5.6.11   "/docker-entrypoint.…"   9 hours ago         Exited (143) 40 minutes ago                       elasticsearch</span><br><span class="line">[root@localhost network-scripts]# docker start 19d9ac40ba76</span><br><span class="line">19d9ac40ba76</span><br><span class="line">[root@localhost network-scripts]#</span><br></pre></td></tr></table></figure><p><a href="http://192.168.0.102:9200/" target="_blank" rel="noopener">http://192.168.0.102:9200/</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// http://192.168.0.102:9200/</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"efBli3S"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span>: <span class="string">"RmnRPDI-T4G8hOH92bX5wQ"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: &#123;</span><br><span class="line">    <span class="attr">"number"</span>: <span class="string">"5.6.11"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span>: <span class="string">"bc3eef4"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span>: <span class="string">"2018-08-16T15:25:17.293Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span>: <span class="string">"6.6.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span>: <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再重启ssh拒绝-Connection-refused">6.2. 再重启ssh拒绝 Connection refused</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LearningtekiMacBook-Air:~ Learning$ ssh linux@192.168.0.102</span><br><span class="line">ssh: connect to host 192.168.0.102 port 22: Connection refused</span><br><span class="line">LearningtekiMacBook-Air:~ Learning$</span><br></pre></td></tr></table></figure><p>查看ssh是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ ps -e | grep ssh</span><br><span class="line">  981 ?        00:00:00 sshd</span><br><span class="line">[linux@localhost ~]$</span><br></pre></td></tr></table></figure><p>查看22端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ ss -lnt</span><br><span class="line">State      Recv-Q Send-Q                          Local Address:Port                                         Peer Address:Port              </span><br><span class="line">LISTEN     0      128                                         *:22                                                      *:*                  </span><br><span class="line">LISTEN     0      100                                 127.0.0.1:25                                                      *:*                  </span><br><span class="line">LISTEN     0      128                                      [::]:22                                                   [::]:*                  </span><br><span class="line">LISTEN     0      100                                     [::1]:25                                                   [::]:*                  </span><br><span class="line">[linux@localhost ~]$</span><br></pre></td></tr></table></figure><p>查看hosts名单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p>添加本地ip和hostname</p><p>– 本机hostname是？ ping 192.168.0.100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ ping 192.168.0.100</span><br><span class="line">PING 192.168.0.100 (192.168.0.100) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.100: icmp_seq=1 ttl=64 time=0.165 ms</span><br><span class="line">64 bytes from 192.168.0.100: icmp_seq=2 ttl=64 time=0.274 ms</span><br><span class="line">64 bytes from 192.168.0.100: icmp_seq=3 ttl=64 time=0.374 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.0.100 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 0.165/0.271/0.374/0.085 ms</span><br><span class="line">[linux@localhost ~]$</span><br></pre></td></tr></table></figure><p>hostname就是ip吧，添加</p><p><code>192.168.0.100 192.168.0.100</code></p><p><strong>ssh hostname</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost ~]$ ssh 192.168.0.100</span><br><span class="line">Warning: Permanently added '192.168.0.100' (ECDSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>再次ssh linux2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LearningtekiMacBook-Air:~ Learning$ ssh linux@192.168.0.102</span><br><span class="line">linux@192.168.0.102's password: </span><br><span class="line">[linux@localhost ~]$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Parallels安装 CentOS7安装&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="/categories/Linux/"/>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch安装及实践</title>
    <link href="/2020/03/29/ElasticSearch%E5%AE%89%E8%A3%85%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
    <id>/2020/03/29/ElasticSearch安装及实践/</id>
    <published>2020-03-29T09:15:01.000Z</published>
    <updated>2021-03-01T13:54:06.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">elasticsearch kibana logstash ELK 最终选用低版本运行</blockquote><a id="more"></a><h1 id="linux的docker中安装">1. linux的docker中安装</h1><h2 id="ElasticSearch5-6-11">1.1. ElasticSearch5.6.11</h2><p>安装镜像 docker pull elasticsearch:5.6.11</p><p>创建本地文件 </p><p>mkdir -p /mydata/elasticsearch/config</p><p>mkdir -p /mydata/elasticsearch/data</p><p>echo “http.host: 0.0.0.0” &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</p><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run </span><br><span class="line">--name elasticsearch  #容器名</span><br><span class="line">-p 9200:9200 -p 9300:9300 #端口映射 9200暴露外部端口 9300 内部集群交互</span><br><span class="line">-e "discovery.type=single-node" </span><br><span class="line">-e ES_JAVA_OPTS="-Xms128m -Xmx128m" #elasticsearch初始内存和最大内存</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml #内部配置文件挂载到本地</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data #数据存储到本地</span><br><span class="line">-d elasticsearch:5.6.11</span><br></pre></td></tr></table></figure><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@192 /]# docker pull elasticsearch:5.6.11</span><br><span class="line">[root@192 /]# </span><br><span class="line">[root@192 /]# mkdir -p /mydata/elasticsearch/config</span><br><span class="line">[root@192 /]# mkdir -p /mydata/elasticsearch/data</span><br><span class="line">[root@192 /]# echo "http.host: 0.0.0.0" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line">[root@192 /]# </span><br><span class="line">[root@192 /]# docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.11</span><br><span class="line">760ba5e8259c75eb577e493537b632ba4750cfae8f8e14ad361762d2e6a21d2d</span><br><span class="line">[root@192 /]#</span><br><span class="line">[root@192 /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">760ba5e8259c        elasticsearch:5.6.11   "/docker-entrypoint.…"   17 seconds ago      Up 14 seconds       0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   elasticsearch</span><br><span class="line">[root@192 /]# systemctl stop firewalld</span><br><span class="line">[root@192 /]#</span><br></pre></td></tr></table></figure><p>远程访问 <a href="http://192.168.0.101:9200/" target="_blank" rel="noopener">http://192.168.0.101:9200/</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 20200331013255</span><br><span class="line">// http://192.168.0.101:9200/</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"efBli3S"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span>: <span class="string">"RmnRPDI-T4G8hOH92bX5wQ"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: &#123;</span><br><span class="line">    <span class="attr">"number"</span>: <span class="string">"5.6.11"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span>: <span class="string">"bc3eef4"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span>: <span class="string">"2018-08-16T15:25:17.293Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span>: <span class="string">"6.6.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span>: <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="es集群">1.1.1. es集群</h3><h4 id="es1">1.1.1.1. es1</h4><p>/mydata/elasticsearch/config/elasticsearch.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启跨域</span></span><br><span class="line"><span class="string">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群名</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点名</span></span><br><span class="line"><span class="string">node.name:</span> <span class="number">101</span><span class="bullet">-es1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定该节点是否有资格被选举成为master节点，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master</span></span><br><span class="line"><span class="string">node.master:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许该节点存储数据(默认开启)</span></span><br><span class="line"><span class="string">node.data:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许任何ip访问</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过这个ip列表进行节点发现</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["192.168.0.101:9300",</span> <span class="string">"192.168.0.101:9301"</span><span class="string">,"192.168.0.101:9302"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prevent the "split brain" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):</span></span><br><span class="line"><span class="comment"># 如果没有这种设置,遭受网络故障的集群就有可能将集群分成两个独立的集群 – 导致脑裂 - 这将导致数据丢失</span></span><br><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>修改文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost mydata]$ mv elasticsearch elasticsearch1</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost /]$ docker run --name es1 -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms128m -Xmx128m" -v /mydata/elasticsearch1/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch1/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.11</span><br><span class="line">f3f915ff2443bc850b80831829983e7090c8988d420588266001c82898d216b7</span><br><span class="line">[linux@localhost /]$ </span><br><span class="line">[linux@localhost /]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">f3f915ff2443        elasticsearch:5.6.11   "/docker-entrypoint.…"   39 seconds ago      Up 33 seconds       0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   es1</span><br><span class="line">[linux@localhost /]$ docker logs f3f915ff2443</span><br><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure><p>修改linux进程数限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost /]$ su</span><br><span class="line">密码：</span><br><span class="line">[root@localhost /]# nano /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=655360</span><br><span class="line">[root@localhost /]# sysctl -p</span><br><span class="line">vm.max_map_count = 655360</span><br></pre></td></tr></table></figure><h4 id="es2">1.1.1.2. es2</h4><p>创建文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost mydata]$ cp -rf elasticsearch1 elasticsearch2</span><br><span class="line">[linux@localhost mydata]$ ls</span><br><span class="line">elasticsearch1  elasticsearch2  kibana  logstash</span><br></pre></td></tr></table></figure><p>config/elasticsearch.yml 仅修改节点名 101-es2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost /]$ docker run --name es2 -p 9201:9200 -p 9301:9300 -e ES_JAVA_OPTS="-Xms128m -Xmx128m" -v /mydata/elasticsearch2/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch2/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.11</span><br></pre></td></tr></table></figure><h4 id="es3">1.1.1.3. es3</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost mydata]$ cp -rf elasticsearch1 elasticsearch3</span><br><span class="line">[linux@localhost mydata]$ ls</span><br><span class="line">elasticsearch1  elasticsearch2  elasticsearch3 kibana  logstash</span><br></pre></td></tr></table></figure><p>config/elasticsearch.yml 仅修改节点名 101-es3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linux@localhost /]$ docker run --name es3 -p 9202:9200 -p 9302:9300 -e ES_JAVA_OPTS="-Xms128m -Xmx128m" -v /mydata/elasticsearch3/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch3/data:/usr/share/elasticsearch/data -d elasticsearch:5.6.11</span><br></pre></td></tr></table></figure><h3 id="测试连接">1.1.2. 测试连接</h3><p>es2  当选</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/master</span><br><span class="line">4glKS6mYRO2M1aGwMbSWPQ 172.17.0.4 172.17.0.4 101-es2</span><br><span class="line"></span><br><span class="line">GET _cat/health</span><br><span class="line">1585690357 21:32:37 elasticsearch green 3 3 2 1 0 0 0 0 - 100.0%</span><br><span class="line"></span><br><span class="line">GET /_cat/nodes</span><br><span class="line">172.17.0.5 48 93 5 0.32 0.96 0.66 mdi - 101-es3</span><br><span class="line">172.17.0.2 55 93 5 0.32 0.96 0.66 mdi - 101-es1</span><br><span class="line">172.17.0.4 58 93 5 0.32 0.96 0.66 mdi * 101-es2</span><br></pre></td></tr></table></figure><h3 id="原理">1.1.3. 原理</h3><p>一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，<font color="#f00">集群将会重新平均分布所有的数据</font></p><p>当一个节点被选举成为 <code>主</code>节点时，<font color="#f00">它将负责管理集群范围内的所有变更</font>，例如增加、删除索引，或者增加、删除节点等。 而<font color="#f00">主节点并不需要涉及到文档级别的变更和搜索等操作</font>，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p><p>作为用户，我们可以将请求发送到 集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 你可以在同一个目录内，完全依照启动第一个节点的方式来启动一个新节点（参考安装并运行 Elasticsearch）。多个节点可以共享同一个目录。</p><p> 当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。 但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。</p><h4 id="分片">1.1.3.1. 分片</h4><p>查看分片信息 p主 r副</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/shards</span><br><span class="line"></span><br><span class="line">customer 1 p STARTED 0  162b 172.17.0.4 101-es2</span><br><span class="line">customer 1 r STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 3 r STARTED 1 3.3kb 172.17.0.5 101-es3</span><br><span class="line">customer 3 p STARTED 1 3.3kb 172.17.0.2 101-es1</span><br><span class="line">customer 4 p STARTED 0  162b 172.17.0.4 101-es2</span><br><span class="line">customer 4 r STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 2 r STARTED 0  162b 172.17.0.4 101-es2</span><br><span class="line">customer 2 p STARTED 0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 0 r STARTED 0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 0 p STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">.kibana  0 p STARTED 1 3.2kb 172.17.0.4 101-es2</span><br><span class="line">.kibana  0 r STARTED 1 3.2kb 172.17.0.5 101-es3</span><br></pre></td></tr></table></figure><p>查看集群信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/health</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"green"</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">3</span>, </span><br><span class="line">  "active_primary_shards": 6, #es2 3 es3 1 es1 2</span><br><span class="line">  "active_shards": 12,</span><br><span class="line">  "relocating_shards": 0,</span><br><span class="line">  "initializing_shards": 0,</span><br><span class="line">  "unassigned_shards": 0,</span><br><span class="line">  "delayed_unassigned_shards": 0,</span><br><span class="line">  "number_of_pending_tasks": 0,</span><br><span class="line">  "number_of_in_flight_fetch": 0,</span><br><span class="line">  "task_max_waiting_in_queue_millis": 0,</span><br><span class="line">  "active_shards_percent_as_number": 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止es2</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/master</span><br><span class="line">xWuBdPbpSMqkCCbIfY07Mg 172.17.0.2 172.17.0.2 101-es1</span><br><span class="line"></span><br><span class="line">GET /_cat/shards</span><br><span class="line"></span><br><span class="line">customer 1 p STARTED    0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 1 r UNASSIGNED                    </span><br><span class="line">customer 3 r STARTED    1 3.4kb 172.17.0.5 101-es3</span><br><span class="line">customer 3 p STARTED    1 3.4kb 172.17.0.2 101-es1</span><br><span class="line">customer 4 p STARTED    0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 4 r UNASSIGNED                    </span><br><span class="line">customer 2 p STARTED    0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 2 r UNASSIGNED                    </span><br><span class="line">customer 0 r STARTED    0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 0 p STARTED    0  162b 172.17.0.2 101-es1</span><br><span class="line">.kibana  0 p STARTED    1 3.2kb 172.17.0.5 101-es3</span><br><span class="line">.kibana  0 r UNASSIGNED   </span><br><span class="line"></span><br><span class="line">#重新分配</span><br><span class="line">customer 1 r STARTED 0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 1 p STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 3 r STARTED 1 3.4kb 172.17.0.5 101-es3</span><br><span class="line">customer 3 p STARTED 1 3.4kb 172.17.0.2 101-es1</span><br><span class="line">customer 4 r STARTED 0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 4 p STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 2 p STARTED 0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 2 r STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">customer 0 r STARTED 0  162b 172.17.0.5 101-es3</span><br><span class="line">customer 0 p STARTED 0  162b 172.17.0.2 101-es1</span><br><span class="line">.kibana  0 p STARTED 1 3.2kb 172.17.0.5 101-es3</span><br><span class="line">.kibana  0 r STARTED 1 3.2kb 172.17.0.2 101-es1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /_cluster/health</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"green"</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">"active_shards"</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分片原理</p><p><img src="/2020/03/29/ElasticSearch安装及实践/liang.png" alt>)</p><p>当第二个节点加入到集群后，3个 副本分片 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p><p>所有新近被索引的文档都将<strong>会保存在主分片上</strong>，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p><p>cluster-health 现在展示的状态为 green ，这表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。</p><h3 id="集群健康">1.1.4. 集群健康</h3><p>GET /_cluster/health</p><p>status 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下： </p><p>green 所有的主分片和副本分片都正常运行。</p><p>yellow 所有的主分片都正常运行，但不是所有的副本分片都正常运行。</p><p>red 有主分片没能正常运行。</p><h4 id="水平扩容">1.1.4.1. 水平扩容</h4><p>三个节点的集群为了分散负载而对分片进行重新分配</p><p>P0的副本存在R0中，P1的副本存在R1中，P2的副本存在R2中，即使node3 挂了，数据仍完整</p><p><img src="/2020/03/29/ElasticSearch安装及实践/three.png" alt></p><p> 读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p><p>在运行中的集群上是可以动态调整副本分片数目的, 我们可以按需伸缩集群.让我们把副本数从默认的 1 增加到 2 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"number_of_replicas"</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p><p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为 yellow（不是green是因为我们之前设置主分片存在两个副本，而现在只剩一个了） 。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般</p><h4 id="脑裂问题">1.1.4.2. 脑裂问题</h4><p>集群中不同的节点对于master的选择出现了分歧，出现了多个master竞争，导致主分片和副本的识别也发生了分歧，对一些分歧中的分片标识为了坏片。</p><p><strong>脑裂问题可能的成因 - 主不能工作了就得选</strong> </p><ol><li><p>网络问题：集群间的网络延迟导致一些节点访问不到master，认为master挂掉了从而选举出新的master，并对master上的分片和副本标红，分配新的主分片</p></li><li><p>节点负载：主节点的角色既为master又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</p></li><li><p>内存回收：data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。</p></li></ol><p><strong>脑裂问题解决方案</strong></p><ol><li><p>减少误判：discovery.zen.ping_timeout节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。</p></li><li><p>选举触发 discovery.zen.minimum_master_nodes:1。</p><p>discovery.zen.minimum_master_nodes（默认是1）：这个参数控制的是，一个节点需要看到的具有master节点资格的最小数量，然后才能在集群中做操作。官方的推荐值是(N/2)+1，其中N是具有master资格的节点的数量（我们的情况是3，因此这个参数设置为2，但对于只有2个节点的情况，设置为2就有些问题了，一个节点DOWN掉后，你肯定连不上2台服务器了，这点需要注意）。</p><p>增大该参数，当该值为2时，我们可以设置master的数量为3，这样，挂掉一台，其他两台都认为主节点挂掉了，才进行主节点选举。</p></li></ol><ol start="3"><li><p>角色分离：即master节点与data节点分离，限制角色</p><p>主节点配置为： node.master: true   ##作为master节点</p><p>​                            node.data: false   ##不作为存储数据节点</p><p>从节点配置为： node.master: false  </p><p>​                            node.data: true</p></li></ol><p><strong>最终考虑到资源有限，解决方案如下：</strong></p><p>增加一台物理机，这样，一共有了三台物理机。在这三台物理机上，搭建了6个ES的节点，三个data节点，三个master节点（每台物理机分别起了一个data和一个master），3个master节点，目的是达到（n/2）+1等于2的要求，这样挂掉一台master后（不考虑data），n等于2，满足参数，其他两个master节点都认为master挂掉之后开始重新选举</p><p><img src="/2020/03/29/ElasticSearch安装及实践/master.png" alt></p><h2 id="Kibana5-6-11">1.2. Kibana5.6.11</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@192 /]# docker pull kibana:5.6.11</span><br><span class="line"></span><br><span class="line">[root@192 /]# docker run --name kibana -v /mydata/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml -p 5601:5601 -d kibana:5.6.11</span><br><span class="line"></span><br><span class="line">25d1bd1a0531c0aec95e7885adf82dc14adbb71df43d4dbc15d6fee7cce58e34</span><br><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint kibana (84808062bec07bb507621f089d0f31d73cc7c3f57402cb6c61444cffddbcc14d):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 5601 -j DNAT --to-destination 172.17.0.3:5601 ! -i docker0: iptables: No chain/target/match by that name.</span><br><span class="line"> (exit status 1)).</span><br><span class="line">[root@192 /]#</span><br></pre></td></tr></table></figure><p>重启docker？？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@192 /]# </span><br><span class="line">[root@192 /]# systemctl restart docker</span><br><span class="line">[root@192 /]# </span><br><span class="line">[root@192 /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED              STATUS                       PORTS               NAMES</span><br><span class="line">25d1bd1a0531        kibana:5.6.11          "/docker-entrypoint.…"   About a minute ago   Created                                          kibana</span><br><span class="line">760ba5e8259c        elasticsearch:5.6.11   "/docker-entrypoint.…"   21 minutes ago       Exited (143) 7 seconds ago                       elasticsearch</span><br><span class="line">[root@192 /]# docker start 25d1bd1a0531</span><br><span class="line">25d1bd1a0531</span><br><span class="line">[root@192 /]# docker start 760ba5e8259c</span><br><span class="line">760ba5e8259c</span><br><span class="line">[root@192 /]#</span><br></pre></td></tr></table></figure><p>访问 <a href="http://192.168.0.101:5601/" target="_blank" rel="noopener">http://192.168.0.101:5601/</a></p><p><img src="/2020/03/29/ElasticSearch安装及实践/kibana5.png" alt></p><p>修改配置文件 原kibana.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Kibana is served by a back end server. This setting specifies the port to use.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.port: 5601</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifies the address to <span class="built_in">which</span> the Kibana server will <span class="built_in">bind</span>. IP addresses and host names are both valid values.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The default is <span class="string">'localhost'</span>, <span class="built_in">which</span> usually means remote machines will not be able to connect.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> To allow connections from remote users, <span class="built_in">set</span> this parameter to a non-loopback address.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.host: <span class="string">"localhost"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enables you to specify a path to mount Kibana at <span class="keyword">if</span> you are running behind a proxy. This only affects</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the URLs generated by Kibana, your proxy is expected to remove the basePath value before forwarding requests</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to Kibana. This setting cannot end <span class="keyword">in</span> a slash.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.basePath: <span class="string">""</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The maximum payload size <span class="keyword">in</span> bytes <span class="keyword">for</span> incoming server requests.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.maxPayloadBytes: 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The Kibana server<span class="string">'s name.  This is used for display purposes.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.name: <span class="string">"your-hostname"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The URL of the Elasticsearch instance to use <span class="keyword">for</span> all your queries.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.url: <span class="string">"http://localhost:9200"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When this setting<span class="string">'s value is true Kibana uses the hostname specified in the server.host</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> setting. When the value of this setting is <span class="literal">false</span>, Kibana uses the hostname of the host</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that connects to this Kibana instance.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.preserveHost: <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Kibana uses an index <span class="keyword">in</span> Elasticsearch to store saved searches, visualizations and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dashboards. Kibana creates a new index <span class="keyword">if</span> the index doesn<span class="string">'t already exist.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">kibana.index: <span class="string">".kibana"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The default application to load.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">kibana.defaultAppId: <span class="string">"discover"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If your Elasticsearch is protected with basic authentication, these settings provide</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the username and password that the Kibana server uses to perform maintenance on the Kibana</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> index at startup. Your Kibana users still need to authenticate with Elasticsearch, <span class="built_in">which</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is proxied through the Kibana server.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.username: <span class="string">"user"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.password: <span class="string">"pass"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These settings <span class="built_in">enable</span> SSL <span class="keyword">for</span> outgoing requests from the Kibana server to the browser.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.ssl.enabled: <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.ssl.certificate: /path/to/your/server.crt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">server.ssl.key: /path/to/your/server.key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Optional settings that provide the paths to the PEM-format SSL certificate and key files.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> These files validate that your Elasticsearch backend uses the same key files.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.ssl.certificate: /path/to/your/client.crt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.ssl.key: /path/to/your/client.key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Optional setting that enables you to specify a path to the PEM file <span class="keyword">for</span> the certificate</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> authority <span class="keyword">for</span> your Elasticsearch instance.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.ssl.certificateAuthorities: [ <span class="string">"/path/to/your/CA.pem"</span> ]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To disregard the validity of SSL certificates, change this setting<span class="string">'s value to '</span>none<span class="string">'.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.ssl.verificationMode: full</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Time <span class="keyword">in</span> milliseconds to <span class="built_in">wait</span> <span class="keyword">for</span> Elasticsearch to respond to pings. Defaults to the value of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the elasticsearch.requestTimeout setting.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.pingTimeout: 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Time <span class="keyword">in</span> milliseconds to <span class="built_in">wait</span> <span class="keyword">for</span> responses from the back end or Elasticsearch. This value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> must be a positive <span class="built_in">integer</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.requestTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> headers, <span class="built_in">set</span> this value to [] (an empty list).</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.requestHeadersWhitelist: [ authorization ]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.customHeaders: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Time <span class="keyword">in</span> milliseconds <span class="keyword">for</span> Elasticsearch to <span class="built_in">wait</span> <span class="keyword">for</span> responses from shards. Set to 0 to <span class="built_in">disable</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.shardTimeout: 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Time <span class="keyword">in</span> milliseconds to <span class="built_in">wait</span> <span class="keyword">for</span> Elasticsearch at Kibana startup before retrying.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.startupTimeout: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifies the path <span class="built_in">where</span> Kibana creates the process ID file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">pid.file: /var/run/kibana.pid</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enables you specify a file <span class="built_in">where</span> Kibana stores <span class="built_in">log</span> output.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">logging.dest: stdout</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the value of this setting to <span class="literal">true</span> to suppress all logging output.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">logging.silent: <span class="literal">false</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the value of this setting to <span class="literal">true</span> to suppress all logging output other than error messages.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">logging.quiet: <span class="literal">false</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the value of this setting to <span class="literal">true</span> to <span class="built_in">log</span> all events, including system usage information</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and all requests.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">logging.verbose: <span class="literal">false</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the interval <span class="keyword">in</span> milliseconds to sample system and process performance</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> metrics. Minimum is 100ms. Defaults to 5000.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ops.interval: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The default locale. This locale can be used <span class="keyword">in</span> certain circumstances to substitute any missing</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> translations.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">i18n.defaultLocale: <span class="string">"en"</span></span></span><br></pre></td></tr></table></figure><p>创建 /mydata/kibana/config/kibana.yml</p><p>kibana配置文件挂载到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@192 /]# mkdir -p /mydata/kibana/config</span><br><span class="line">[root@192 /]# cd /mydata/kibana/config</span><br><span class="line">[root@192 config]# nano kibana.yml</span><br><span class="line">bash: nano: 未找到命令</span><br><span class="line">[root@192 config]# yum install nano</span><br><span class="line">[root@192 config]# nano kibana.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################################</span></span></span><br><span class="line">server.port: 5601</span><br><span class="line"></span><br><span class="line">server.host: "0.0.0.0"</span><br><span class="line"></span><br><span class="line">elasticsearch.url: "http://192.168.0.101:9200"</span><br><span class="line"></span><br><span class="line">elasticsearch.requestTimeout: 90000</span><br><span class="line"></span><br><span class="line">i18n.defaultLocale: "zh-CN"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@192 config]# docker rm 25d1bd1a0531</span><br><span class="line">25d1bd1a0531</span><br><span class="line">[root@192 config]# docker run --name kibana -v /mydata/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml -p 5601:5601 -d kibana:5.6.11</span><br><span class="line">7122d84209e4d082dc6e0e18065567eb0bbfd5e4aa3017b3ff8d8457c217b66b</span><br><span class="line"></span><br><span class="line">[root@192 config]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">7122d84209e4        kibana:5.6.11          "/docker-entrypoint.…"   25 minutes ago      Up 10 minutes       0.0.0.0:5601-&gt;5601/tcp                           kibana</span><br><span class="line">760ba5e8259c        elasticsearch:5.6.11   "/docker-entrypoint.…"   About an hour ago   Up 49 minutes       0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   elasticsearch</span><br><span class="line">[root@192 config]# </span><br><span class="line">[root@192 config]# </span><br><span class="line">[root@192 config]# docker logs 7122d84209e4</span><br><span class="line">"tags":["status","ui settings","info"],"pid":9,"state":"green","message":"Status changed from yellow to green - Ready","prevState":"yellow","prevMsg":"Elasticsearch plugin is yellow"&#125;</span><br></pre></td></tr></table></figure><h2 id="logstash5-6-11">1.3. logstash5.6.11</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@192 config]# docker pull logstash:5.6.11</span><br><span class="line">[root@192 config]# mkdir -p /mydata/logstash</span><br><span class="line">[root@192 config]# cd /mydata/logstash</span><br><span class="line">[root@192 logstash]# nano logstash.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################</span></span></span><br><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 4560</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; ["192.168.0.101:9200"]</span><br><span class="line">    index =&gt; "applog"</span><br><span class="line">    #user =&gt; "elastic"</span><br><span class="line">    #password =&gt; "changeme"</span><br><span class="line">  &#125;</span><br><span class="line">  stdout&#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################################</span></span></span><br><span class="line"></span><br><span class="line">[root@192 logstash]# </span><br><span class="line">[root@192 logstash]# pwd</span><br><span class="line">/mydata/logstash</span><br><span class="line">[root@192 logstash]# docker run --name logstash -p 4560:4560 -v /mydata/logstash/logstash.conf:/etc/logstash.conf --link elasticsearch:elasticsearch -d logstash:5.6.11 logstash -f /etc/logstash.conf</span><br><span class="line">c7473e2145bc7478835f08b08caf8134b126899a4031b78baf5b234c732bd7fa</span><br><span class="line">[root@192 logstash]# </span><br><span class="line">[root@192 logstash]# </span><br><span class="line">[root@192 logstash]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">c7473e2145bc        logstash:5.6.11        "/docker-entrypoint.…"   6 seconds ago       Up 3 seconds        0.0.0.0:4560-&gt;4560/tcp                           logstash</span><br><span class="line">7122d84209e4        kibana:5.6.11          "/docker-entrypoint.…"   About an hour ago   Up 49 minutes       0.0.0.0:5601-&gt;5601/tcp                           kibana</span><br><span class="line">760ba5e8259c        elasticsearch:5.6.11   "/docker-entrypoint.…"   2 hours ago         Up 2 hours          0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   elasticsearch</span><br><span class="line">[root@192 logstash]#</span><br></pre></td></tr></table></figure><h1 id="linux">2. linux</h1><h2 id="ElasticSearch-存储和检索数据">2.1. ElasticSearch 存储和检索数据</h2><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>elasticsearch只能用非root启动</p><p>拷贝至/usr/local/elasticsearch-7.6.1</p><p>编译 elasticsearch.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@192 Downloads]# tar zxvf elasticsearch-7.6.1-linux-x86_64.tar.gz</span><br><span class="line">[root@192 Downloads]# ls</span><br><span class="line">elasticsearch-7.6.1  elasticsearch-7.6.1-linux-x86_64.tar.gz  tomcat-users.xml</span><br><span class="line">[root@192 Downloads]# cp -rf elasticsearch-7.6.1 /usr/local/elasticsearch-7.6.1</span><br><span class="line">[root@192 Downloads]# cd /usr/local/elasticsearch-7.6.1</span><br><span class="line">[root@192 elasticsearch-7.6.1]# ls</span><br><span class="line">bin  config  jdk  lib  LICENSE.txt  logs  modules  NOTICE.txt  plugins  README.asciidoc</span><br><span class="line">[root@192 elasticsearch-7.6.1]# cd config</span><br><span class="line">[root@192 config]# ls</span><br><span class="line">elasticsearch.yml  jvm.options  log4j2.properties  role_mapping.yml  roles.yml  users  users_roles</span><br><span class="line">[root@192 config]# nano elasticsearch.yml</span><br></pre></td></tr></table></figure><p><strong>elasticsearch.yml</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: es-linux</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a descriptive name <span class="keyword">for</span> the node:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">node.name: node-linux</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Add custom attributes to the node:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> node.attr.rack: r1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Path to directory <span class="built_in">where</span> to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">path.data: /usr/local/elasticsearch-7.6.1/data</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Path to <span class="built_in">log</span> files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">path.logs: /usr/local/elasticsearch-7.6.1/logs</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lock the memory on startup:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the <span class="built_in">bind</span> address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set a custom port <span class="keyword">for</span> HTTP:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The default list of hosts is [<span class="string">"127.0.0.1"</span>, <span class="string">"[::1]"</span>]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">discovery.zen.ping.unicast.hosts: ["127.0.0.1","192.168.0.100","192.168.0.112"]</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bootstrap the cluster using an initial <span class="built_in">set</span> of master-eligible nodes:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">cluster.initial_master_nodes: ["es-linux"]</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p><strong>jvm.options</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure><p><strong>创建用户和权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@192 bin]# adduser elasticsearch</span><br><span class="line">[root@192 bin]# passwd elasticsearch</span><br><span class="line"></span><br><span class="line">[root@192 local]# chown -R elasticsearch:elasticsearch elasticsearch-7.6.1</span><br></pre></td></tr></table></figure><p><font color="#f00">ERROR Unable to invoke factory method in class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 bin]# yum install -y log4j</span><br></pre></td></tr></table></figure><p><font color="#f00">max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@192 bin]# nano /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">*               soft    nofile          65536</span><br><span class="line">*               hard    nofile          65536</span><br><span class="line">*               soft    nproc           4096</span><br><span class="line">*               hard    nproc           4096</span><br></pre></td></tr></table></figure><p><font color="#f00">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@192 bin]# su elasticsearch</span><br><span class="line">[elasticsearch@192 bin]$ ./elasticsearch</span><br></pre></td></tr></table></figure><p><a href="http://192.168.0.113:9200/" target="_blank" rel="noopener">http://192.168.0.113:9200/</a></p><h2 id="Logstash-收集数据保存到es">2.2. Logstash 收集数据保存到es</h2><p><a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a> 解压后进入config文件夹下</p><p>nano  config/logstash-sample.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Sample Logstash configuration <span class="keyword">for</span> creating a simple</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Beats -&gt; Logstash -&gt; Elasticsearch pipeline.</span></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; ["localhost:9200"]</span><br><span class="line">    index =&gt; "%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;"</span><br><span class="line">    #user =&gt; "elastic"</span><br><span class="line">    #password =&gt; "changeme"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logstash-sample.conf中的内容改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 4560</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; ["192.168.0.113:9200"]</span><br><span class="line">    index =&gt; "applog"</span><br><span class="line">    #user =&gt; "elastic"</span><br><span class="line">    #password =&gt; "changeme"</span><br><span class="line">  &#125;</span><br><span class="line">  stdout&#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装json_lines</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./logstash-plugin list|grep json-lines</span><br><span class="line">./logstash-plugin install logstash-codec-json_lines</span><br></pre></td></tr></table></figure><h2 id="Kibana-可视化界面">2.3. Kibana 可视化界面</h2><p><a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a></p><p>config/kibana.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To allow connections from remote users</span></span><br><span class="line">server.host: "192.168.0.100"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The URLs of the Elasticsearch instances to use <span class="keyword">for</span> all your queries.</span></span><br><span class="line">elasticsearch.hosts: ["http://192.168.0.100:9200"]</span><br></pre></td></tr></table></figure><p>虚拟机中ELK全开+本机Intellij项目运行 笔记本完全卡死了。。。故采用树莓派安装ELK</p><h1 id="树莓派">3. 树莓派</h1><p><a href="https://zhuanlan.zhihu.com/p/23111516" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23111516</a></p><h2 id="elasticsearch-1-0-1">3.1. elasticsearch-1.0.1</h2><p><a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-1-0-1" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-1-0-1</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pi@pi:/usr/local $ cd es1</span><br><span class="line">pi@pi:/usr/local/es1 $ ls</span><br><span class="line">bin  config  lib  LICENSE.txt  NOTICE.txt  README.textile</span><br><span class="line">root@pi:/usr/local/es1# cd config</span><br><span class="line">root@pi:/usr/local/es1/config# nano elasticsearch.yml </span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群名字，如果要搭集群的话，同个网段内的Elasticsearch应用集群名取得一样就行了，应用会自动广播组成集群的，非常方便</span></span><br><span class="line">cluster.name: es-pi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点的名称，这个应用的节点名字叫啥，用于区分同个集群里的不同节点</span></span><br><span class="line">node.name: "node-pi"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否为主节点，一个集群里必须有一个主节点，也只能有一个主节点。当出现一个主节点后，其他master: <span class="literal">true</span>的节点都只会成为备用主节点，只有当之前的主节点挂了的时候其他备用的节点才会顶上来。</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否是数据节点，一个集群必须要有至少一个数据节点来存储数据</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认这个集群中每个索引的分片数量。Elasticsearch中的数据都是存储在索引（index）中的（不同于sql数据库中的索引的概念），每个索引会被分成多个分片到不同的数据节点中进行保存。这就是一个分布式文件数据库的概念</span></span><br><span class="line">index.number_of_shards: 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认这个集群中每个分片的副本数量。Elasticsearch中的每个分片都会产生等同于该配置数量的副本，副本分片一般不会与主分片存储在相同的主机节点中，当有主机挂掉的时候，该节点上的分片就丢失了，这时，如果设置了副本分片（相当于备份），那就会保证索引的完整性。如果是单节点没有集群的话，这里配置0就可以了</span></span><br><span class="line">index.number_of_replicas: 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点中数据存储的路径，这条不配也没事，默认存储在Elasticsearch文件夹中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> path.data: /path/to/data</span></span><br><span class="line"></span><br><span class="line">root@pi:/usr/local/es1/bin# nano elasticsearch.in.sh</span><br><span class="line">root@pi:/usr/local/es1/bin# </span><br><span class="line">ES_MIN_MEM=128m</span><br><span class="line">ES_MAX_MEM=128m</span><br></pre></td></tr></table></figure><h2 id="Kibana-3-0-0">3.2. Kibana-3.0.0</h2><p><a href="https://www.elastic.co/cn/downloads/past-releases/kibana-3-0-0" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases/kibana-3-0-0</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/home/pi# cd /usr/local/kibana</span><br><span class="line">root@pi:/usr/local/kibana# ls</span><br><span class="line">app  build.txtconfig.js  cssfavicon.ico  font  imgindex.html  LICENSE.mdREADME.md  vendor</span><br><span class="line">root@pi:/usr/local/kibana# nano config.js</span><br><span class="line"></span><br><span class="line">elasticsearch: "http://192.168.0.112:9200",</span><br></pre></td></tr></table></figure><p>kibana需要挂载到tomcat或nignx中显示</p><p>整个文件添加到tomcat的webapps文件夹下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/tomcat8/webapps# cp -rf /usr/local/kibana /usr/local/tomcat8/webapps</span><br><span class="line">root@pi:/usr/local/tomcat8/webapps# ls</span><br><span class="line">root@pi:/usr/local/tomcat8/webapps# ls</span><br><span class="line">docs  exampleshost-manager  kibana  manager  ROOT</span><br></pre></td></tr></table></figure><p>运行tomcat <a href="http://192.168.0.112:8080/kibana/index.html" target="_blank" rel="noopener">http://192.168.0.112:8080/kibana/index.html</a></p><p><img src="/2020/03/29/ElasticSearch安装及实践/kibanaindex.png" alt></p><p>根据索引查找</p><p><img src="/2020/03/29/ElasticSearch安装及实践/kibana-index.png" alt></p><h2 id="logstash-2-0-0">3.3. logstash-2.0.0</h2><p><a href="https://www.elastic.co/cn/downloads/past-releases/logstash-2-0-0" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases/logstash-2-0-0</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/home/pi/Downloads# tar zxvf logstash-2.0.0.tar.gz</span><br><span class="line">root@pi:/home/pi/Downloads# cp -rf logstash-2.0.0 /usr/local/logstash</span><br><span class="line">root@pi:/home/pi# cd /usr/local/logstash</span><br><span class="line">root@pi:/usr/local/logstash# ls</span><br><span class="line">bin  CHANGELOG.md  CONTRIBUTORS  Gemfile  Gemfile.jruby-1.9.lock  lib  LICENSElogstash.conf  NOTICE.TXT  vendor</span><br><span class="line">root@pi:/usr/local/logstash# cd bin</span><br><span class="line">root@pi:/usr/local/logstash/bin# ls</span><br><span class="line">logstash  logstash.batlogstash.lib.sh  plugin  plugin.bat  rspec  rspec.bat  setup.bat</span><br><span class="line">root@pi:/usr/local/logstash/bin# ./logstash</span><br></pre></td></tr></table></figure><h3 id="运行出错-libjffi-1-2-so">3.3.1. 运行出错 libjffi-1.2.so</h3><p><font color="#f00">java.lang.UnsatisfiedLinkError: /usr/local/logstash/vendor/jruby/lib/jni/arm-Linux/libjffi-1.2.so: /usr/local/logstash/vendor/jruby/lib/jni/arm-Linux/libjffi-1.2.so: 无法打开共享对象文件: 没有那个文件或目录</font></p><p><a href="https://discuss.elastic.co/t/logstash-7-x-on-raspberry-pi-4/205348" target="_blank" rel="noopener">https://discuss.elastic.co/t/logstash-7-x-on-raspberry-pi-4/205348</a></p><p><strong>安装texinfo,jruby</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/logstash/bin# apt-get install apt-transport-https jruby -y</span><br><span class="line">root@pi:/usr/local/logstash/bin# apt-get install texinfo build-essential ant git -y</span><br></pre></td></tr></table></figure><p><font color="#f00">perl-base 5.24.1-3+deb9u6 [无候选版本]</font></p><p><strong>安装perl</strong></p><p><a href="https://packages.debian.org/buster/arm64/perl/download" target="_blank" rel="noopener">https://packages.debian.org/buster/arm64/perl/download</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/logstash/bin# nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">镜像</span></span><br><span class="line">deb http://ftp.cn.debian.org/debian buster main </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">升级</span></span><br><span class="line">root@pi:/usr/local/logstash/bin# apt-get install update</span><br></pre></td></tr></table></figure><p><font color="#f00">W: GPG 错误:<a href="http://ftp.us.debian.org/debian" target="_blank" rel="noopener">http://ftp.us.debian.org/debian</a> stretch Release: 由于没有公钥,无W: GPG 错误:<a href="http://ftp.us.debian.org/debian" target="_blank" rel="noopener">http://ftp.us.debian.org/debian</a> stretch Release: 由于没有公钥,无法验证下列签名 NO_PUBKEY &lt;&lt; key&gt;&gt;</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys &lt;&lt;key&gt;&gt;</span><br></pre></td></tr></table></figure><p><font color="#f00">W: 目标 Packages (main/binary-armhf/Packages) 在 /etc/apt/sources.list.d/elastic-7.x.list:1和 /etc/apt/sources.list.d/elastic-7.x.list:2 中被配置了多次</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/logstash/bin# cd /etc/apt/sources.list.d</span><br><span class="line">root@pi:/etc/apt/sources.list.d# ls</span><br><span class="line">docker.list elastic-7.x.list raspi.list</span><br><span class="line">root@pi:/etc/apt/sources.list.d# rm -r elastic-7.x.list</span><br><span class="line">root@pi:/etc/apt/sources.list.d# sudo apt-get update</span><br><span class="line">root@pi:/etc/apt/sources.list.d#</span><br><span class="line">root@pi:/etc/apt/sources.list.d#</span><br><span class="line">root@pi:/etc/apt/sources.list.d# apt-get install perl</span><br></pre></td></tr></table></figure><p><font color="#f00">依旧perl-base 5.24.1-3+deb9u6 [无候选版本]</font></p><p>手动安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/home/pi/Downloads# wget http://www.cpan.org/src/5.0/perl-5.24.1.tar.gz</span><br><span class="line">root@pi:/home/pi/Downloads# tar zxvf perl-5.24.1.tar.gz</span><br><span class="line">root@pi:/home/pi/Downloads# cp -rf perl-5.24.1 /usr/local/perl-5.24.1</span><br><span class="line">root@pi:/home/pi/Downloads# cd /usr/local/perl-5.24.1</span><br><span class="line">root@pi:/usr/local/perl-5.24.1# ./Configure -des -Dprefix=/usr  </span><br><span class="line">root@pi:/usr/local/perl-5.24.1# make  &amp;&amp; make install</span><br><span class="line">root@pi:/usr/local/perl-5.24.1# perl -v</span><br></pre></td></tr></table></figure><p><strong>编译jffi库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/<span class="built_in">local</span><span class="comment"># git clone https://github.com/jnr/jffi 9</span></span><br><span class="line">root@pi:/usr/<span class="built_in">local</span><span class="comment"># cd jffi/</span></span><br><span class="line">root@pi:/usr/<span class="built_in">local</span>/jffi<span class="comment"># ant jar</span></span><br></pre></td></tr></table></figure><p><strong>替换jffi</strong></p><p>将/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux下的libjffi-1.2.so 替换为/usr/local/jffi/build/jni/下的libjffi-1.2.so </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/jffi# cd /usr/local/logstash/vendor/jruby/lib/jni/arm-Linux</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux# ls</span><br><span class="line">libjffi-1.2.so</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux# cd /usr/local/jffi/build/jni/</span><br><span class="line">root@pi:/usr/local/jffi/build/jni# ls</span><br><span class="line">com_kenai_jffi_Foreign.h com_kenai_jffi_Foreign_InValidInstanceHolder.h  com_kenai_jffi_ObjectBuffer.hjffi  libjffi-1.2.so</span><br><span class="line">com_kenai_jffi_Foreign_InstanceHolder.h  com_kenai_jffi_Foreign_ValidInstanceHolder.h com_kenai_jffi_Version.hlibffi-arm-linux</span><br><span class="line">root@pi:/usr/local/jffi/build/jni# cd /usr/local/logstash/vendor/jruby/lib/jni/arm-Linux</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux# mv libjffi-1.2.so libjffi-1.2.so.old</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux# cd /usr/local/jffi/build/jni/</span><br><span class="line">root@pi:/usr/local/jffi/build/jni# cp libjffi-1.2.so /usr/local/logstash/vendor/jruby/lib/jni/arm-Linux/libjffi-1.2.so</span><br><span class="line">root@pi:/usr/local/jffi/build/jni# cd /usr/local/logstash/vendor/jruby/lib/jni/arm-Linux</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux# ls</span><br><span class="line">libjffi-1.2.solibjffi-1.2.so.old</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux#</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux#</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux#</span><br><span class="line">root@pi:/usr/local/logstash/vendor/jruby/lib/jni/arm-Linux# cd /usr/local/logstash/bin</span><br><span class="line">root@pi:/usr/local/logstash/bin# ./logstash</span><br><span class="line">io/console not supported; tty will not be manipulated</span><br><span class="line">No command given</span><br><span class="line"></span><br><span class="line">Usage: logstash &lt;command&gt; [command args]</span><br><span class="line">Run a command with the --help flag to see the arguments.</span><br><span class="line">For example: logstash agent --help</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  agent - runs the logstash agent</span><br><span class="line">  version - emits version info about this logstash</span><br><span class="line">root@pi:/usr/local/logstash/bin# ls</span><br><span class="line">logstash  logstash.batlogstash.lib.sh  plugin  plugin.bat  rspec  rspec.bat  setup.bat</span><br><span class="line">root@pi:/usr/local/logstash/bin# logstash</span><br><span class="line">bash: logstash：未找到命令</span><br><span class="line">root@pi:/usr/local/logstash/bin# ./logstash --help</span><br><span class="line">io/console not supported; tty will not be manipulated</span><br><span class="line">Usage:</span><br><span class="line">    /bin/logstash agent [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -f, --config CONFIG_PATH      Load the logstash config from a specific file</span><br><span class="line">                                  or directory.  If a directory is given, all</span><br><span class="line">                                  files in that directory will be concatenated</span><br><span class="line">                                  in lexicographical order and then parsed as a</span><br><span class="line">                                  single config file. You can also specify</span><br><span class="line">                                  wildcards (globs) and any matched files will</span><br><span class="line">                                  be loaded in the order described above.</span><br><span class="line">    -e CONFIG_STRING              Use the given string as the configuration</span><br><span class="line">                                  data. Same syntax as the config file. If no</span><br><span class="line">                                  input is specified, then the following is</span><br><span class="line">                                  used as the default input:</span><br><span class="line">                                  "input &#123; stdin &#123; type =&gt; stdin &#125; &#125;"</span><br><span class="line">                                  and if no output is specified, then the</span><br><span class="line">                                  following is used as the default output:</span><br><span class="line">                                  "output &#123; stdout &#123; codec =&gt; rubydebug &#125; &#125;"</span><br><span class="line">                                  If you wish to use both defaults, please use</span><br><span class="line">                                  the empty string for the '-e' flag.</span><br><span class="line">                                   (default: "")</span><br><span class="line">    -w, --filterworkers COUNT     Sets the number of filter workers to run.</span><br><span class="line">                                   (default: 2)</span><br><span class="line">    -l, --log FILE                Write logstash internal logs to the given</span><br><span class="line">                                  file. Without this flag, logstash will emit</span><br><span class="line">                                  logs to standard output.</span><br><span class="line">    -v                            Increase verbosity of logstash internal logs.</span><br><span class="line">                                  Specifying once will show 'informational'</span><br><span class="line">                                  logs. Specifying twice will show 'debug'</span><br><span class="line">                                  logs. This flag is deprecated. You should use</span><br><span class="line">                                  --verbose or --debug instead.</span><br><span class="line">    --quiet                       Quieter logstash logging. This causes only </span><br><span class="line">                                  errors to be emitted.</span><br><span class="line">    --verbose                     More verbose logging. This causes 'info' </span><br><span class="line">                                  level logs to be emitted.</span><br><span class="line">    --debug                       Most verbose logging. This causes 'debug'</span><br><span class="line">                                  level logs to be emitted.</span><br><span class="line">    -V, --version                 Emit the version of logstash and its friends,</span><br><span class="line">                                  then exit.</span><br><span class="line">    -p, --pluginpath PATH         A path of where to find plugins. This flag</span><br><span class="line">                                  can be given multiple times to include</span><br><span class="line">                                  multiple paths. Plugins are expected to be</span><br><span class="line">                                  in a specific directory hierarchy:</span><br><span class="line">                                  'PATH/logstash/TYPE/NAME.rb' where TYPE is</span><br><span class="line">                                  'inputs' 'filters', 'outputs' or 'codecs'</span><br><span class="line">                                  and NAME is the name of the plugin.</span><br><span class="line">    -t, --configtest              Check configuration for valid syntax and then exit.</span><br><span class="line">    -h, --help                    print help</span><br><span class="line">root@pi:/usr/local/logstash/bin#</span><br></pre></td></tr></table></figure><p><strong>运行logstash脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/logstash/bin# ./logstash -e 'input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;'</span><br><span class="line">io/console not supported; tty will not be manipulated</span><br><span class="line">Default settings used: Filter workers: 2</span><br><span class="line">Logstash startup completed</span><br><span class="line">Hello World</span><br><span class="line">&#123;</span><br><span class="line">       "message" =&gt; "Hello World",</span><br><span class="line">      "@version" =&gt; "1",</span><br><span class="line">    "@timestamp" =&gt; "2020-03-29T08:28:52.594Z",</span><br><span class="line">          "host" =&gt; "pi"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/logstash/bin#cd /usr/local/logstash</span><br><span class="line">root@pi:/usr/local/logstash# ls</span><br><span class="line">bin  CHANGELOG.md  CONTRIBUTORS  Gemfile  Gemfile.jruby-1.9.lock  lib  LICENSElogstash.conf  NOTICE.TXT  vendor</span><br><span class="line">root@pi:/usr/local/logstash# nano logstash.conf</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 4560</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; ["192.168.0.112:9200"]</span><br><span class="line">    index =&gt; "applog"</span><br><span class="line">    #user =&gt; "elastic"</span><br><span class="line">    #password =&gt; "changeme"</span><br><span class="line">  &#125;</span><br><span class="line">  stdout&#123; codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开放4560端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/logstash# iptables -I INPUT -i eth0 -p tcp --dport 4560 -j ACCEPT</span><br><span class="line">root@pi:/usr/local/logstash# iptables  -I OUTPUT -o eth0 -p tcp --sport 4560 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="创建Maven依赖">3.4. 创建Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.logstash.logback/logstash-logback-encoder --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="logback-spring-xml">3.5. logback-spring.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/base.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/defaults.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/console-appender.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--应用名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"APP_NAME"</span> <span class="attr">value</span>=<span class="string">"edu-service"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保存路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"edu-service"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;APP_NAME&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每天记录日志到文件appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE_PATH&#125;/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出到logstash的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"LOGSTASH"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.0.100:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> <span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--日志级别   DEBUG-INFO-WARN-ERROR  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"LOGSTASH"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="运行SpringBoot">4. 运行SpringBoot</h1><p><a href="http://192.168.0.112:8080/kibana/index.html#/dashboard/file/logstash.json" target="_blank" rel="noopener">http://192.168.0.112:8080/kibana/index.html#/dashboard/file/logstash.json</a></p><p><img src="/2020/03/29/ElasticSearch安装及实践/kibana.png" alt></p><p>树莓派终端</p><p><img src="/2020/03/29/ElasticSearch安装及实践/logstash.png" alt></p><p>运行一次就两千多个数据</p><p><img src="/2020/03/29/ElasticSearch安装及实践/result.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;elasticsearch kibana logstash ELK 最终选用低版本运行&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="/categories/Java/"/>
    
    
      <category term="ElasticSearch" scheme="/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>20200229</title>
    <link href="/2020/02/29/20200229/"/>
    <id>/2020/02/29/20200229/</id>
    <published>2020-02-29T14:26:57.000Z</published>
    <updated>2021-03-01T13:38:02.930Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d2415b0ac7d084c6f04b3f10d47ab376bfc1beb82eda5afed1753c8c93d0a2f">d6314501bcd5e5d69b9fb41bdacc395cb5e4656af1b804e3db5709b314184f24d711e23623ee27766086432344d123f79d0a8905ee3c25b1176883cdd594f3f9ca7bca40a48bb86dc368c27a2c305d2399b3a95cd092fcff6f63bd5d1dc16448bc238650e52ae0ed958c6af9201a7c2af594ced5ffd5471589d53fd49bc6fdc535f63a3ddcb9b06ffbae8ebb098e84bba76ee05e5e22329ad0ff9ed50631d4b03163078b993184b50de4317d7fee5bdb2c7e50a665600db494b12650985844b7adbc094124bbb4d5e84301b62d0feba8e258580cc68d1de2458c5d3b6ffdebf0acb71c1da1aea3f8a094aad8d15b6161aea2713aa78b0d4316f0e4eceb7f507bd4b7c7c0391c26ce6dbe43a6ff7bc12f40e20a5b6a100fd207df2245eb657563b8aa257cc08f308f08b9654f9869dd1020fef84fb12cc0f263d4eb8c3c122cdbacbf0de15fb33e12bf2b5c2a2d31013b5fc508f62402fb639ff3aed53ae783501d11b2fd773a4058ff80e05e6edfbb85f2e4aa9f20b7617db3caa905cc082429fde4cbd6d26b69ad8feb801a43fcdec47f8312b1d5642c016e84c31fb7cc45039acf2d76f02c18891edb12dc827cf70c81364cfe40dc53d9f174de4fb1bc54a1910a4f7b5b125cc65a135abd5aa6c2e9c15649358fa60419d0c0beb3a0c7bb82b09eca11dd05dd4dc12970a32c1c71a9e0bc55fc4a098287d987abcccdafb64a97f7a483ccee6f295400e26d40db1a083524407ecebbaab9e5d0f5bc67295f4ebe14777630282036730228652d028749721929a6ecfa8703d7986dcbbbdb3e2c943bffecd3f24c4a360bfa6db16f4f3afdea0131d7d03621b95fc03c1cb5300f9aa7f7b44e91e7336f97f4408c96ca536140405281c3d5e70a32980034c301aaebafadcebe0a2f7bb1c08a730c399e8a1962aa9b1e3e34b05b11f7f21b28d9039db28f04569240fd4e6bdd4d73ac2c8b078c536600ba802ea50855acbda1614a4be2049ac35e222e72179a6830a102d685053f012c20680fa44aaa00e9292a4bebb0315d4ee4793b9b93a036da7f79280328cb98b2e29228481447bd56aa1352d710829ea9e793026ac6389df08af7e628eb76c746257cfa58d0847a07c91fdbfca054173bfcaa4073150af34fa1a031cd2f1c7e0e2cbaa52a762edad790e78091375756c2f5d0c1074283662ffbc0d1f7c4105661e5ce6d9efe0194f39e23c33f9186a5b86d3b2eb6fea7760139c08ab1b05322f2db515e5e3642399040a82236f6051a29b54983ec493fde1acc8cbd6cdf5a1262a3069f8b63b052a9c2acde9b1bd2648ff0d54c86b3b6a3a1ea42fd986d49f6fd02acc8a964e4292037e2ebc1c327433e926c8230c6c11e7fe5d4173f36c7a70a8e354fa924425eefb3653a198671aa78f2a6d9dc671630e22f99802aad6c429ecb1733637e8036985a490bc6f37e9ba0760c0019591837b05cbc8f474c4877c16f6595d4762c4b2f934d2315180b91efdefcf27aef3dd49a1f6a7dba4be98831a3c2f8f87053904edb75444429ef13ea572988b34be7d8080e53af8fbf976617ac58f91362c01252a7d26db0a3e5f84b294c808ae1c14bb97f9d68d46bb70894d9bc609711bbeadc95779cc0dc194df12adb9e285bb39951b2a147a3549d4442cb834652480b4a5f598b075e20f1448911c54e499248eab6fbc4d8143de694a1781b3afd1e35180b77f9d066b61d1b2f246150a4c2e147a012b74a55eb8cceebd69c509dea927fca85b86f3833d8d73b11dc2ad74ad5f21095d1eefb603a7de38d1f82458294b211312b974dc8ad1c6ee9d89d094766907f57fa7d409db17e1b27f5ba37ca143d94491545402e87de910fe41ee4287c8a3ed2268f18918c42cf57ca56dad24f885cd25b58b14fadc2c6d4ed75cb2c6925bdf566340cb0b284217b46f71d18d808caaf21e51c3213514fda30dd825989913ce12a8c82974debaf2983dc57e36343ce63c523fb9657d81039a553e2e15122f26edc23</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default"><font size="4px">输入密码，查看文章。</font></span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;这是一篇加密文章，内容可能是个人情感宣泄。如果你确实想看，请与我联系。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="小黑屋" scheme="/tags/%E5%B0%8F%E9%BB%91%E5%B1%8B/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装hexo</title>
    <link href="/2020/02/19/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85hexo/"/>
    <id>/2020/02/19/树莓派安装hexo/</id>
    <published>2020-02-19T14:45:37.000Z</published>
    <updated>2020-02-26T07:11:58.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">nodejs npm hexo</blockquote><a id="more"></a><h1 id="安装nodejs">1. 安装nodejs</h1><p><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p><img src="/2020/02/19/树莓派安装hexo/nodejs.png" alt></p><p>下载到树莓派，解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tar -xJvf node-v12.16.0-linux-armv7l.tar.xz</span></span><br></pre></td></tr></table></figure><p>复制到目标文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cp -rf node-v12.16.0-linux-armv7l /usr/<span class="built_in">local</span>/nodejs</span></span><br></pre></td></tr></table></figure><h1 id="创建软链接">2. 创建软链接</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/nodejs/bin/node /usr/bin/node</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/nodejs/bin/npm /usr/bin/npm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/nodejs/bin/npx /usr/bin/npx</span></span><br></pre></td></tr></table></figure><h1 id="查看版本">3. 查看版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node -v</span></span><br><span class="line">v12.16.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> npm -v</span></span><br><span class="line">6.13.4</span><br></pre></td></tr></table></figure><h1 id="下载hexo">4. 下载hexo</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;nodejs npm hexo&lt;/blockquote&gt;
    
    </summary>
    
      <category term="树莓派" scheme="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派" scheme="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="hexo" scheme="/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat8无法进入管理页面</title>
    <link href="/2020/02/19/Tomcat8%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2/"/>
    <id>/2020/02/19/Tomcat8无法进入管理页面/</id>
    <published>2020-02-19T07:46:23.000Z</published>
    <updated>2021-03-01T13:39:43.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Manager-App管理权限设置后仍无法进入页面</blockquote><a id="more"></a><h1 id="配置管理账号密码">1. 配置管理账号密码</h1><p>当首次打开localhost:8080时，点击Manager App按钮，出现403配置信息</p><p>进入tomcat8/conf/tomcat-users.xml配置账号密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@pi:/usr/local/tomcat8/bin# cd ..</span><br><span class="line">root@pi:/usr/local/tomcat8# cd conf</span><br><span class="line">root@pi:/usr/local/tomcat8/conf# nano tomcat-users.xml</span><br><span class="line"></span><br><span class="line">&lt;role rolename="manager-gui"/&gt;</span><br><span class="line">&lt;user username="tomcat8" password="tomcat8" roles="manager-gui,manager-script"/&gt;</span><br></pre></td></tr></table></figure><h1 id="重启tomcat仍出现403">2. 重启tomcat仍出现403</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You are not authorized to view this page.</span><br><span class="line">By default the Host Manager is only accessible from a browser running on the same machine as Tomcat. If you wish to modify this restriction, you'll need to edit the Host Manager's context.xml file.</span><br></pre></td></tr></table></figure><p>编辑tomcat8/webapps/manager/META-INF/context.xml</p><p>tomcat8/webapps/host-manager/META-INF/context.xml</p><p>将其中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /&gt; --&gt;</span></span><br></pre></td></tr></table></figure><p>注释掉</p><p>重启tomcat</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Manager-App管理权限设置后仍无法进入页面&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="/categories/Java/"/>
    
    
      <category term="Tomcat" scheme="/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse自动代码补全</title>
    <link href="/2020/02/12/Eclipse%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8/"/>
    <id>/2020/02/12/Eclipse自动代码补全/</id>
    <published>2020-02-12T11:13:12.000Z</published>
    <updated>2021-03-01T14:08:48.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Eclipse操作-同时适用于jsp，xml提示</blockquote><a id="more"></a><p>window-&gt;Preferences-&gt;Java-&gt;Editor-&gt;Content Assist</p><p>auto activaction -&gt; Enable auto activation -&gt; Auto Activation triggers for java “.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,([{”<br><img src="/2020/02/12/Eclipse自动代码补全/eclipse.png" alt></p><p>window-&gt;Preferences-&gt;Java-&gt;Editor-&gt;Content Assist-&gt;Advanced </p><p>Select the proposal kinds contained in the ‘default’ content assist list中全部勾上！</p><p><img src="/2020/02/12/Eclipse自动代码补全/2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Eclipse操作-同时适用于jsp，xml提示&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="/2020/02/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>/2020/02/08/正则表达式/</id>
    <published>2020-02-08T15:04:41.000Z</published>
    <updated>2021-03-23T15:16:39.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">描述的是一个规则，匹配一类字符串</blockquote><a id="more"></a><h1 id="示例">1. 示例</h1><p><code>[Ji]ava.+</code></p><p>匹配第一个字母是J或j，接下来三个三个字母是ava，其余部分由一个或多个任意的字符构成</p><p>[Jj], [0-9] 表示一个范围，所有Unicode值落在两个边界范围内的字符</p><p>[^] 表示补集</p><h1 id="转义字符">2. 转义字符</h1><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行符</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\\</code></td><td>\</td></tr><tr><td><code>\^</code>,<code>\$</code>,<code>\.</code>,<code>\(</code>,<code>\)</code>,<code>\{</code>,<code>\}</code>,<code>\?</code>,<code>\+</code>,<code>\-</code>,<code>\[</code>,<code>\]</code>,<code>|</code></td><td>匹配\后字符本身</td></tr></tbody></table><h1 id="标准字符">3. 标准字符</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\d</td><td>0-9数字</td></tr><tr><td>\w</td><td>字母，数字，下划线 A-Z,a-z,0-9</td></tr><tr><td>\s</td><td>空格，制表符，换行符等空白字符的其中任意一个</td></tr><tr><td>.</td><td>任意字符</td></tr></tbody></table><h1 id="内任意字符">4. [] 内任意字符</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 a或b或c或5或@</td></tr><tr><td>[^abc]</td><td>a,b,c以外的任意字符</td></tr><tr><td>[f-k]</td><td>f-k之间的任意字母</td></tr><tr><td>[^A-F0-3]</td><td>A-F,0-3之外的任意字符</td></tr></tbody></table><p>包含在中括号中的特殊符号会失去特殊意义，除了^,-之外。</p><p>如<code>[\d.\-+]</code>表示数字，小数点，-，+</p><h1 id="量词">5. 量词</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>{n}</td><td>表达式重复n次</td></tr><tr><td>{m,n}</td><td>重复至少m次，至多n次</td></tr><tr><td>{m,}</td><td>重复至少m次</td></tr><tr><td>?</td><td>0次或1次，{0,1}</td></tr><tr><td>+</td><td>至少1次，{1,}</td></tr><tr><td>*</td><td>不出现或出现任意次，{0,}</td></tr></tbody></table><h1 id="字符边界">6. 字符边界</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>与字符串开始的地方匹配</td></tr><tr><td>$</td><td>与字符串结束的地方匹配</td></tr><tr><td>\b</td><td>匹配一个单词边界, (前面的字符和后面的字符不全是\w)</td></tr></tbody></table><h1 id="选择符和分组">7. 选择符和分组</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>|</td><td>两个表达式之间<code>或</code>关系</td></tr><tr><td>()</td><td>括号内的表达式可以作为整体被修饰，()\1表示捕获的整体作为匹配模式 go gogo</td></tr><tr><td>(?:表达式)</td><td>抵消()带来的作用</td></tr></tbody></table><h1 id="预搜索-零宽断言">8. 预搜索-零宽断言</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>(?=exp)</td><td>断言后匹配exp <br>[a-z]+(?:\d)<br> go222 222本身不计入匹配</td></tr><tr><td>(?&lt;=exp)</td><td>断言前匹配exp</td></tr><tr><td>(?!exp)</td><td>断言后不匹配exp</td></tr><tr><td>(?&lt;!exp)</td><td>断言前不匹配exp</td></tr></tbody></table><h1 id="常用表达">9. 常用表达</h1><h2 id="电话号码">9.1. 电话号码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d&#123;<span class="number">2</span>-<span class="number">3</span>&#125;-\d&#123;<span class="number">7</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="number">1</span>[<span class="number">356789</span>]\d&#123;<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="邮箱">9.2. 邮箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12334</span><span class="meta">@qq</span>.com</span><br><span class="line"><span class="number">234</span><span class="meta">@sina</span>.com.cn</span><br><span class="line"></span><br><span class="line">[\w\-]+@[A-Za-z0-<span class="number">9</span>]+(\.[A-Za-z]&#123;<span class="number">2</span>,<span class="number">3</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="java中使用">10. java中使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\d"</span>);</span><br><span class="line"></span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"aw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag =matcher.matches();</span><br><span class="line">System.out.println(flag);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试获取下一个匹配，找到则为true</span></span><br><span class="line"><span class="keyword">boolean</span> bool = matcher.find();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回匹配的子字符串</span></span><br><span class="line">String str = matcher.group(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将匹配的字符串替换为#</span></span><br><span class="line">String str = matcher.replaceAll(<span class="string">"#"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//惰性获取</span></span><br><span class="line"><span class="comment">//用正则表达式匹配边界，将输入字符串分割成字符串数组</span></span><br><span class="line">Stream&lt;String&gt; stream = pattern.splitAsStream(<span class="string">"输入字符串"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;描述的是一个规则，匹配一类字符串&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="/categories/Java/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式</title>
    <link href="/2020/02/07/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/02/07/java设计模式/</id>
    <published>2020-02-07T10:56:29.000Z</published>
    <updated>2021-03-23T13:31:50.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">GOF(Group For Four)23设计模式</blockquote><a id="more"></a><h1 id="创建型模式">1. 创建型模式</h1><h2 id="单例模式">1.1. 单例模式</h2><p>只生成一个实例</p><h3 id="饿汉式">1.1.1. 饿汉式</h3><p>线程安全，调用效率高。不能延时加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="comment">//类初始化时，立即加载这个对象加载时，天然是线程安全的</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//方法没有同步，调用效率高</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式">1.1.2. 懒汉式</h3><p>线程安全，调用效率不高，可以延时加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重检测锁式">1.1.3. 双重检测锁式</h3><p>由于JVM底层内部模型原因，偶尔会出问题，不建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      Singleton s;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">        s = instance;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">              s = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          instance = s;</span><br><span class="line">        &#125;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类式">1.1.4. 静态内部类式</h3><p>线程安全，调用效率高，不能延时加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletonclass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Singletonclass.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举单例">1.1.5. 枚举单例</h3><p>线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化漏洞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line"></span><br><span class="line">  INSTANCE;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式">1.2. 工厂模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"奥迪在跑"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baoma</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"宝马在跑"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现创建者和调用者分离</p><h3 id="简单工厂模式-静态">1.2.1. 简单工厂模式-静态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    Car c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"奥迪"</span>.equals(type))&#123;</span><br><span class="line">      c = <span class="keyword">new</span> Audi();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"宝马"</span>.equals(type))&#123;</span><br><span class="line">      c = <span class="keyword">new</span> Baoma();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">  <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car audi = <span class="keyword">new</span> AudiFactory().creatCar();</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式">1.3. 抽象工厂模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuxuryEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seat</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuxurySeat</span> <span class="keyword">implements</span> <span class="title">Seat</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowSeat</span> <span class="keyword">implements</span> <span class="title">Seat</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFatory</span></span>&#123;</span><br><span class="line">  <span class="function">Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Seat <span class="title">createSeat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuxuryCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式">1.4. 建造者模式</h2><h3 id="Airship">1.4.1. Airship</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Airship</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String engine;</span><br><span class="line"><span class="keyword">private</span> String escapeTower;</span><br><span class="line"><span class="keyword">private</span> String orbitalModule;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(String engine)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.engine = engine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEscapeTower</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> escapeTower;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEscapeTower</span><span class="params">(String escapeTower)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.escapeTower = escapeTower;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getOrbitalModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> orbitalModule;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrbitalModule</span><span class="params">(String orbitalModule)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.orbitalModule = orbitalModule;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Airship [engine="</span> + engine + <span class="string">", escapeTower="</span> + escapeTower + <span class="string">", orbitalModule="</span> + orbitalModule + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AirshipBuilder">1.4.2. AirshipBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AirshipBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">builderEngine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">builderOrbitalModule</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">builderEscapeTower</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AirshipDirector">1.4.3. AirshipDirector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AirshipDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Airship <span class="title">createAirship</span><span class="params">(AirshipBuilder builder)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CeacreteAirshipBuilder">1.4.4. CeacreteAirshipBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeacreteAirshipBuilder</span> <span class="keyword">implements</span> <span class="title">AirshipBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">builderEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"发动机"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">builderOrbitalModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"轨道仓"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">builderEscapeTower</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"逃逸塔"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CeacreteAirshipDirector">1.4.5. CeacreteAirshipDirector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeacreteAirshipDirector</span> <span class="keyword">implements</span> <span class="title">AirshipDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Airship <span class="title">createAirship</span><span class="params">(AirshipBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Airship airship = <span class="keyword">new</span> Airship();</span><br><span class="line">airship.setEngine(builder.builderEngine());</span><br><span class="line">airship.setEscapeTower(builder.builderEscapeTower());</span><br><span class="line">airship.setOrbitalModule(builder.builderOrbitalModule());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> airship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client">1.4.6. Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AirshipDirector director = <span class="keyword">new</span> CeacreteAirshipDirector();</span><br><span class="line"></span><br><span class="line">Airship airship=director.createAirship(<span class="keyword">new</span> CeacreteAirshipBuilder());</span><br><span class="line"></span><br><span class="line">System.out.println(airship);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式">1.5. 原型模式</h2><h1 id="结构型模式">2. 结构型模式</h1><h2 id="适配器模式">2.1. 适配器模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式">2.2. 桥接模式</h2><p>多层继承结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//电脑品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenvo</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dell</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">computer</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Brand brand;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Brand brand)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.brand=brand;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">    brand.sale();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(Brand brand)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(brand);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Computer c = <span class="keyword">new</span> Laptop(<span class="keyword">new</span> Dell());</span><br></pre></td></tr></table></figure><h2 id="装饰模式">2.3. 装饰模式</h2><p>IO流 BufferInputerStream(new InputStream())</p><p>线程 new Thread(new Runnable())</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Baoma</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> Car car;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SuperCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    car.move();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyCar</span> <span class="keyword">extends</span> <span class="title">SuperCar</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FlyCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(car);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.move();</span><br><span class="line">    fly(); <span class="comment">//添加装饰</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car car = <span class="keyword">new</span> Baoma();</span><br><span class="line">car.move(); </span><br><span class="line">FlyCar fly = <span class="keyword">new</span> FlyCar(car);</span><br><span class="line">fly.move(); <span class="comment">//添加了功能</span></span><br></pre></td></tr></table></figure><h2 id="组合模式">2.4. 组合模式</h2><p>树形结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">  <span class="function">Component <span class="title">getChlid</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外观模式">2.5. 外观模式</h2><p>简单封装</p><h2 id="享元模式">2.6. 享元模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代理模式">2.7. 代理模式</h2><h3 id="静态代理模式">2.7.1. 静态代理模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProxyStar</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyStar</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Star star;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">proxy</span><span class="params">(Star star)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.star=star;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    star.sing();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RealStar</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealStar</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Star star=<span class="keyword">new</span> RealStar();</span><br><span class="line">    ProxyStar proxy = <span class="keyword">new</span> ProxyStar(star);</span><br><span class="line">    </span><br><span class="line">    proxy.sing();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理模式">2.7.2. 动态代理模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyStar</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Star star;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyStar</span><span class="params">(Star star)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.star = star;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">method.invoke(star, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Star star = <span class="keyword">new</span> RealStar();</span><br><span class="line"></span><br><span class="line">ProxyStar proxyStar = <span class="keyword">new</span> ProxyStar(star);</span><br><span class="line"></span><br><span class="line">Star proxy = (Star) Proxy.newProxyInstance(</span><br><span class="line">      ClassLoader.getSystemClassLoader(), </span><br><span class="line">      <span class="keyword">new</span> Class[] &#123;Star.class&#125;, </span><br><span class="line">      proxyStar);</span><br><span class="line"></span><br><span class="line">proxy.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="行为型模式">3. 行为型模式</h1><h2 id="模版方法模式">3.1. 模版方法模式</h2><h2 id="命令模式">3.2. 命令模式</h2><h2 id="迭代器模式">3.3. 迭代器模式</h2><h2 id="观察者模式">3.4. 观察者模式</h2><h2 id="中介者模式">3.5. 中介者模式</h2><h2 id="备忘录模式">3.6. 备忘录模式</h2><h2 id="解释器模式">3.7. 解释器模式</h2><h2 id="状态模式">3.8. 状态模式</h2><h2 id="策略模式">3.9. 策略模式</h2><h2 id="职责链模式">3.10. 职责链模式</h2><h3 id="Leave">3.10.1. Leave</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leave</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String empName;</span><br><span class="line"><span class="keyword">private</span> String reason;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Leave</span><span class="params">(String empName, String reason,<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.empName = empName;</span><br><span class="line"><span class="keyword">this</span>.reason = reason;</span><br><span class="line"><span class="keyword">this</span>.day=day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmpName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> empName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpName</span><span class="params">(String empName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.empName = empName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> reason;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReason</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.reason = reason;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.day = day;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leader">3.10.2. Leader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> String name;</span><br><span class="line"><span class="keyword">protected</span> Leader nextLeader;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Leader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLeader</span><span class="params">(Leader nextLeader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.nextLeader = nextLeader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Leave leave)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Manager">3.10.3. Manager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Leave leave)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leave.getDay()&lt;<span class="number">3</span>) &#123;</span><br><span class="line">System.out.println(<span class="keyword">super</span>.name+ <span class="string">"批准请假"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.nextLeader!=<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.nextLeader.handleRequest(leave);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Director">3.10.4. Director</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Leave leave)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leave.getDay()&lt;<span class="number">10</span>) &#123;</span><br><span class="line">System.out.println(name+<span class="string">"批准"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.nextLeader.handleRequest(leave);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client-1">3.10.5. Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Leader director = <span class="keyword">new</span> Director(<span class="string">"主管"</span>);</span><br><span class="line"></span><br><span class="line">Leader manager = <span class="keyword">new</span> Manager(<span class="string">"经理"</span>);</span><br><span class="line"></span><br><span class="line">manager.setNextLeader(director);</span><br><span class="line"></span><br><span class="line">Leave leave = <span class="keyword">new</span> Leave(<span class="string">"员工"</span>, <span class="string">"过年"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">manager.handleRequest(leave);</span><br><span class="line"></span><br><span class="line">Leave leave2 = <span class="keyword">new</span> Leave(<span class="string">"员工"</span>, <span class="string">"过年"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">manager.handleRequest(leave2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问者模式">3.11. 访问者模式</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;GOF(Group For Four)23设计模式&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="/categories/Java/"/>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构03-栈和队列</title>
    <link href="/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>/2020/02/07/数据结构-栈和队列/</id>
    <published>2020-02-07T06:57:07.000Z</published>
    <updated>2021-05-28T17:19:56.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">栈[顺序栈，链栈]，队列[循环队列，链式队列]</blockquote><a id="more"></a><p>视频讲解，习题讲解，思维导图，PPT资源</p><p>链接: <a href="https://pan.baidu.com/s/1Fwji3dgqIhU6C4BzN13bBQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1Fwji3dgqIhU6C4BzN13bBQ</a>  密码: e4t2</p><h1 id="栈-Stack-基本概念">1. 栈(Stack) 基本概念</h1><h2 id="栈的定义">1.1. 栈的定义</h2><p>线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，其中n为表长，当n = 0时线性表是一个空表。若用<em>L</em>命名线性表，则其一般表示为 L = (<em>a</em><sub>1</sub>, a<sub>2</sub>, … , a<sub>i</sub>, a<sub>i+1</sub>, … , a<sub>n</sub>)</p><p>栈(Stack)是<code>只允许在一端进行插入或删除</code>操作的<code>线性表</code></p><p>逻辑结构：与普通线性表相同</p><p>数据的运算：插入、删除操作有区别</p><p><img src="/2020/02/07/数据结构-栈和队列/stack.png" alt></p><p>重要术语：栈顶、栈底、空栈</p><p><img src="/2020/02/07/数据结构-栈和队列/stack2.png" alt></p><h2 id="栈的基本操作">1.2. 栈的基本操作</h2><p>###创、销</p><p>InitStack(&amp;S)：初始化栈。构造一个空栈 S，分配内存空间。 </p><p>DestroyStack(&amp;S):销毁栈。销毁并释放栈 S 所占用的内存空间。</p><h3 id="增、删">1.2.1. 增、删</h3><p>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 </p><p>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。删除栈顶元素</p><p>GetTop(S, &amp;x)：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素。不删除栈顶元素，栈的使用场景中大多只访问栈顶元素</p><h3 id="其他常用操作">1.2.2. 其他常用操作</h3><p>StackEmpty(S)：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。</p><h2 id="栈的常考题型">1.3. 栈的常考题型</h2><p>进栈顺序:</p><p>a-&gt;b-&gt;c-&gt;d-&gt;e </p><p>有哪些合法的出栈顺序?</p><p>n个不同元素进栈，出栈元素不同排列的个数为 $\frac{1}{n+1}$C$_{2n}^{n}$</p><p>上述公式称为卡特兰(Catalan)数，可采用数学归纳法证明(不要求掌握)。</p><p>$\frac{1}{5+1}$C$_{10}^{5}$=$\frac{10∗9∗8∗7∗6}{6∗5∗4∗3∗2∗1}$ =42</p><h2 id="顺序栈">1.4. 顺序栈</h2><h3 id="顺序栈的定义">1.4.1. 顺序栈的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义栈中元素的最大个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="comment">//栈顶指针</span></span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">  SqStack s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><p><img src="/2020/02/07/数据结构-栈和队列/seq.JPG" alt></p><h3 id="初始化操作">1.4.2. 初始化操作</h3><p>top指向栈顶指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化栈顶指针</span></span><br><span class="line">  S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空操作">1.4.3. 判空操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(S.top == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈满判断">1.4.4. 栈满判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackFull</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进栈操作">1.4.5. 进栈操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//top指向栈顶</span></span><br><span class="line">  S.data[++S.top]=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈操作">1.4.6. 出栈操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x = S.data[S.top--];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读栈顶元素">1.4.7. 读栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x = S.data[S.top];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="若top指向栈顶后一个位置">1.4.8. 若top指向栈顶后一个位置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈空</span></span><br><span class="line">S.top==<span class="number">0</span>;</span><br><span class="line"><span class="comment">//栈满</span></span><br><span class="line">S.top==MaxSize;</span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line">S.data[S.top++]=x;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">x = S.data[--S.top];</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">x = S.data[S.top<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><h2 id="共享栈">1.5. 共享栈</h2><p>利用栈底位置相对不变的特性，让两个顺序栈共享一个一维空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。采用共享栈的好处是节省存储空间，降低发生<code>上溢</code>的可能</p><h3 id="共享栈的定义">1.5.1. 共享栈的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">  <span class="keyword">int</span> top0;</span><br><span class="line">  <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">  <span class="keyword">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br></pre></td></tr></table></figure><h3 id="初始化操作-1">1.5.2. 初始化操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">  <span class="keyword">int</span> top0;</span><br><span class="line">  <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">  <span class="keyword">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈顶指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">  S.top0=<span class="number">-1</span>;</span><br><span class="line">  S.top1=MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈满判断-1">1.5.3. 栈满判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.top0 + <span class="number">1</span>==S.top1;</span><br></pre></td></tr></table></figure><h2 id="链栈">1.6. 链栈</h2><p>用链式存储方式实现的栈</p><h3 id="链栈定义">1.6.1. 链栈定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">  <span class="comment">//数据域</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//指针域</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure><h3 id="两种实现方式">1.6.2. 两种实现方式</h3><h4 id="带头结点">1.6.2.1. 带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LiStack s;</span><br><span class="line">s-&gt;next == <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="不带头结点">1.6.2.2. 不带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LiStack s;</span><br><span class="line">s == <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="进栈操作-带头结点">1.6.3. 进栈操作(带头结点)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于链表的头插法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">  Linknode *e = (Linknode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linknode));</span><br><span class="line">  <span class="comment">//栈空间分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(e==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;data = x;</span><br><span class="line">  e-&gt;next = S-&gt;next;</span><br><span class="line">  S-&gt;next = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈操作-带头结点">1.6.4. 出栈操作(带头结点)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">  <span class="comment">//栈空</span></span><br><span class="line">  <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x = S-&gt;data;</span><br><span class="line">  S = S-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的应用">1.7. 栈的应用</h2><h3 id="括号匹配">1.7.1. 括号匹配</h3><p>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</p><p>匹配失败情况:</p><ol><li>左括号单身</li><li>右括号单身</li><li>左右括号不匹配</li></ol><p><img src="/2020/02/07/数据结构-栈和队列/kuohao.png" alt></p><p>判断括号是否匹配流程图：</p><p><img src="/2020/02/07/数据结构-栈和队列/seq.png" alt></p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//判断栈是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//新元素入栈</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//栈顶元素出栈，用x返回</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">char</span> &amp;x)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="keyword">char</span> str[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  SqStack S;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[i]==<span class="string">'&#123;'</span>||str[i]==<span class="string">'['</span>||str[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">      Push(S,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(StackEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span> topElem;</span><br><span class="line">      Pop(S,topElem);</span><br><span class="line">      <span class="keyword">if</span>(str[i]==<span class="string">')'</span>&amp;&amp;topElem!=<span class="string">'('</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(str[i]==<span class="string">']'</span>&amp;&amp;topElem!=<span class="string">'['</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(str[i]==<span class="string">'&#125;'</span>&amp;&amp;topElem!=<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> StackEmpty(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式求值">1.7.2. 表达式求值</h3><p>Reference: Wikipedia ——<strong>Reverse Polish notation</strong></p><p><img src="/2020/02/07/数据结构-栈和队列/suanshu.png" alt></p><p>Reverse Polish notation(逆波兰表达式 = 后缀表达式) </p><p>Polish notation(波兰表达式 = 前缀表达式)</p><p>中缀表达式(运算符在两个操作数中间)： a+b</p><p>后缀表达式(运算符在两个操作数后面)： ab+</p><p>前缀表达式(运算符在两个操作数前面)： +ab</p><h4 id="中缀表达式转后缀表达式-手算">1.7.2.1. 中缀表达式转后缀表达式(手算)</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照【<code>左操作数 右操作数 运算符</code>】的方式组合成一个新的操作数 </li><li>如果还有运算符没被处理，就继续【2】</li></ol><p><img src="/2020/02/07/数据结构-栈和队列/zhonghou.png" alt></p><p>运算顺序不唯一，因此对应的后缀表达式也不唯一</p><p>私房菜：“左优先”原则，不要FreeStyle，保证手算和机算结果相同“左优先”原则：只要左边的运算符能先计算，就优先算左边的</p><p><img src="/2020/02/07/数据结构-栈和队列/zhong2.png" alt></p><h4 id="后缀表达式的计算">1.7.2.2. 后缀表达式的计算</h4><ol><li>从左往右扫描下一个元素，直到处理完所有元素 </li><li>若扫描到操作数则压入栈，并回到【1】；否则执行【3】 <code>注意：先出栈的是“右操作数”</code></li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到【1】</li></ol><h4 id="中缀表达式转后缀表达式-机算">1.7.2.3. 中缀表达式转后缀表达式(机算)</h4><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 从左到右处理各个元素，直到末尾。可能遇到三种情况：</p><ol><li><p>遇到<code>操作数</code>。直接加入后缀表达式。</p></li><li><p>遇到<code>界限符</code>。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。</p></li><li><p>遇到<code>运算符</code>。依次弹出栈中优先级(<code>\*优先级高于+ -</code>)高于或等于当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈。</p><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p></li></ol><p>优先级：栈内$\geq$栈外时，栈内元素出栈</p><table><thead><tr><th></th><th>(</th><th>* /</th><th>+ -</th><th>)</th></tr></thead><tbody><tr><td>栈内</td><td>1</td><td>5</td><td>3</td><td>6</td></tr><tr><td>栈外</td><td>6</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><h4 id="中缀表达式的计算-用栈实现">1.7.2.4. 中缀表达式的计算(用栈实现)</h4><p>用栈实现中缀表达式的计算：</p><p>初始化两个栈，操作数栈和运算符栈</p><p>若扫描到操作数，压入操作数栈</p><p>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈(期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈)</p><h4 id="中缀表达式转前缀表达式-手算">1.7.2.5. 中缀表达式转前缀表达式(手算)</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照【运算符 左操作数 右操作数】的方式组合成一个新的操作数 </li><li>如果还有运算符没被处理，就继续 【2】</li></ol><p>“右优先”原则：只要右边的运算符能先计算，就优先算右边的</p><p><img src="/2020/02/07/数据结构-栈和队列/hou1.png" alt></p><h4 id="前缀表达式的计算">1.7.2.6. 前缀表达式的计算</h4><ol><li>从右往左扫描下一个元素，直到处理完所有元素 </li><li>若扫描到操作数则压入栈，并回到【1】;否则执行【3】 <code>注意:先出栈的是“左操作数”</code></li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到【1】</li></ol><h3 id="递归">1.7.3. 递归</h3><p>可以把原始问题转换为属性相同，但规模较小的问题</p><h4 id="函数调用背后的过程">1.7.3.1. 函数调用背后的过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">  func1(a,b);</span><br><span class="line">  c = a+b; <span class="comment">//#1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  func2(x);</span><br><span class="line">  x = x+<span class="number">10086</span>; <span class="comment">//#2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用的特点:最后被调用的函数最先执行结束(LIFO)</p><p>函数调用时，需要用一个栈存储:</p><ol><li>调用返回地址</li><li>实参</li><li>局部变量</li></ol><p><img src="/2020/02/07/数据结构-栈和队列/fun.png" alt></p><h4 id="计算正整数的阶乘-n">1.7.3.2. 计算正整数的阶乘 n!</h4><p>factorial (n) = $\left{\begin{matrix}<br>n*factorial(n-1) , n&gt;1  (递归表达式)&amp; \<br>1, n=1 (边界条件)&amp; \<br>1, n=0  (边界条件)&amp;<br>\end{matrix}\right.$</p><p><img src="/2020/02/07/数据结构-栈和队列/digui.png" alt></p><h4 id="求斐波那契数列">1.7.3.3. 求斐波那契数列</h4><p>Fib(n)=$\left{\begin{matrix}<br>Fib(n-1)+Fib(n-2) , n&gt;1 &amp; \<br>1, n=1 &amp; \<br>0, n=0 &amp;<br>\end{matrix}\right.$</p><p><img src="/2020/02/07/数据结构-栈和队列/digui2.png" alt></p><h1 id="队列-Queue-的基本概念">2. 队列(Queue)的基本概念</h1><h2 id="队列的定义">2.1. 队列的定义</h2><p>队列(Queue)是只允许在一端进行插入，在另一端删除的线性表</p><p>特点：先进入队列的元素先出队</p><p>重要术语:队头、队尾、空队列</p><p><img src="/2020/02/07/数据结构-栈和队列/queue.png" alt></p><h2 id="队列的基本操作">2.2. 队列的基本操作</h2><p>InitQueue(&amp;Q)：<code>初始化</code>队列，构造一个空队列Q。 </p><p>DestroyQueue(&amp;Q)：<code>销毁</code>队列。销毁并释放队列Q所占用的内存空间。</p><p>EnQueue(&amp;Q ,x)：<code>入队</code>，若队列Q未满，将x加入，使之成为新的队尾。 </p><p>DeQueue(&amp;Q ,&amp;x)：<code>出队</code>，若队列Q非空，删除队头元素，并用x返回。<code>删除队头元素</code></p><p>GetHead(Q ,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。<code>不删除队头元素</code></p><p>其他常用操作: </p><p>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。</p><h2 id="队列的顺序实现">2.3. 队列的顺序实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="comment">//队头指针，队尾指针</span></span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SqQueue Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q.front=0指向队头</p><p>Q.rear=0指向队尾后一个元素</p><p><img src="/2020/02/07/数据结构-栈和队列/sequeue.JPG" alt></p><h3 id="初始化操作-2">2.3.1. 初始化操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">  Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空">2.3.2. 判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q.rear == Q.front)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列–如何判满">2.3.3. 循环队列–如何判满</h3><p>如何判满？Q.rear==MaxSize？</p><p>在Q.front+1=Q.rear=Maxsize时，其实是列空的，该如何判断？<code>用循环队列</code></p><p>循环队列：用模运算将存储空间在逻辑上变成“环状”</p><p>判满方案有三种：</p><h4 id="队尾指针下一个位置是队头">2.3.3.1. 队尾指针下一个位置是队头</h4><p>队空：Q.rear==Q.front</p><p>队满：Q.front == (Q.rear+1)%MaxSize</p><p>入队：Q.data[Q.rear]=x;    Q.rear = (Q.rear+1)%MaxSize;</p><p>出队：x = Q.data[Q.front];    Q.front = (Q.front+1)%MaxSize;</p><h4 id="添加size元素">2.3.3.2. 添加size元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">  <span class="comment">//队列元素个数</span></span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>初始操作：Q.front=Q.rear=0;    Q.size=0；</p><p>入队元素：Q.rear++;    Q.size++;</p><p>元素出队：Q.front++;    Q.size–;</p><p>队满判断：Q.size==MaxSize-1;</p><p>队空判断：Q.size==0;</p><h4 id="添加标签位tag">2.3.3.3. 添加标签位tag</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> front,rear;</span><br><span class="line">  <span class="comment">//最近进行的是添加/删除</span></span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>初始化时，Q.rear=Q.front=0，Q.tag=0</p><p>每次删除操作成功时，都令Q.tag=0；</p><p>每次插入操作成功时，都令Q.tag=1；</p><p>队满判断：Q.rear==Q.front&amp;&amp;tag==1</p><p>队空判断：Q.rear==Q.front&amp;&amp;tag==0</p><p>入队：Q.rear++; Q.tag=1;</p><p>出队：Q.front++; Q.tag=0;</p><h3 id="取队头元素">2.3.4. 取队头元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x = Q.data[Q.front];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求元素个数">2.3.5. 求元素个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Q.rear+MaxSize-Q.front)%MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改队列指针指向">2.3.6. 修改队列指针指向</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向队头元素</span></span><br><span class="line">Q.front=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//指向队尾元素</span></span><br><span class="line">Q.rear=MaxSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">Q.rear = (Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">Q.data[Q.rear]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">x = Q.data[Q.front];</span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br></pre></td></tr></table></figure><h2 id="队列的链式存储">2.4. 队列的链式存储</h2><p>一个同时带有队头指针和队尾指针的单链表。头指针指向队头，尾指针指向队尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  LinkNode *front,*next;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-栈和队列/linkqueue.png" alt></p><h3 id="初始化操作-3">2.4.1. 初始化操作</h3><h4 id="带头结点-1">2.4.1.1. 带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">  Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">  Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不带头结点-1">2.4.1.2. 不带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">  Q.front=Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空-1">2.4.2. 判空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队">2.4.3. 入队</h3><h4 id="带头结点-2">2.4.3.1. 带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">  LinkNode *s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">  s-&gt;data=x;</span><br><span class="line">  s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//指针尾插法插入到链表中</span></span><br><span class="line">  Q.rear-&gt;next=s;</span><br><span class="line">  Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-栈和队列/enqueue.png" alt></p><h4 id="不带头结点-2">2.4.3.2. 不带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">  LinkNode *s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">  s-&gt;data=x;</span><br><span class="line">  s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    Q.front=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  Q.rear-&gt;next=s;</span><br><span class="line">  Q.rear=s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-栈和队列/noenqueue.png" alt></p><h3 id="出队">2.4.4. 出队</h3><h4 id="带头结点-3">2.4.4.1. 带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">    <span class="comment">//空队</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkNode *p=Q.front-&gt;next;</span><br><span class="line">  <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">  x=p-&gt;data;</span><br><span class="line">  <span class="comment">//修改头结点的next指针</span></span><br><span class="line">  Q.front-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="comment">//若为最后一个结点出队</span></span><br><span class="line">  <span class="keyword">if</span>(Q.rear==p)&#123;</span><br><span class="line">    <span class="comment">//修改rear指针</span></span><br><span class="line">    Q.rear=Q.front;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放结点空间</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不带头结点-3">2.4.4.2. 不带头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">    <span class="comment">//空队</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkNode *p=Q.front-&gt;next;</span><br><span class="line">  <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">  x=p-&gt;data;</span><br><span class="line">  <span class="comment">//修改头结点的指针</span></span><br><span class="line">  Q.front=p-&gt;next;</span><br><span class="line">  <span class="comment">//若为最后一个结点出队</span></span><br><span class="line">  <span class="keyword">if</span>(Q.rear==p)&#123;</span><br><span class="line">    <span class="comment">//修改front,rear指针</span></span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放结点空间</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队满">2.4.5. 队满</h3><p>顺序存储——预分配的空间耗尽时队满</p><p>链式存储——一般不会队满，除非内存不足</p><h2 id="双端队列">2.5. 双端队列</h2><p>只允许从两端插入、两端删除的线性表</p><p>若只使用其中一端的插入、删除操作，则效果等同于栈</p><h3 id="双端队列形式">2.5.1. 双端队列形式</h3><p><img src="/2020/02/07/数据结构-栈和队列/double.png" alt></p><h3 id="判断输出序列合法性">2.5.2. 判断输出序列合法性</h3><p>若数据元素输入序列为 1,2,3,4，则哪些输出序列是<code>合法</code>的，哪些是非法的?</p><p>𝐴$_{4}^{4}$= 4! = 24</p><h4 id="对于栈">2.5.2.1. 对于栈</h4><table><thead><tr><th>以1开头</th><th>以2开头</th><th>以3开头</th><th>以4开头</th></tr></thead><tbody><tr><td><code>1,2,3,4</code></td><td><code>2,1,3,4</code></td><td>3,1,2,4</td><td>4,1,2,3</td></tr><tr><td><code>1,2,4,3</code></td><td><code>2,1,4,3</code></td><td>3,1,4,2</td><td>4,1,3,2</td></tr><tr><td><code>1,3,2,4</code></td><td><code>2,3,1,4</code></td><td><code>3,2,1,4</code></td><td>4,2,1,3</td></tr><tr><td><code>1,3,4,2</code></td><td><code>2,3,4,1</code></td><td><code>3,2,4,1</code></td><td>4,2,3,1</td></tr><tr><td>1,4,2,3</td><td>2,4,1,3</td><td>3,4,1,2</td><td>4,3,1,2</td></tr><tr><td><code>1,4,3,2</code></td><td><code>2,4,3,1</code></td><td><code>3,4,2,1</code></td><td><code>4,3,2,1</code></td></tr></tbody></table><p>卡特兰数：14种合法出栈序列</p><p>$\frac{1}{n+1}$C$<em>{2n}^{n}$ = $\frac{1}{4+1}$C$</em>{8}^{4}$=14</p><h4 id="输入受限的双端队列">2.5.2.2. 输入受限的双端队列</h4><p>栈中合法的序列，双端队列中一定也合法</p><table><thead><tr><th>以1开头</th><th>以2开头</th><th>以3开头</th><th>以4开头</th></tr></thead><tbody><tr><td><code>1,2,3,4</code></td><td><code>2,1,3,4</code></td><td><code>3,1,2,4</code></td><td><code>4,1,2,3</code></td></tr><tr><td><code>1,2,4,3</code></td><td><code>2,1,4,3</code></td><td><code>3,1,4,2</code></td><td><code>4,1,3,2</code></td></tr><tr><td><code>1,3,2,4</code></td><td><code>2,3,1,4</code></td><td><code>3,2,1,4</code></td><td>4,2,1,3</td></tr><tr><td><code>1,3,4,2</code></td><td><code>2,3,4,1</code></td><td><code>3,2,4,1</code></td><td>4,2,3,1</td></tr><tr><td><code>1,4,2,3</code></td><td><code>2,4,1,3</code></td><td><code>3,4,1,2</code></td><td><code>4,3,1,2</code></td></tr><tr><td><code>1,4,3,2</code></td><td><code>2,4,3,1</code></td><td><code>3,4,2,1</code></td><td><code>4,3,2,1</code></td></tr></tbody></table><h4 id="输出受限的双端队列">2.5.2.3. 输出受限的双端队列</h4><table><thead><tr><th>以1开头</th><th>以2开头</th><th>以3开头</th><th>以4开头</th></tr></thead><tbody><tr><td><code>1,2,3,4</code></td><td><code>2,1,3,4</code></td><td><code>3,1,2,4</code></td><td><code>4,1,2,3</code></td></tr><tr><td><code>1,2,4,3</code></td><td><code>2,1,4,3</code></td><td><code>3,1,4,2</code></td><td>4,1,3,2</td></tr><tr><td><code>1,3,2,4</code></td><td><code>2,3,1,4</code></td><td><code>3,2,1,4</code></td><td><code>4,2,1,3</code></td></tr><tr><td><code>1,3,4,2</code></td><td><code>2,3,4,1</code></td><td><code>3,2,4,1</code></td><td>4,2,3,1</td></tr><tr><td><code>1,4,2,3</code></td><td><code>2,4,1,3</code></td><td><code>3,4,1,2</code></td><td><code>4,3,1,2</code></td></tr><tr><td><code>1,4,3,2</code></td><td><code>2,4,3,1</code></td><td><code>3,4,2,1</code></td><td><code>4,3,2,1</code></td></tr></tbody></table><p>有一个双端队列，输入序列为1，2，3，4，求以下条件的输出序列：</p><ol><li>能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列 <code>4,1,3,2</code></li><li>能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列 <code>4,2,1,3</code></li><li>不能由输入受限的双端队列得到，也不能由输出受限的双端队列得到的输出序列 <code>4,2,3,1</code></li></ol><h2 id="队列的应用">2.6. 队列的应用</h2><h3 id="层次遍历">2.6.1. 层次遍历</h3><p>对问题进行逐层或逐行处理。这类问题的解决方法往往在处理当前层或当前axing是就队下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。如二叉树的层次遍历，图的层次遍历。</p><p>层次遍历过程</p><ol><li>跟结点入队；</li><li>若队空，则结束遍历；否则重复【3】操作；</li><li>队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有有孩子，则将右孩子入队，返回【2】。</li></ol><p><img src="/2020/02/07/数据结构-栈和队列/search.png" alt></p><h3 id="在操作系统中的应用">2.6.2. 在操作系统中的应用</h3><p>在计算机系统中的作用：第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决有多用户引起的资源竞争问题。</p><p>多个进程争抢着使用有限的系统资源时，FCFS(First Come First Service， 先来先服务)是一种常用策略。</p><p>Eg1：CPU资源的分配</p><p>Eg2：去学校打印店打印论文，多个同学用同一台打印机打印，打印的先后顺序如何?</p><p><img src="/2020/02/07/数据结构-栈和队列/print.png" alt></p><h1 id="矩阵的压缩存储">3. 矩阵的压缩存储</h1><h2 id="数组的存储结构">3.1. 数组的存储结构</h2><h3 id="一维数组">3.1.1. 一维数组</h3><p><code>ElemType a[10];</code></p><table><thead><tr><th></th><th>a[0]</th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th><th>a[5]</th><th>a[6]</th><th>a[7]</th><th>a[8]</th><th>a[9]</th><th></th></tr></thead></table><p>各数组元素大小相同，且物理上连续存放。</p><p>数组元素a[i] 的存放地址 = LOC + i * sizeof(ElemType) (0≤i&lt;10)</p><h3 id="二维数组">3.1.2. 二维数组</h3><p><code>ElemType b[2][4];</code> 2行4列的二维数组</p><p>逻辑视角</p><table><thead><tr><th>b[0] [0]</th><th>b[0] [1]</th><th>b[0] [2]</th><th>b[0] [3]</th></tr></thead><tbody><tr><td>b[1] [0]</td><td>b[1] [1]</td><td>b[1] [2]</td><td>b[1] [3]</td></tr></tbody></table><p><code>行优先存储</code></p><table><thead><tr><th></th><th>b[0] [0]</th><th>b[0] [1]</th><th>b[0] [2]</th><th>b[0] [3]</th><th>b[1] [0]</th><th>b[1] [1]</th><th>b[1] [2]</th><th>b[1] [3]</th><th></th></tr></thead></table><p>M行N列的二维数组b[M] [N]中，若按行优先存储，则b[i] [j]的存储地址=LOC+(i*N+j) *sizeof(ElemType)</p><p><code>列优先存储</code></p><table><thead><tr><th></th><th>b[0] [0]</th><th>b[1] [0]</th><th>b[0] [1]</th><th>b[1] [1]</th><th>b[0] [2]</th><th>b[1] [2]</th><th>b[0] [3]</th><th>b[1] [3]</th><th></th></tr></thead></table><p>M行N列的二维数组b[M] [N]中，若按列优先存储，则b[i] [j]的存储地址=LOC+(j*M+i ) *sizeof(ElemType)</p><h2 id="特殊矩阵">3.2. 特殊矩阵</h2><p>压缩存储：为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间。</p><p>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵，上(下)三角矩阵，对角矩阵等。</p><h3 id="对称矩阵">3.2.1. 对称矩阵</h3><p><img src="/2020/02/07/数据结构-栈和队列/aij.png" alt></p><p>若 n 阶方阵中任意一个元素 a<sub>i,j</sub> 都有 a<sub>i,j</sub> = a<sub>j,i</sub> 则该矩阵为对称矩阵</p><p>普通存储：n*n 二维数组 </p><p>压缩存储策略：只存储主对角线+下三角区(或主对角线+上三角区)</p><p>策略:只存储主对角线+下三角区 按行优先原则将各元素存入一维数组中。</p><table><thead><tr><th>B[0]</th><th>B[1]</th><th>B[2]</th><th>B[3]</th><th>…</th><th></th><th>B[$\frac{(1+n)*n}{2}$-1]</th></tr></thead><tbody><tr><td>a<sub>1,1</sub></td><td>a<sub>2,1</sub></td><td>a<sub>2,2</sub></td><td>a<sub>3,1</sub></td><td>…</td><td>a<sub>n,n-1</sub></td><td>a<sub>n,n</sub></td></tr></tbody></table><p>思考:</p><ol><li><p>数组大小应为多少? </p><p>$\frac{(1+n)*n}{2}$</p></li><li><p>站在程序员的角度，对称矩阵压缩存储后怎样才能方便使用?</p><p>可以实现一个“映射”函数</p><p>矩阵下标 -&gt; 一维数组下标</p></li><li><p>按行优先的原则，a<sub>i,j</sub> 是第几个元素?</p><p>[1+2+···+(i-1)] + j  -&gt; 第 $\frac{i(i-1)}{2}$ + j 个元素 -&gt; k= $\frac{i(i-1)}{2}$+ j − 1</p></li><li><p>按行优先的原则，a<sub>j,i</sub>是第几个元素?</p><p>ai,j = aj,i (对称矩阵性质)</p><p>k= $\frac{j(j-1)}{2}$ + 𝑖 − 1</p></li></ol><p>故压缩到一维数组时k=$\left{\begin{matrix}<br>\frac{i(i-1)}{2}+j-1, i\geq j (下三角区和主对角线元素)  &amp; \<br>  \frac{j(j-1)}{2}+i-1, i&lt;j (上三角区元素a_{i,j} =a_{j,i})&amp;<br>\end{matrix}\right.$</p><h3 id="三角矩阵">3.2.2. 三角矩阵</h3><h4 id="下三角矩阵">3.2.2.1. 下三角矩阵</h4><p><img src="/2020/02/07/数据结构-栈和队列/xiasanjiao.png" alt></p><p>压缩存储策略：按行优先原则将橙色区元素存入一维数组中。并在最后一个位置存储常量c</p><table><thead><tr><th>B[0]</th><th>B[1]</th><th>B[2]</th><th>B[3]</th><th>…</th><th></th><th>B[$\frac{(1+n)*n}{2}$-1]</th><th>B[$\frac{(1+n)*n}{2}$]</th></tr></thead><tbody><tr><td>a<sub>1,1</sub></td><td>a<sub>2,1</sub></td><td>a<sub>2,2</sub></td><td>a<sub>3,1</sub></td><td>…</td><td>a<sub>n,n-1</sub></td><td>a<sub>n,n</sub></td><td>C</td></tr></tbody></table><p>按行优先的原则，a<sub>i,j</sub> 是第几个元素?</p><p>k=$\left{\begin{matrix}<br>\frac{i(i-1)}{2}+j-1, i\geq j (下三角区和主对角线元素)  &amp; \<br>  \frac{n(n+1)}{2}, i&lt;j (上三角区元素)&amp;<br>\end{matrix}\right.$</p><h4 id="上三角矩阵">3.2.2.2. 上三角矩阵</h4><p><img src="/2020/02/07/数据结构-栈和队列/shangsanjiao.png" alt></p><p>压缩存储策略：按行优先原则将绿色区元素存入一维数组中。并在最后一个位置存储常量c</p><table><thead><tr><th>B[0]</th><th>B[1]</th><th>B[2]</th><th>B[3]</th><th>…</th><th></th><th>B[$\frac{(1+n)*n}{2}$-1]</th><th>B[$\frac{(1+n)*n}{2}$]</th></tr></thead><tbody><tr><td>a<sub>1,1</sub></td><td>a<sub>1,2</sub></td><td>a<sub>1,3</sub></td><td>a<sub>1,4</sub></td><td>…</td><td>a<sub>n,n-1</sub></td><td>a<sub>n,n</sub></td><td>C</td></tr></tbody></table><p>按行优先的原则，ai,j 是第几个元素?</p><p>k=$\left{\begin{matrix}<br>\frac{(i-1)(2n-i+2)}{2}+(j-i), i\leq j (上三角区和主对角线元素)  &amp; \<br>  \frac{n(n+1)}{2}, i&gt;j (下三角区元素)&amp;<br>\end{matrix}\right.$</p><h3 id="三对角矩阵">3.2.3. 三对角矩阵</h3><p><img src="/2020/02/07/数据结构-栈和队列/sanduijiao.png" alt></p><p>三对角矩阵，又称带状矩阵：当|i - j|&gt;1时，有a$_{i,j}$ = 0 (1≤ i, j ≤n)</p><p>压缩存储策略：按行优先(或列优先)原则，只存储带状部分</p><table><thead><tr><th>B[0]</th><th>B[1]</th><th>B[2]</th><th>B[3]</th><th>…</th><th></th><th>B[3n-3]</th></tr></thead><tbody><tr><td>a$_{1,1}$</td><td>a$_{1,2}$</td><td>a$_{2,1}$</td><td>a$_{2,2}$</td><td>…</td><td>a$_{n,n-1}$</td><td>a$_{n,n}$</td></tr></tbody></table><p>a$_{i,j}$ (|i-j|$\leq$1) -&gt; B[k]</p><ol><li><p>按行优先的原则，a$_{i,j}$ 是第几个元素?</p><p>前i-1行共 3(i-1)-1 个元素 </p><p>a$_{i,j}$是 i 行第 j-i+2 个元素 </p><p>a$_{i,j}$是第 2i+j-2 个元素</p><p>数组下标从0开始：<code>k = 2i+j-3</code></p></li><li><p>若已知数组下标k，如何得到 i, j ? </p><p>B[k] -&gt; a$_{i,j}$</p><p>前i-1行共 3(i-1)-1 个元素，前i行共 3i-1 个元素，显然 </p><p>3(i-1)-1 &lt; k+1 ≤ 3i-1</p><p>i $\geq$ (k+2)/3</p><p><code>i = (k+2)/3</code> 向上取整即可满足</p><p>王道书的计算逻辑：</p><p>3(i-1)-1 ≤ k &lt; 3i-1<br> i $\leq$ (k+1)/3+1 </p><p><code>i = (k+1)/3+1</code></p><p>j = k– 2i + 3</p></li></ol><h3 id="稀疏矩阵">3.2.4. 稀疏矩阵</h3><p>稀疏矩阵：非零元素远远少于矩阵元素的个数<br>压缩存储策略：顺序存储—三元组 &lt;行，列，值&gt;，链式存储——十字链表法</p><h4 id="顺序存储—三元组-lt-行，列，值-gt">3.2.4.1. 顺序存储—三元组 &lt;行，列，值&gt;</h4><p><img src="/2020/02/07/数据结构-栈和队列/xishi1.png" alt><img src="/2020/02/07/数据结构-栈和队列/xishi2.png" alt></p><h4 id="链式存储——十字链表法">3.2.4.2. 链式存储——十字链表法</h4><p><img src="/2020/02/07/数据结构-栈和队列/xishi3.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;栈[顺序栈，链栈]，队列[循环队列，链式队列]&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构02-线性表</title>
    <link href="/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>/2020/02/07/数据结构-线性表/</id>
    <published>2020-02-07T06:56:56.000Z</published>
    <updated>2021-05-12T13:58:39.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">顺序表，单链表，双链表，循环链式，静态链表</blockquote><a id="more"></a> <p>视频讲解，习题讲解，思维导图，PPT资源</p><p>链接: <a href="https://pan.baidu.com/s/1iprTv68hPqAS3-YmF1oVWw" target="_blank" rel="noopener">https://pan.baidu.com/s/1iprTv68hPqAS3-YmF1oVWw</a> 提取码: b8hx </p><h1 id="线性表总览">1. 线性表总览</h1><p><img src="/2020/02/07/数据结构-线性表/zong.png" alt></p><p>数据结构三要素——逻辑结构、数据的运算、存储结构(物理结构)</p><p>存储结构不同，运算的实现方式不同</p><h2 id="线性表的定义-逻辑结构">1.1. 线性表的定义-逻辑结构</h2><p>Linear List：</p><p>Line 线 Eg:Sky line baby 天线宝宝</p><p>List 列表 Eg:a list of 一连串、一系列的</p><p>线性表是具有<font color="#f00">相同</font>数据类型的<em>n</em>(<em>n</em>≥0)个<font color="#f00">数据元素</font>的<font color="#f00">有限</font>序列，其中<em>n</em>为表长，当<em>n</em> = 0时线性表是一个空表。若用<em>L</em>命名线性表，则其一般表示为 L = (a<sub>1</sub>, a<sub>2</sub>, … , a<sub>i</sub>, a<sub>i+1</sub>, … , a<sub>n</sub>)</p><h3 id="线性表特点">1.1.1. 线性表特点</h3><p>$\circledast$ 表中元素的个数有限</p><p>$\circledast$ 表中元素具有逻辑上的顺序性，表中元素有其先后次序</p><p>$\circledast$ 表中元素都是数据元素，每个元素都是单个元素</p><p>$\circledast$ 表中元素的数据类型都相同，者意味着每个元素占有相同大小的存储空间</p><p>$\circledast$ 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容</p><p><font color="#f00">所有的整数按递增次序排列，因长度不定，不是线性表</font></p><h3 id="线性表概念">1.1.2. 线性表概念</h3><ul><li>a<sub>i</sub> 是线性表中的“第i个”元素线性表中的位序</li><li>a<sub>1</sub>是表头元素；a<sub>n</sub> 是表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继</li></ul><h2 id="线性表的基本操作-数据的运算">1.2. 线性表的基本操作-数据的运算</h2><p>为什么要实现对数据结构的基本操作?</p><ol><li>团队合作编程，你定义的数据结构要让别人能够很方便的使用(封装)</li><li>将常用的操作/运算封装成函数，避免重复工作，降低出错风险</li></ol><p><font color="#f00">Tips:比起学会“How”， 更重要的是想明白 “Why”</font></p><h3 id="创销">1.2.1. 创销</h3><p><code>InitList(&amp;L)</code>:初始化表。构造一个空的线性表L，分配内存空间。 </p><p><code>DestroyList(&amp;L)</code>:销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><h3 id="增、删">1.2.2. 增、删</h3><p><code>ListInsert(&amp;L,i,e)</code>:插入操作。在表L中的第i个位置上插入指定元素e。 </p><p><code>ListDelete(&amp;L,i,&amp;e)</code>:删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><h3 id="改、查">1.2.3. 改、查</h3><p> <code>LocateElem(L,e)</code>:按值查找操作。在表L中查找具有给定关键字值的元素。 </p><p><code>GetElem(L,i)</code>:按位查找操作。获取表L中第i个位置的元素的值。</p><h3 id="其他常用操作">1.2.4. 其他常用操作</h3><p><code>Length(L)</code>:求表长。返回线性表L的长度，即L中数据元素的个数。 </p><p><code>PrintList(L)</code>:输出操作。按前后顺序输出线性表L的所有元素值。 </p><p><code>Empty(L)</code>:判空操作。若L为空表，则返回true，否则返回false。</p><h3 id="Tips">1.2.5. Tips</h3><ol><li>对数据的操作(记忆思路) —— 创销、增删改查</li><li>C语言函数的定义 —— &lt;返回值类型&gt; 函数名 (&lt;参数1类型&gt; 参数1，&lt;参数2类型&gt; 参数2，……) </li><li>实际开发中，可根据实际需求定义其他的基本操作 </li><li>函数名和参数的形式、命名都可改变(Reference:严蔚敏版《数据结构》) 一一Key:命名要有可读性 </li><li>什么时候要传入引用“&amp;” —— 对参数的修改结果需要“带回来”</li></ol><h2 id="总结">1.3. 总结</h2><p><img src="/2020/02/07/数据结构-线性表/linear.png" alt></p><h1 id="顺序表">2. 顺序表</h1><h2 id="顺序表的定义">2.1. 顺序表的定义</h2><p>线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列 L = (a<sub>1</sub>, a<sub>2</sub>, … , a<sub>i</sub>, a<sub>i+1</sub>, … , a<sub>n</sub>)</p><p>顺序表—用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p><p>线性表L逻辑结构：a<sub>1</sub>—&gt;a<sub>2</sub>—&gt;a<sub>3</sub>—&gt;a<sub>4</sub>—&gt;a<sub>5</sub></p><table><thead><tr><th>内存</th><th>线性表第一个元素的存放位置是LOC (L)  LOC-location</th></tr></thead><tbody><tr><td>a<sub>1</sub></td><td>LOC(L)</td></tr><tr><td>a<sub>2</sub></td><td>LOC(L)+数据元素的大小</td></tr><tr><td>a<sub>3</sub></td><td>LOC(L)+数据元素的大小*2</td></tr><tr><td>a<sub>4</sub></td><td>LOC(L)+数据元素的大小*3</td></tr><tr><td>a<sub>5</sub></td><td>LOC(L)+数据元素的大小*4</td></tr></tbody></table><p>ElemType 就是顺序表中存放的数据元素类型</p><p>如何知道一个数据元素大小</p><p> C语言 <code>sizeof(ElemType)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">//号数 </span></span><br><span class="line">  <span class="keyword">int</span> people; <span class="comment">//人数</span></span><br><span class="line">&#125; Customer;</span><br></pre></td></tr></table></figure><p>sizeof(int) = 4B </p><p>sizeof(Customer) = 8B</p><h2 id="线性表的实现">2.2. 线性表的实现</h2><h3 id="静态分配">2.2.1. 静态分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义最大长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="comment">//顺序表的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义(静态分配方式)</span></span><br><span class="line"><span class="comment">//Sq:sequence —— 顺序，序列</span></span><br></pre></td></tr></table></figure><p>给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)</p><h4 id="实战">2.2.1.1. 实战</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="comment">//所有数据元素设置为默认初始值,不然内存中会有遗留的“脏数据”</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    L.data[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">  L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//声明一个顺序表</span></span><br><span class="line">  SqList L;</span><br><span class="line">  <span class="comment">//初始化顺序表</span></span><br><span class="line">  InitList(L);</span><br><span class="line">  <span class="comment">//遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,L.data[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分配</p><table><thead><tr><th>内存</th><th></th></tr></thead><tbody><tr><td>data[0]</td><td>1. 内存中分配存储顺序表L的空间。包括：MaxSize*sizeof(ElemType)和存储length的空间</td></tr><tr><td>data[1]</td><td>2. 把各个数据元素的值设为默认值(可省略)</td></tr><tr><td>data[2]</td><td></td></tr><tr><td>data[3]</td><td></td></tr><tr><td>data[4]</td><td></td></tr><tr><td>data[5]</td><td></td></tr><tr><td>data[6]</td><td></td></tr><tr><td>data[7]</td><td></td></tr><tr><td>data[8]</td><td></td></tr><tr><td>data[9]</td><td></td></tr><tr><td>length</td><td>3. length值为0</td></tr></tbody></table><p>Q：如果“数组”存满了怎么办?</p><p>A：可以放弃治疗，顺序表的表长刚开始确定后就无法更改(存储空间是静态的) </p><p>思考：如果刚开始就声明一个很大的内存空间呢?存在什么问题?</p><p>A：浪费空间</p><h3 id="动态分配">2.2.2. 动态分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的初始长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="comment">//顺序表的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList;<span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure><p>Key：动态申请和释放内存空间需要强制转型为你定义的数据元素类型指针</p><ul><li><p>C - malloc、free函数</p><p>头文件 <code>#include&lt;stdlib.h&gt;</code></p><p><code>L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize);</code></p><p>malloc 函数会申请一整片连续的存储空间</p><p>返回一个指针，需要强制转型为你定义的数据元素类型指针</p><p>返回的是申请的空间的首地址</p></li><li><p>C++ - new、delete 关键字</p><p>L.data = new ElemType[InitSize];</p></li></ul><h4 id="实战-1">2.2.2.1. 实战</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">  L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  L.length=<span class="number">0</span>;</span><br><span class="line">  L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *p = L.data;</span><br><span class="line">  L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="comment">//数据复制到新区域 - 时间开销大</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">    L.data[i]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  L.MaxSize=L.MaxSize+len;</span><br><span class="line">  <span class="comment">//释放原来的内存空间</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SeqList L;</span><br><span class="line">  InitList(L);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//扩容</span></span><br><span class="line">  IncreaseSize(L,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分配</p><p><img src="/2020/02/07/数据结构-线性表/dong.png" alt></p><h2 id="顺序表的特点">2.3. 顺序表的特点</h2><ol><li><p>随机访问，即可以在 O(1) 时间内找到第 i 个元素。<code>data[i-1]：静态分配、动态分配都一样</code></p></li><li><p>存储密度高，每个节点只存储数据元素 </p></li><li><p>拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高) </p></li><li><p>插入、删除操作不方便，需要移动大量元素</p><p>静态分配、动态分配都一样</p></li></ol><h2 id="顺序表的基本操作">2.4. 顺序表的基本操作</h2><h3 id="插入-O-n">2.4.1. 插入-O(n)</h3><p>1$\leqslant$ i $\leqslant$ L.length+1</p><p>用存储位置的相邻来体现数据元素之间的逻辑关系</p><p><code>ListInsert(&amp;L,i,e)</code>:插入操作。在表L中的第i个位置上插入指定元素e。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存储空间已满</span></span><br><span class="line">  <span class="keyword">if</span>(L.length&gt;=MaxSize)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第i个元素及之后的元素后移</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length;j&gt;=i;j--)&#123;</span><br><span class="line">    L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">  L.length++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题规模 n = L.length (表长)</p><ul><li><p>最好情况：新元素插入到表尾，不需要移动元素i = n+1，循环0次；最好时间复杂度 = O(1)</p></li><li><p>最坏情况：新元素插入到表头，需要将原有的n个元素全都向后移动 i = 1，循环n次；最坏时间复杂度 = O(n);</p></li><li><p>平均情况：假设新元素插入到任何一个位置的概率相同，即 i = 1,2,3, … , length+1 的概率都是 p = 1/(n+1)</p><p>i=1，循环n次；i=2时，循环n-1次；i=3，循环n-2次 ……i=n+1时，循环0次</p><p>平均循环次数=np+(n-1)p+(n-2)p+……+1⋅p=$\frac{1}{n+1}$ $\sum_{i=1}^{n+1}(n-i+1)$=$\frac{n(n+1)}{2}$ $\frac{1}{n+1}$=$\frac{n}{2}$ </p><p>平均时间复杂度 = O(n)</p></li></ul><h3 id="删除-O-n">2.4.2. 删除-O(n)</h3><p>1$\leqslant$ i $\leqslant$ L.length</p><p><code>ListDelete(&amp;L,i,&amp;e)</code> 删除操作。删除表L中第i个位置的元素， 并用e返回删除元素的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  e = L.data[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;L.length;j++)&#123;</span><br><span class="line">    L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SqList L;</span><br><span class="line">  InitList(L);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> e = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(ListDelete(L,<span class="number">3</span>,e))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已删除第3个元素，删除的元素值为%d\n"</span>,e);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除失败!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题规模 n = L.length (表长)</p><ul><li><p>最好情况：删除表尾元素，不需要移动其他元素 i = n，循环 0 次;最好时间复杂度 = O(1)</p></li><li><p>最坏情况：删除表头元素，需要将后续的 n-1 个元素全都向前移动 i = 1，循环 n-1 次;最坏时间复杂度 = O(n);</p></li><li><p>平均情况：假设删除任何一个元素的概率相同，即 i=1,2,3, … , length 的概率都是 p = 1/n</p><p> i=1,循环n-1次；i=2时,循环n-2次；i=3，循环n-3次 ……i=n时，循环0次</p><p>平均循环次数 = (n-1)p + (n-2)p + …… + 1⋅p = $\frac{1}{n}$ $\sum_{i=1}^{n}(n-i)$=$\frac{n(n-1)}{2}$ $\frac{1}{n}$=$\frac{n-1}{2}$</p><p>平均时间复杂度 = O(n)</p></li></ul><h3 id="查找">2.4.3. 查找</h3><h4 id="按位查找-O-1">2.4.3.1. 按位查找-O(1)</h4><p><code>GetElem(L,i)</code>:按位查找操作。获取表L中第i个位置的元素的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义最大长度</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"> </span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SeqList L, <span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">   <span class="comment">//和访问普通数组的方法一样</span></span><br><span class="line">   <span class="keyword">return</span> L.data[i<span class="number">-1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p><p>由于顺序表的各个数据元素在内存中连续存放,因此可以根据起始地址和数据元素大小立即找到第i个元素–“随机存取”</p><h4 id="按值查找-O-n">2.4.3.2. 按值查找-O(n)</h4><p><code>LocateElem(L,e)</code>:按值查找操作。在表L中查找具有给定关键字值的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的初始长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">  <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">  <span class="comment">//顺序表的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; SeqList; <span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L,ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.data[i]==e)&#123;</span><br><span class="line">      <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">      <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本数据类型:int、char、double、 float 等可以直接用运算符“==”比较</p><p>Q：结构类型的数据元素也这样吗?</p><p>A：C语言中，结构体的比较不能直接用 “== ”，需要依次对比各个分量来判断两个结构体是否相等</p><p>Tips:</p><p>《数据结构》考研初试中，手写代码可以直接用“==”，无论 ElemType 是基本数据类型还是结构类型</p><p>手写代码主要考察学生是否能理解算法思想，不会严格要求代码完全可运行 有的学校考《C语言程序设计》，那么，也许就要语法严格一些</p><p><strong>时间复杂度</strong></p><ul><li><p>最好情况：目标元素在表头，循环1次;最好时间复杂度 = O(1)</p></li><li><p>最坏情况：目标元素在表尾，循环 n 次;最坏时间复杂度 = O(n);</p></li><li><p>平均情况：假设目标元素出现在任何一个位置的概率相同，都是1/n</p><p>目标元素在第1位，循环1次；在第2位，循环2次；…… ;在第n位，循环n次</p><p>平均循环次数=1$\frac{1}{n}$+2$\frac{1}{n}$+3$\frac{1}{n}$+……+n$\frac{1}{n}$= $\frac{1}{n}$ $\sum_{i=1}^{n}i$=$\frac{n(n+1)}{2}$ $\frac{1}{n}$=$\frac{n+1}{2}$  </p><p>平均时间复杂度=O(n)</p></li></ul><h2 id="总结-1">2.5. 总结</h2><p><img src="/2020/02/07/数据结构-线性表/shunzong.png" alt></p><p><img src="/2020/02/07/数据结构-线性表/chazong.png" alt></p><p><img src="/2020/02/07/数据结构-线性表/shuncha.png" alt></p><h1 id="单链表">3. 单链表</h1><h2 id="什么是单链表">3.1. 什么是单链表</h2><p>逻辑结构：线性表 a<sub>1</sub> - a<sub>2</sub> - a<sub>3</sub> - a<sub>4</sub></p><table><thead><tr><th></th><th>顺序存储</th><th>链式存储</th></tr></thead><tbody><tr><td></td><td>顺序表 L-&gt;a<sub>1</sub> - a<sub>2</sub> - a<sub>3</sub> - a<sub>4</sub></td><td>单链表 L-&gt;a<sub>1</sub> -&gt; a<sub>2</sub> -&gt; a<sub>3</sub> -&gt; a<sub>4</sub></td></tr><tr><td>优点</td><td>可随机存取，存储密度高</td><td>不要求大片连续空间，改变容量方便</td></tr><tr><td>缺点</td><td>要求大片连续空间，改变容量不方便</td><td>不可随机存取，要耗费一定空间存放指针</td></tr><tr><td></td><td><img src="/2020/02/07/数据结构-线性表/shunxub.png" alt></td><td><img src="/2020/02/07/数据结构-线性表/danlianb.png" alt></td></tr></tbody></table><h2 id="代码定义单链表">3.2. 代码定义单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//数据域</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//指针域</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加一个新的结点:在内存中申请一个结点所需空间，并用指针p指向这个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> = (<span class="title">struct</span> <span class="title">LNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">LNode</span>));</span></span><br></pre></td></tr></table></figure><p>别名：typedef关键字  <code>typedef &lt;数据类型&gt; &lt;别名&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zhangsan;</span><br><span class="line">zhangsan x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,x); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>故重命名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  <span class="comment">//数据域</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//指针域</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode *p = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure><p>单链表定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p>要表示一个单链表时，只需声明一个头指针 L ，指向单链表的第一个结点<code>LNode *L</code>,<code>LinkList L</code></p><p><code>LNode *L</code> 强调返回的是一个结点</p><p>``LinkList L `强调是一个单链表</p><h2 id="单链表的实现">3.3. 单链表的实现</h2><h3 id="带头结点">3.3.1. 带头结点</h3><p>引入头结点：</p><ol><li>由于第一个数据点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理</li><li>无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到统一</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="comment">//头结点</span></span><br><span class="line">  L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="comment">//内存不足，分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LinkList L;</span><br><span class="line">  InitList(L);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存</p><p><img src="/2020/02/07/数据结构-线性表/tou.png" alt></p><h3 id="不带头结点">3.3.2. 不带头结点</h3><p>不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  L=<span class="literal">NULL</span>;<span class="comment">//防止脏数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LinkList L;</span><br><span class="line">  InitList(L);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存</p><p><img src="/2020/02/07/数据结构-线性表/notou.png" alt></p><h2 id="单链表基本操作">3.4. 单链表基本操作</h2><h3 id="插入">3.4.1. 插入</h3><h4 id="按位序插入-带头结点-O-n">3.4.1.1. 按位序插入(带头结点)-O(n)</h4><p><code>ListInsert(&amp;L,i,e)</code>:插入操作。在表L中的第i个位置上插入指定元素e. 找到第 i-1 个结点,将新结点插入其后</p><p>头结点可以看作 “第0个”结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//L指向头结点，头结点第0个结点(不存数据)</span></span><br><span class="line">  p=L;</span><br><span class="line">  <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i值不合法</span></span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  <span class="comment">//后插</span></span><br><span class="line">  s-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n)</strong></p><p>i=1时，p指向头结点</p><p><img src="/2020/02/07/数据结构-线性表/weicha.png" alt></p><p>i=5时,插在表尾</p><p><img src="/2020/02/07/数据结构-线性表/i=5.png" alt></p><p>如果 i = 6(i&gt;Lengh)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按位序插入-不带头结点-O-n">3.4.1.2. 按位序插入(不带头结点)-O(n)</h4><p>不存在 “第0个” 结点，因此i=1时，需要特殊处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">//初始化时L=NULL</span></span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//L指向第1个结点</span></span><br><span class="line">  p=L;</span><br><span class="line">  <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i值不合法</span></span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  <span class="comment">//后插</span></span><br><span class="line">  s-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i=1时，</p><p><img src="/2020/02/07/数据结构-线性表/i=1.png" alt></p><p>如果i &gt; 1，后续逻辑和带 头结点的一样</p><h4 id="指定结点的后插操作">3.4.1.3. 指定结点的后插操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="comment">//内存分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  s-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-线性表/houcha.png" alt></p><h4 id="指定结点的前插操作">3.4.1.4. 指定结点的前插操作</h4><ol><li><p>从头指针开始遍历，求p前插结点 – O(n)</p><p><code>bool InsertPriorNode(LinkList L,LNode *p,ElemType e)</code></p></li><li><p>p后插结点，交换两者数据 – O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="comment">//内存分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//s插到p后</span></span><br><span class="line">  s-&gt;next = p=&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="comment">//交换两者值</span></span><br><span class="line">  s-&gt;data = p-&gt;data;</span><br><span class="line">  p-&gt;data = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王道书版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p,LNode *s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="comment">//交换两者值</span></span><br><span class="line">  ElemType temp = p-&gt;data;</span><br><span class="line">  p-&gt;data = s-&gt;data;</span><br><span class="line">  s-&gt;data = temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除">3.4.2. 删除</h3><h4 id="按位序删除-带头结点-O-n">3.4.2.1. 按位序删除(带头结点)-O(n)</h4><p><code>ListDelete(&amp;L,i,&amp;e)</code>:删除操作。</p><p>删除表L中第i个位置的元素，并用e返回删除元素的值。</p><p>找到 i-1个结点，将其指针指向第i+1个结点，并释放第i个结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//L指向第1个结点</span></span><br><span class="line">  p=L;</span><br><span class="line">  <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i值不合法</span></span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第i-1结点后已无结点</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//q记录被删除结点</span></span><br><span class="line">  LNode *q = p-&gt;next;</span><br><span class="line">  <span class="comment">//e返回元素值</span></span><br><span class="line">  e = q-&gt;data;</span><br><span class="line">  <span class="comment">//q结点从链表中断开</span></span><br><span class="line">  p-&gt;next = q-&gt;next;</span><br><span class="line">  <span class="comment">//释放结点存储空间</span></span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏、平均时间复杂度：O(n)  最好时间复杂度：O(1)</p><h4 id="按位序删除-不带头结点">3.4.2.2. 按位序删除(不带头结点)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">    LNode *s = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">  p = L;</span><br><span class="line">  <span class="comment">//same</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定结点的删除">3.4.2.3. 指定结点的删除</h4><p><code>bool DeleteNode(LNodwe *p)</code>删除结点p，需要修改其前驱结点的next指针</p><ol><li><p>传入头指针，循环寻找p的前驱结点 </p></li><li><p>偷天换日-后插后交换值-O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//q指向p后继</span></span><br><span class="line">  LNode *q = p-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//交换p，q的值</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>单链表的局限性：无法逆向检索，有时候不太方便</p><h3 id="查找-1">3.4.3. 查找</h3><p><font color="#f00">本节只探讨“带头结点”的情况</font></p><h4 id="按位查找-O-n">3.4.3.1. 按位查找 -O(n)</h4><p><code>GetElem(L,i)</code>:按位查找操作。获取表L中第i个位置的元素的值。 平均时间复杂度:O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  p=L;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王道版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"> LNode *p = L-&gt;next;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按值查找-O-n-1">3.4.3.2. 按值查找 - O(n)</h4><p><code>LocateElem(L,e)</code>:按值查找操作。在表L中查找具有给定关键字值的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//从第1个结点开始查找数据</span></span><br><span class="line">  LNode *p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求表长-O-n">3.4.4. 求表长 - O(n)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  LNode *p = L;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立链表">3.4.5. 建立链表</h3><p>如果给你很多个数据元素(ElemType)，要把它们存到一个单链表里边，怎么做?</p><ol><li>初始化一个单链表</li><li>每次取一个数据元素，插入到表尾/表头</li></ol><p>头插法、尾插法：核心就是初始化操作、指定结点的后插操作</p><h4 id="尾插法">3.4.5.1. 尾插法</h4><p>初始化链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="comment">//头结点</span></span><br><span class="line">  L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="comment">//内存不足，分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LinkList L;</span><br><span class="line">  InitList(L);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法建立单链表：初始化单链表，设置变量 length 记录链表长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">While 循环 &#123; </span></span><br><span class="line"><span class="comment">  每次取一个数据元素 e;</span></span><br><span class="line"><span class="comment">  ListInsert (L, length+1, e) 插到尾部;</span></span><br><span class="line"><span class="comment">  length++; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入-每次都从头开始之后遍历，时间复杂度为O(n*n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//L指向头结点，头结点第0个结点(不存数据)</span></span><br><span class="line">  p=L;</span><br><span class="line">  <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i值不合法</span></span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  <span class="comment">//后插</span></span><br><span class="line">  s-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立尾指针，后插</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  LNode *s,*r;</span><br><span class="line">  r = L;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">999</span>)&#123;</span><br><span class="line">    s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r-&gt;next = s;</span><br><span class="line">    <span class="comment">//r指向新的表尾结点-永远保持r指向最后一个结点</span></span><br><span class="line">    r = s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头插法">3.4.5.2. 头插法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">While 循环 &#123; </span></span><br><span class="line"><span class="comment">每次取一个数据元素 e;</span></span><br><span class="line"><span class="comment">InsertNextNode (L, e);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="comment">//内存分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  s-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头插法-逆置链表数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆向建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123; </span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x; </span><br><span class="line">  <span class="comment">//创建头结点</span></span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); </span><br><span class="line">  <span class="comment">////初始为空链表</span></span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); </span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); </span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L-&gt;next;</span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆向建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123; </span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="keyword">int</span> x; </span><br><span class="line">  <span class="comment">//创建头结点</span></span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); </span><br><span class="line">  <span class="comment">////初始为空链表</span></span><br><span class="line">  L=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); </span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); </span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=L-&gt;next;</span><br><span class="line">    L=s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-s-t-之间的结点">3.4.5.3. 删除[s,t]之间的结点</h4><p>法一：从头扫描</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LNode *pre,*q,*p;</span><br><span class="line">pre = L;</span><br><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;data&gt;=s&amp;&amp;p-&gt;data&lt;=t)&#123;</span><br><span class="line">    q = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将pre的指针指向p的后继</span></span><br><span class="line">    pre-&gt;next = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    pre = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：用尾插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LNode *r,*q,*p;</span><br><span class="line">r = L;</span><br><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;data&lt;s||p-&gt;data&gt;t)&#123;</span><br><span class="line">    <span class="comment">//不满足条件的链接到L尾部</span></span><br><span class="line">    r-&gt;next = p; </span><br><span class="line">    r = p;</span><br><span class="line">    <span class="comment">//继续扫描</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    q = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="comment">//满足条件的释放其空间</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2">3.5. 总结</h2><p><img src="/2020/02/07/数据结构-线性表/lianzong.png" alt></p><p><img src="/2020/02/07/数据结构-线性表/dancha.png" alt></p><p><img src="/2020/02/07/数据结构-线性表/danzhao.png" alt></p><h1 id="双链表">4. 双链表</h1><p>单链表:无法逆向检索，有时候不太方便</p><p>双链表:可进可退，存储密度更低一丢丢</p><p><img src="/2020/02/07/数据结构-线性表/shuang.png" alt></p><h2 id="初始化">4.1. 初始化</h2><p>表头结点的 prior指向 NULL; 表尾结点的 next 指向 NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DlinkList &amp;L)</span></span>&#123;</span><br><span class="line">  L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">  L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">  l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  DLinkList L;</span><br><span class="line">  InitDLinkList(L);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-线性表/shuangtou.png" alt></p><h2 id="插入-1">4.2. 插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  s-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;prior = p;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除-1">4.3. 删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  DNode *q = p-&gt;next;</span><br><span class="line">  p-&gt;next = q-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除整个链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(L-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    DeleteNextNode(L);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(L);</span><br><span class="line">  L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历">4.4. 遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">  <span class="comment">//对结点p做相应处理，如打印 </span></span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前向遍历</span></span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">  <span class="comment">//对结点p做相应处理 </span></span><br><span class="line">  p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前向遍历(跳过头结 点)</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt; prior != <span class="literal">NULL</span>)&#123; </span><br><span class="line">  <span class="comment">//对结点p做相应处理 </span></span><br><span class="line">  p = p-&gt;prior; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现。时间复杂度 O(n)</p><h2 id="总结-3">4.5. 总结</h2><p><img src="/2020/02/07/数据结构-线性表/shuangzong.png" alt></p><h1 id="循环链表">5. 循环链表</h1><h2 id="循环单链表">5.1. 循环单链表</h2><p><img src="/2020/02/07/数据结构-线性表/xundan.png" alt><br><img src="/2020/02/07/数据结构-线性表/xunshuang.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===============初始化=================</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">  L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//头结点next指向头结点</span></span><br><span class="line">  L-&gt;next = L;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================判空==================</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L-&gt;next == L)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============判断结点p是否为循环单链表的表尾结点============</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L,LNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next == L)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-线性表/xundndai.png" alt></p><p>从头结点找到尾部，时间复杂度为O(n)</p><p>从尾部找到头部，时间复杂度为O(1)</p><p>很多时候对链表的操作都是在头部或尾部，可以让L指向表尾元素 (插入、删除时可能需要修改L)</p><h2 id="循环双链表">5.2. 循环双链表</h2><p><img src="/2020/02/07/数据结构-线性表/shuangdan.png" alt><br><img src="/2020/02/07/数据结构-线性表/shuangxun.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DlinkList;</span><br><span class="line"><span class="comment">//===============初始化====================</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DlinkList &amp;L)</span></span>&#123;</span><br><span class="line">  L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">  <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//头结点prior指向头结点</span></span><br><span class="line">  L-&gt;prior = L;</span><br><span class="line">  <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">  l-&gt;next = L;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================判空==================</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L-&gt;next == L)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============判断结点p是否为循环单链表的表尾结点============</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L,LNode *p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next == L)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/数据结构-线性表/emptyshuang.png" alt></p><h3 id="插入-2">5.2.1. 插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span></span>&#123;</span><br><span class="line">  <span class="comment">//s插入到p之后</span></span><br><span class="line">  s-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next-&gt;prior = s;</span><br><span class="line">  s-&gt;prior = p;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-2">5.2.2. 删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">  DNode *q = p-&gt;next;</span><br><span class="line">  p-&gt;next = q-&gt;next;</span><br><span class="line">  q-&gt;next-&gt;prior = p;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-4">5.3. 总结</h2><p><img src="/2020/02/07/数据结构-线性表/xunzong.png" alt></p><h1 id="静态链表">6. 静态链表</h1><h2 id="什么是静态链表">6.1. 什么是静态链表</h2><p>单链表：各个结点在内存中星罗棋布、散落天涯。</p><p>静态链表：分配一整片连续的内存空间，各个结点集中安置。用数组的方式实现的链表</p><p>初始化静态链表: 把a[0]的next设为-1，把其他结点的 next 设为一个特殊值用来表示结点空闲，如 -2</p><p><img src="/2020/02/07/数据结构-线性表/jing.png" alt></p><p>每个数据元素4B，每个游标4B(每个结点共 8B) 设起始地址为 addr，e1的存放地址为 addr + 8*2</p><h2 id="用代码定义一个静态链表">6.2. 用代码定义一个静态链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="comment">//数据元素</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="comment">//下一个元素数组下标</span></span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可用SLinkList定义一个长度为MaxSize的Node型数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//数组a作为静态链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王道</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SLinkList a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SLinkList a ——相当于定义了一个长度为 MaxSize 的 Node型数组</p><h2 id="基本操作">6.3. 基本操作</h2><h3 id="查找-2">6.3.1. 查找</h3><p>从头结点出发挨个往后遍历结点</p><h3 id="插入位序为-i-的结点">6.3.2. 插入位序为 i 的结点</h3><ol><li>找到一个空的结点，存入数据元素 </li><li>从头结点出发找到位序为 i-1 的结点 </li><li>修改新结点的 next</li><li>修改 i-1 号结点的 next</li></ol><h3 id="删除某个结点">6.3.3. 删除某个结点</h3><ol><li>从头结点出发找到前驱结点 </li><li>修改前驱结点的游标 </li><li>被删除结点 next 设为 -2</li></ol><h2 id="总结-5">6.4. 总结</h2><p>优点：增、删 操作不需要大量移动元素 </p><p>缺点：不能随机存取，只能从头结点开始依次往后查 找;容量固定不可变</p><p>适用场景:</p><ol><li>不支持指针的低级语言;</li><li>数据元素数量固定不变的场景(如操作系统的文件分配表FAT)</li></ol><h1 id="顺序表-V-S-链表">7. 顺序表 V.S.链表</h1><h2 id="逻辑结构">7.1. 逻辑结构</h2><p>都属于线性表，都是线性结构</p><h2 id="物理结构">7.2. 物理结构</h2><p>顺序表是顺序存储，链表是链式存储</p><table><thead><tr><th></th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td>优点</td><td>支持随机存取、存储密度高</td><td>离散的小空间分配方便，改变容量方便</td></tr><tr><td>缺点</td><td>大片连续空间分配不方便，改变容量不方便</td><td>不可随机存取，存储密度低</td></tr></tbody></table><h2 id="数据的运算-创销增删改查">7.3. 数据的运算-创销增删改查</h2><table><thead><tr><th></th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td>创</td><td>需要预分配大片连续空间。 若分配空间过小，则之后不方便拓展容量;若分配空间过大，则浪费内存资源<br>静态分配：静态数组 - 容量不可变<br>动态分配：动态数组(malloc、free) - 容量可变，扩容时间代价高</td><td>只需分配一个头结点(也可以不要头结点，只声明一个头指针)，之后方便拓展</td></tr><tr><td>销</td><td>修改 L.length = 0<br>静态分配：静态数组 - 系统自动回收空间<br>动态分配：动态数组(malloc、free) - 手动free</td><td>依次删除各个 结点(free)</td></tr><tr><td>增删</td><td>插入/删除元素要将后续元素都后移/前移<br>时间复杂度 O(n)，时间开销主要来自移动元素<br>若数据元素很大，则移动的时间代价很高</td><td>插入/删除元素只需修改指针即可<br>时间复杂度 O(n)，时间开销主要来自查找目标元素<br>查找元素的时间代价更低</td></tr><tr><td>查</td><td>按位查找:O(1)<br>按值查找:O(n) 若表内元素有序，可在 O(log2n) 时间内找到</td><td>按位查找:O(n)<br>按值查找:O(n)</td></tr><tr><td>弹性(可扩容)</td><td>静态不可扩容，动态可扩容</td><td>可扩容</td></tr></tbody></table><p>表长难以预估、经常要增加/删除元素 ——链表 </p><p>表长可预估、查询(搜索)操作较多 ——顺序表</p><h2 id="如何抉择">7.4. 如何抉择</h2><p>请描述顺序表和链表的… 实现线性表时，用顺序表还是链表好?</p><p>顺序表和链表的逻辑结构都是线性结构，都属于线性表。 但是二者的存储结构不同，顺序表采用顺序存储…(特点，带来的优点缺点)；链表采用链式存储…(特点、导致的优缺点)。 </p><p>由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…;当插入一个数据元素时…;当删除一个数据元素时…;当查找一个数据元素时…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;顺序表，单链表，双链表，循环链式，静态链表&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
