
<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Arial:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "4767878b"
    });
  daovoice('update');
  </script>



<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"falt"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
  (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://www.runaccpeted.com"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>
  <meta name="description" content="Lambda表达式，函数式接口，方法引用与构造器引用，Stream API，Optional类">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识-Java8新特性">
<meta property="og:url" content="https://www.runaccepted.com/2019/09/20/Java基础知识-Java8新特性/index.html">
<meta property="og:site_name" content="W.T.的博客">
<meta property="og:description" content="Lambda表达式，函数式接口，方法引用与构造器引用，Stream API，Optional类">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-01-30T20:12:04.849Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java基础知识-Java8新特性">
<meta name="twitter:description" content="Lambda表达式，函数式接口，方法引用与构造器引用，Stream API，Optional类">
  <link rel="alternate" href="/atom.xml" title="W.T.的博客" type="application/atom+xml">
  <link rel="canonical" href="https://www.runaccepted.com/2019/09/20/Java基础知识-Java8新特性/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>


  <title>Java基础知识-Java8新特性 | W.T.的博客</title>
  <meta name="generator" content="Hexo 3.9.0">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?59cd4bc54e9d484dff9357727e454c80";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container">
    <div class="headband"></div>
    <!-- github -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">W.T.的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Every day to be a little better</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">32</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">13</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">305</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-schedule">
      
    
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-sitemap">
      
    
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-commonweal">
      
    
      
    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a class="book-mark-link book-mark-link-fixed" href="#"></a>

  <a href="https://github.com/helloworld1006" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://www.runaccepted.com/2019/09/20/Java基础知识-Java8新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Ting">
      <meta itemprop="description" content="技术成长笔记">
      <meta itemprop="image" content="/images/a.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="W.T.的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java基础知识-Java8新特性

          
        </h1>

        <div class="post-meta">

           
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-20 14:52:05" itemprop="dateCreated datePublished" datetime="2019-09-20T14:52:05+08:00">2019-09-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-31 04:12:04" itemprop="dateModified" datetime="2021-01-31T04:12:04+08:00">2021-01-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/09/20/Java基础知识-Java8新特性/" class="post-meta-item leancloud_visitors" data-flag-title="Java基础知识-Java8新特性" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
              <span>℃</span>
            </span>
          
           
           <!--
            <span class="post-meta-item" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
          -->
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">评论：</span>
    
    <a title="valine" href="/2019/09/20/Java基础知识-Java8新特性/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/09/20/Java基础知识-Java8新特性/" itemprop="commentCount"></span></a>
  </span>
  
  
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>13k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>22 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote class="blockquote-center">Lambda表达式，函数式接口，方法引用与构造器引用，Stream API，Optional类</blockquote>

<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><font size="4px">介绍</font></h1><p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本</p>
<p>Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以 来最具革命性的版本。Java 8为Java语言、编译器、类库、开发 工具与JVM带来了大量新特性</p>
<ul>
<li><p>速度更快</p>
</li>
<li><p>代码更少(增加了新的语法：Lambda 表达式) </p>
</li>
<li><p>强大的 Stream API：</p>
<p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率</p>
<p>parallel() 与 sequential() 在并行流与顺序流之间进行切换</p>
</li>
<li><p>便于并行</p>
</li>
<li><p>最大化减少空指针异常：Optional</p>
</li>
<li><p>Nashorn引擎，允许在JVM上运行JS应用</p>
</li>
</ul>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><font size="4px">Lambda表达式</font></h1><p>Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<p>在Java 8中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分:</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表 </li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li>
</ul>
<h2 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a><font size="3px">Lambda语法</font></h2><ol>
<li><p>无参，无返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable ri = ()-&gt;&#123;System.out.println(<span class="string">"Hello Lambda!"</span>);&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个参数，但是没有返回值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (String str)-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>数据类型可以省略 - 类型推断</p>
<p> Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“<font color="#f00">类型推断</font>”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (str)-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要一个参数时，参数的小括号可以省略</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = str-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要两个或以上的参数，多条执行语句，并且可以有返回值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;&#123;</span><br><span class="line">   System.out.println(<span class="string">"实现函数式接口方法!"</span>);</span><br><span class="line">   <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>体只有一条语句时，return 与大括号若有，都可以省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;Integer.compare(x,y);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Lambda的延迟执行"><a href="#Lambda的延迟执行" class="headerlink" title="Lambda的延迟执行"></a><font size="3px">Lambda的延迟执行</font></h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 作为解决方案，提升性能。</p>
<h4 id="性能浪费的日志案例"><a href="#性能浪费的日志案例" class="headerlink" title="性能浪费的日志案例"></a><font size="3px">性能浪费的日志案例</font></h4><p>日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Logger</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String msg)</span> </span>&#123;</span><br><span class="line">					<span class="keyword">if</span> (level == <span class="number">1</span>) &#123; </span><br><span class="line">            System.out.println(msg);</span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">        String msgB = <span class="string">"World"</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line">        log(<span class="number">1</span>, msgA + msgB + msgC);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码存在问题:无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p>
<blockquote>
<p>SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。</p>
<p>如: LOGGER.debug(“变量{}的取值为{}。”, “os”, “macOS”) ，其中的大括号 {} 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置;否则不会进行字 符串拼接。这也是一种可行解决方案，但Lambda可以做到更好</p>
</blockquote>
<p>使用Lambda必然需要一个函数式接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">buildMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后对 log 方法进行改造:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LoggerLambda</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123; </span><br><span class="line">          System.out.println(builder.buildMessage());</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">        String msgB = <span class="string">"World"</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line">        log(<span class="number">1</span>, () ‐&gt; msgA + msgB + msgC ); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p>
<p>证明Lambda的延迟 下面的代码可以通过结果进行验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03LoggerDelay</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (level == <span class="number">1</span>) &#123; </span><br><span class="line">            System.out.println(builder.buildMessage());</span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">        String msgB = <span class="string">"World"</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line">        log(<span class="number">2</span>, () ‐&gt; &#123; </span><br><span class="line">          System.out.println(<span class="string">"Lambda执行!"</span>); <span class="keyword">return</span> msgA + msgB + msgC;</span><br><span class="line">        &#125;); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 </p>
<blockquote>
<p>实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的</p>
</blockquote>
<h2 id="使用Lambda作为参数和返回值"><a href="#使用Lambda作为参数和返回值" class="headerlink" title="使用Lambda作为参数和返回值"></a><font size="3px">使用Lambda作为参数和返回值</font></h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</p>
<p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(task).start(); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   startThread(() ‐&gt; System.out.println(<span class="string">"线程任务执行!"</span>));</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays; </span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">newComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (a, b) ‐&gt; b.length() ‐ a.length(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">      String[] array = &#123; <span class="string">"abc"</span>, <span class="string">"ab"</span>, <span class="string">"abcd"</span> &#125;; </span><br><span class="line">      System.out.println(Arrays.toString(array)); </span><br><span class="line">      Arrays.sort(array, newComparator()); </span><br><span class="line">      System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中直接return一个Lambda表达式即可。</p>
<h1 id="函数式接口概念"><a href="#函数式接口概念" class="headerlink" title="函数式接口概念"></a><font size="4px">函数式接口概念</font></h1><h2 id="如何理解函数式接口"><a href="#如何理解函数式接口" class="headerlink" title=" 如何理解函数式接口"></a><font size="3px"> 如何理解函数式接口</font></h2><ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP) 编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不 得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还 可以支持OOF(面向函数编程)</li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的 编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——函数式接口。</li>
<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示。</li>
<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li>
</ul>
<h2 id="什么是函数式-Functional-接口"><a href="#什么是函数式-Functional-接口" class="headerlink" title=" 什么是函数式(Functional)接口"></a><font size="3px"> 什么是函数式(Functional)接口</font></h2><p>函数式接口 : 有且仅有一个抽象方法的接口。 </p>
<blockquote>
<p>即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda</p>
</blockquote>
<p>语法糖</p>
<blockquote>
<p>指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<p>只要确保接口中有且仅有一个抽象方法即可</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">	<span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于接口当中抽象方法的 public abstract 是可以省略的，</p>
<p>所以定义一个函数式接口很简单</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a><font size="3px">@FunctionalInterface注解</font></h2><p> 与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解: @FunctionalInterface 。该注</p>
<p>解可用于一个接口的定义上:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a><font size="3px">常用函数式接口</font></h2><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的几个接口及使用示例。</p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a><font size="3px">核心接口</font></h3><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer&lt; T&gt;  消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象应用操作,方法:void accpet(T t)</td>
</tr>
<tr>
<td>Supplier&lt; T&gt; 供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象,方法: T get()</td>
</tr>
<tr>
<td>Function&lt; T,R&gt; 函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。方法：R apply(T t)</td>
</tr>
<tr>
<td>Predicate&lt; T&gt; 断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回boolean值。方法：boolean test(T t)</td>
</tr>
</tbody></table>
<h3 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a><font size="3px">其他接口</font></h3><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>T, U</td>
<td>R</td>
<td>对类型为T, U参数应用操作，返回R类型的结果。有方法: R apply(T t, U u);</td>
</tr>
<tr>
<td>UnaryOperator&lt; T&gt;(Function子接口)</td>
<td>T</td>
<td>T</td>
<td>对类型为T的对象进行一元运算，并返回T类型的结果。有方法: T apply(T t);</td>
</tr>
<tr>
<td>BinaryOperator&lt; T&gt; (BiFunction 子接口)</td>
<td>T, T</td>
<td>T</td>
<td>对类型为T的对象进行二元运算，并返回T类型的结果。有方法: T apply(T t1, T t2);</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>T, U</td>
<td>void</td>
<td>对类型为T, U参数应用操作。 有方法: void accept(T t, U u)</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>有方法: boolean test(T t,U u)</td>
</tr>
<tr>
<td>ToIntFunction&lt; T&gt;，ToLongFunction&lt; T&gt;，ToDoubleFunction&lt; T&gt;</td>
<td>T</td>
<td>int，long double</td>
<td>分别计算int、long、double值的函数</td>
</tr>
<tr>
<td>IntFunction&lt; R&gt;，LongFunction&lt; R&gt;，DoubleFunction&lt; R&gt;</td>
<td>int，long double</td>
<td>R</td>
<td>参数分别为int、long、double 类型的函数</td>
</tr>
</tbody></table>
<h3 id="Supplier接口-T-get"><a href="#Supplier接口-T-get" class="headerlink" title="Supplier接口 - T get()"></a><font size="3px">Supplier接口 - T get()</font></h3><p><code>java.util.function.Supplier&lt;T&gt;</code> 接口仅包含一个无参的方法: <code>T get()</code> 。</p>
<p>用来获取一个泛型参数指定类型的对 象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象 数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08Supplier</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; function)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> function.get(); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">    String msgB = <span class="string">"World"</span>; </span><br><span class="line">    System.out.println(getString(() ‐&gt; msgA + msgB));</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求数组元素最大值"><a href="#求数组元素最大值" class="headerlink" title="求数组元素最大值"></a><font size="3px">求数组元素最大值</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Test</span> </span>&#123; </span><br><span class="line">    <span class="comment">//定一个方法,方法的参数传递Supplier,泛型使用Integer </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sup.get(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">      <span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">333</span>,<span class="number">23</span>&#125;;</span><br><span class="line">			<span class="comment">//调用getMax方法,参数传递Lambda </span></span><br><span class="line">      <span class="keyword">int</span> maxNum = getMax(()‐&gt;&#123;</span><br><span class="line">      <span class="comment">//计算数组的最大值 </span></span><br><span class="line">          <span class="keyword">int</span> max = arr[<span class="number">0</span>]; </span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">      			<span class="keyword">if</span>(i&gt;max)&#123; </span><br><span class="line">        			max = i;</span><br><span class="line">      			&#125; </span><br><span class="line">          &#125;    </span><br><span class="line">    			<span class="keyword">return</span> max;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">			System.out.println(maxNum); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a><font size="3px">Consumer接口</font></h3><p> <code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。                                 </p>
<h4 id="void-accept-T-t"><a href="#void-accept-T-t" class="headerlink" title="void accept(T t)"></a><font size="3px">void accept(T t)</font></h4><p>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。</p>
<p>基本使用如:                                 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09Consumer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeString</span><span class="params">(Consumer&lt;String&gt; function)</span> </span>&#123; </span><br><span class="line">     function.accept(<span class="string">"Hello"</span>); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     consumeString(s ‐&gt; System.out.println(s)); 								</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，更好的写法是使用方法引用。 </p>
<h4 id="Consumer-andThen-Consumer"><a href="#Consumer-andThen-Consumer" class="headerlink" title="Consumer andThen(Consumer)"></a><font size="3px">Consumer andThen(Consumer)</font></h4><p>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果:消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法 andThen 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123; </span><br><span class="line">  Objects.requireNonNull(after);  </span><br><span class="line">  <span class="keyword">return</span> (T t) ‐&gt; &#123; </span><br><span class="line">    accept(t); </span><br><span class="line">    after.accept(t); </span><br><span class="line">  &#125;; 								</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java.util.Objects 的 requireNonNull 静态方法将会在参数为null时主动抛出 NullPointerException 异常。这省去了重复编写if语句和抛出空指针异常的麻烦。                                 </p>
</blockquote>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而 andThen 的语义正是“一步接一步”操作。</p>
<p>例如两个步骤组 合的情况:         </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer; 								</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10ConsumerAndThen</span> </span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeString</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> </span>&#123; 							one.andThen(two).accept(<span class="string">"Hello"</span>); </span><br><span class="line">    &#125; 								</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;           </span><br><span class="line">          consumeString(</span><br><span class="line">              s ‐&gt; System.out.println(s.toUpperCase()), </span><br><span class="line">              s ‐&gt; System.out.println(s.toLowerCase()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的 组合。</p>
<h4 id="格式化打印信息"><a href="#格式化打印信息" class="headerlink" title="格式化打印信息"></a><font size="3px">格式化打印信息</font></h4><p>下面的字符串数组当中存有多条信息，请按照格式“ 姓名:XX。性别:XX。 ”的格式将信息打印出来。要求将打印姓 名的动作作为第一个 Consumer 接口的Lambda实例，将打印性别的动作作为第二个 Consumer 接口的Lambda实 例，将两个 Consumer 接口按照顺序“拼接”到一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConsumer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span> &#125;; </span><br><span class="line">       printInfo(</span><br><span class="line">         s ‐&gt; System.out.print(<span class="string">"姓名:"</span> + s.split(<span class="string">","</span>)[<span class="number">0</span>]),</span><br><span class="line">         s ‐&gt; System.out.println(<span class="string">"。性别:"</span> + s.split(<span class="string">","</span>)[<span class="number">1</span>] + <span class="string">"。"</span>), </span><br><span class="line">         array);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(Consumer&lt;String&gt; one, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   Consumer&lt;String&gt; two, String[] array)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (String info : array) &#123;</span><br><span class="line">             one.andThen(two).accept(info); <span class="comment">// 姓名:迪丽热巴。性别:女。 </span></span><br><span class="line">           &#125;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a><font size="3px">Predicate接口</font></h3><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用</p>
<p><code>java.util.function.Predicate&lt;T&gt;</code> 接口。</p>
<h4 id="boolean-test-T-t"><a href="#boolean-test-T-t" class="headerlink" title="boolean test(T t)"></a><font size="3px">boolean test(T t)</font></h4><p>用于条件判断的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo15PredicateTest</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">boolean</span> veryLong = predicate.test(<span class="string">"HelloWorld"</span>);</span><br><span class="line">         System.out.println(<span class="string">"字符串很长吗:"</span> + veryLong); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         method(s ‐&gt; s.length() &gt; <span class="number">5</span>);</span><br><span class="line">       &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。 </p>
<h4 id="Predicate-and-Predicate"><a href="#Predicate-and-Predicate" class="headerlink" title="Predicate and(Predicate)"></a><font size="3px">Predicate and(Predicate)</font></h4><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实 现“并且”的效果时，可以使用default方法 and</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123; </span><br><span class="line">  Objects.requireNonNull(other);</span><br><span class="line">  <span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要判断一个字符串既要包含大写“H”，又要包含大写“W”，那么: import java.util.function.Predicate;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16PredicateAnd</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> isValid = one.and(two).test(<span class="string">"Helloworld"</span>);</span><br><span class="line">       System.out.println(<span class="string">"字符串符合要求吗:"</span> + isValid); </span><br><span class="line">     &#125;</span><br><span class="line">  	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 				method(s ‐&gt; s.contains(<span class="string">"H"</span>), s ‐&gt; s.contains(<span class="string">"W"</span>));</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate-or-Predicate-“或”"><a href="#Predicate-or-Predicate-“或”" class="headerlink" title="Predicate or(Predicate)“或”"></a><font size="3px">Predicate or(Predicate)“或”</font></h4><p>or 实现逻辑关系中的“或”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123; </span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16PredicateAnd</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class="line">         	<span class="keyword">boolean</span> isValid = one.or(two).test(<span class="string">"Helloworld"</span>);</span><br><span class="line">					System.out.println(<span class="string">"字符串符合要求吗:"</span> + isValid); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       method(s ‐&gt; s.contains(<span class="string">"H"</span>), s ‐&gt; s.contains(<span class="string">"W"</span>));</span><br><span class="line"></span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate-negate-Predicate-“非”"><a href="#Predicate-negate-Predicate-“非”" class="headerlink" title="Predicate negate(Predicate)“非”"></a><font size="3px">Predicate negate(Predicate)“非”</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现中很容易看出，它是执行了test方法之后，对结果boolean值进行“!”取反而已。一定要在 test 方法调用之前</p>
<p>调用 negate 方法，正如 and 和 or 方法一样: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo17PredicateNegate</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class="line">         	<span class="keyword">boolean</span> veryLong = predicate.negate().test(<span class="string">"HelloWorld"</span>);</span><br><span class="line">					System.out.println(<span class="string">"字符串很长吗:"</span> + veryLong); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; method(s ‐&gt; s.length() &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合信息筛选"><a href="#集合信息筛选" class="headerlink" title="集合信息筛选"></a><font size="3px">集合信息筛选</font></h4><p>数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中，需要同时满足两个条件:    1. 必须为女生; 2. 姓名为4个字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicate</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span>, <span class="string">"赵丽颖,女"</span> &#125;; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicate</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       	String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span>, <span class="string">"赵丽颖,女"</span> &#125;;</span><br><span class="line">         List&lt;String&gt; list = filter(array,</span><br><span class="line">            s ‐&gt; <span class="string">"女"</span>.equals(s.split(<span class="string">","</span>)[<span class="number">1</span>]),s ‐&gt; s.split(<span class="string">","</span>)[<span class="number">0</span>].length() == <span class="number">4</span>);</span><br><span class="line">         System.out.println(list); </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(String[] array, Predicate&lt;String&gt; one,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="keyword">for</span> (String info : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (one.and(two).test(info)) &#123; </span><br><span class="line">              list.add(info);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a><font size="3px">Function接口</font></h3><p> <code>java.util.function.Function&lt;T,R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件</p>
<h4 id="R-apply-T-t"><a href="#R-apply-T-t" class="headerlink" title="R apply(T t)"></a><font size="3px">R apply(T t)</font></h4><p>根据类型T的参数获取类型R的结果。 使用的场景例如:将 String 类型转换为 Integer 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11FunctionApply</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Function&lt;String, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">         	<span class="keyword">int</span> num = function.apply(<span class="string">"10"</span>);</span><br><span class="line">					System.out.println(num + <span class="number">20</span>); </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">          method(s ‐&gt; Integer.parseInt(s));</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，最好是通过方法引用的写法。</p>
<h4 id="Function-andThen-Function"><a href="#Function-andThen-Function" class="headerlink" title="Function andThen(Function)"></a><font size="3px">Function andThen(Function)</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">  	Objects.requireNonNull(after);</span><br><span class="line">		<span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法同样用于“先做什么，再做什么”的场景，和 Consumer 中的 andThen 差不多:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12FunctionAndThen</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Function&lt;String, Integer&gt; one, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Function&lt;Integer, Integer&gt; two)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> num = one.andThen(two).apply(<span class="string">"10"</span>);</span><br><span class="line">         System.out.println(num + <span class="number">20</span>); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">          method(str‐&gt;Integer.parseInt(str)+<span class="number">10</span>, i ‐&gt; i *= <span class="number">10</span>);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p>
<blockquote>
<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>
</blockquote>
<h4 id="自定义函数模型拼接"><a href="#自定义函数模型拼接" class="headerlink" title="自定义函数模型拼接"></a><font size="3px">自定义函数模型拼接</font></h4><p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为: String str = “赵丽颖,20”;</p>
<ol>
<li>将字符串截取数字年龄部分，得到字符串;</li>
<li>将上一步的字符串转换成为int类型的数字;</li>
<li>将上一步的int数字累加100，得到结果int数字。</li>
</ol>
<p>解答</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoFunction</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         String str = <span class="string">"赵丽颖,20"</span>;</span><br><span class="line">         <span class="keyword">int</span> age = getAgeNum(str,s ‐&gt; s.split(<span class="string">","</span>)[<span class="number">1</span>],</span><br><span class="line">                             s ‐&gt;Integer.parseInt(s),</span><br><span class="line">                             n ‐&gt; n += <span class="number">100</span>); System.out.println(age);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAgeNum</span><span class="params">(String str, Function&lt;String, String&gt; one,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Function&lt;String, Integer&gt; two,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Function&lt;Integer, Integer&gt; three)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> one.andThen(two).andThen(three).apply(str);</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a><font size="4px">方法引用与构造器引用</font></h1><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a><font size="3px">方法引用</font></h2><ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li>
<li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向 一个方法，可以认为是Lambda表达式的一个语法糖。</li>
<li>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致</li>
<li>格式:使用操作符 “<font color="#f00">::</font>” 将类(或对象) 与 方法名分隔开来。</li>
<li>如下三种主要使用情况:<ul>
<li>对象::实例方法名 </li>
<li>类::静态方法名 </li>
<li>类::实例方法名</li>
</ul>
</li>
</ul>
<h3 id="类-实例方法名"><a href="#类-实例方法名" class="headerlink" title="类::实例方法名"></a><font size="3px">类::实例方法名</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;Integer.compare(x,y);</span><br><span class="line"><span class="keyword">int</span> value = com.compare(<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line">System.out.println(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========等价于===========</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">value = com.compare(<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>

<p>当函数式接口方法的第一个参数是需要引用方法的调用者，且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiPredicate&lt;String,String&gt; bp = (x,y)-&gt;x.equals(y);</span><br><span class="line">    <span class="keyword">boolean</span> test = bp.test(<span class="string">"abc"</span>, <span class="string">"abb"</span>);</span><br><span class="line">   <span class="comment">//false</span></span><br><span class="line">    System.out.println(test);</span><br><span class="line"></span><br><span class="line">    bp = String::equals;</span><br><span class="line">    <span class="keyword">boolean</span> test1 = bp.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>);</span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    System.out.println(test1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造器引用-class-new"><a href="#构造器引用-class-new" class="headerlink" title="构造器引用 class::new"></a><font size="3px">构造器引用 class::new</font></h2><p>与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象 方法的参数列表一致，且方法的返回值即为构造器对应类的对象。</p>
<p><code>n-&gt;new MyClass(n)</code>-&gt;<code>MyClass::new</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">getClass</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MyInterface my = n-&gt;<span class="keyword">new</span> MyClass(n);</span><br><span class="line">    MyClass myClass = my.getClass(<span class="string">"AAA"</span>);</span><br><span class="line">    <span class="comment">//AAA</span></span><br><span class="line">    System.out.println(myClass.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    my = MyClass::<span class="keyword">new</span>;</span><br><span class="line">    MyClass abc = my.getClass(<span class="string">"ABC"</span>);</span><br><span class="line">    <span class="comment">//ABC</span></span><br><span class="line">    System.out.println(abc.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组引用-type-new"><a href="#数组引用-type-new" class="headerlink" title="数组引用 type[]::new"></a><font size="3px">数组引用 type[]::new</font></h2><p><code>n-&gt;new Integer[n]</code> -&gt; <code>Integer[]::new</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    Integer[] getInteger(<span class="keyword">int</span> n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer[] Method(<span class="keyword">int</span> n,MyInterface face)&#123;</span><br><span class="line">    <span class="keyword">return</span> face.getInteger(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer[] integers = Method(<span class="number">10</span>,n-&gt;<span class="keyword">new</span> Integer[n]);</span><br><span class="line">    <span class="comment">//10</span></span><br><span class="line">    System.out.println(integers.length);</span><br><span class="line"></span><br><span class="line">    integers = Method(<span class="number">20</span>,Integer[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="comment">//20</span></span><br><span class="line">    System.out.println(integers.length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><font size="4px">Stream</font></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font size="3px">定义</font></h2><p>Stream(流)是一个来自数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是<font color="#f00">按需计算</font>。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组 等</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征:</p>
<ul>
<li><p><strong>Pipelining</strong></p>
<p>中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格(fluent style)。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p>
</li>
<li><p><strong>内部迭代</strong></p>
<p>以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</p>
</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤:</p>
<ol>
<li><p>获取一个数据源(source)</p>
</li>
<li><p>数据转换</p>
</li>
<li><p>执行操作获取想要的结果</p>
</li>
</ol>
<p>每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象(可以有多次转换)，这就允许对其操作可以 像链条一样排列，变成一个管道。</p>
<p><font color="#f00">注意:</font></p>
<p><font color="#f00">1. Stream 自己不会存储元素。</font><br><font color="#f00">2. Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</font><br><font color="#f00">3. Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</font></p>
<h2 id="获取Stream方法"><a href="#获取Stream方法" class="headerlink" title="获取Stream方法"></a><font size="3px">获取Stream方法</font></h2><h3 id="通过集合Collection-stream"><a href="#通过集合Collection-stream" class="headerlink" title="通过集合Collection.stream()"></a><font size="3px">通过集合Collection.stream()</font></h3><ul>
<li><code>default Stream&lt;E&gt; stream()</code>: 返回一个顺序流</li>
<li><code>default Stream&lt;E&gt; parallelStream()</code>: 返回一个并行流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"BA"</span>);</span><br><span class="line">list.add(<span class="string">"AB"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//BA</span></span><br><span class="line">list.stream().filter((name)-&gt;name.endsWith(<span class="string">"A"</span>)).forEach((i)-&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>

<h3 id="通过数组Arrays-stream-T"><a href="#通过数组Arrays-stream-T" class="headerlink" title="通过数组Arrays.stream(T[])"></a><font size="3px">通过数组Arrays.stream(T[])</font></h3><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流: </p>
<p><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code>: 返回一个流</p>
<p>重载形式，能够处理对应基本类型的数组:</p>
<ul>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    stream.filter(i-&gt;i&gt;<span class="number">4</span>).forEach(i-&gt; System.out.println(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过Stream的of"><a href="#通过Stream的of" class="headerlink" title="通过Stream的of()"></a><font size="3px">通过Stream的of()</font></h3><p>可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。</p>
<p><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values)</code> : 返回一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s=Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">s.filter((i)-&gt;i&gt;<span class="number">2</span>).forEach((i)-&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>

<h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a><font size="3px">创建无限流</font></h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<ul>
<li>迭代<br> <code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li>
<li>生成<br> <code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">    stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">    Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">    stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a><font size="3px">Stream 的中间操作</font></h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a><font size="3px">筛选与切片</font></h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>接收 Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一 个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a><font size="3px">映射</font></h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    IntStream stream = Arrays.stream(arr);</span><br><span class="line">    stream.map(i-&gt;i+<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a><font size="3px">排序</font></h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<h2 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a><font size="3px">Stream 的终止操作</font></h2><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如:List、Integer，甚至是 void 。</p>
<p>流进行了终止操作后，不能再次使用。</p>
<h3 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a><font size="3px">匹配与查找</font></h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素 `</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代 称为外部迭代。相反，Stream API 使用内部迭 代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a><font size="3px">归约</font></h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reduce(T iden, BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一 个值。返回 T</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一 个值。返回 Optional&lt; T&gt;</td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a><font size="3px">收集</font></h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>collect(Collector c)</td>
<td>将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总 的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map)。</p>
<p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表:</p>
<h4 id="Collectors-实用类静态方法"><a href="#Collectors-实用类静态方法" class="headerlink" title="Collectors 实用类静态方法"></a><font size="3px">Collectors 实用类静态方法</font></h4><table>     
  <tr bgcolor="#905a3d">         
    <td>方法</td>          
    <td>返回类型</td>   
    <td>作用</td> 
  </tr>     
  <tr>         
    <td>toList</td>             
    <td>List&lt;T&gt;</td>   
    <td>把流中元素收集到List</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</td>       
  </tr> 
  <tr>         
    <td>toSet</td>             
    <td>Set&lt;T&gt;</td>   
    <td>把流中元素收集到Set</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</td>       
  </tr> 
  <tr>         
    <td>toCollection</td>             
    <td>Collection&lt;T&gt;</td>   
    <td>把流中元素收集到创建的集合</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">Collection&lt;Employee&gt; emps= list.stream().collect(Collectors.toCollection(ArrayList::new));</td>       
  </tr> 
  <tr>         
    <td>counting</td>             
    <td>Long</td>   
    <td>计算流中元素的个数</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">long count = list.stream().collect(Collectors.counting());</td>       
  </tr> 
  <tr>         
    <td>summingInt</td>             
    <td>Integer</td>   
    <td>对流中元素的整数属性求和</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>       
  </tr> 
  <tr>         
    <td>averagingInt</td>             
    <td>Double</td>   
    <td>计算流中元素Integer属性的平均值</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>       
  </tr> 
  <tr>         
    <td>summarizingInt</td>             
    <td>IntSummaryStatistics</td>   
    <td>收集流中Integer属性的统计值。如:平均值</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>       
  </tr> 
  <tr>         
    <td>joining</td>             
    <td>String</td>   
    <td>连接流中每个字符串</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td>       
  </tr> 
  <tr>         
    <td>maxBy</td>             
    <td>Optional&lt;T&gt;</td>   
    <td>根据比较器选择最大值</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">Optional<emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</emp></td>       
  </tr> 
  <tr>         
    <td>minBy</td>             
    <td>Optional&lt;T&gt;</td>   
    <td>根据比较器选择最小值</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">Optional<emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</emp></td>       
  </tr> 
  <tr>         
    <td>reducing</td>             
    <td>归约产生的类型</td>   
    <td>从一个作为累加器的初始值开始,利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td>       
  </tr> 
  <tr>         
    <td>collectingAndThen</td>             
    <td>转换函数返回的类型</td>   
    <td>包裹另一个收集器，对其结果转 换函数</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>       
  </tr> 
  <tr>         
    <td>groupingBy</td>             
    <td>Map&lt;K, List&lt;T&gt;&gt;</td>   
    <td>根据某属性值对流分组，属性为K 结果为V</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</td>       
  </tr> 
  <tr>         
    <td>partitioningBy</td>             
    <td>Map&lt;Boolean, List&lt;T&gt;&gt;</td>   
    <td>根据true或false进行分区</td>
  </tr>     
  <tr>         
    <td colspan="3" bgcolor="#fedcbd">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</td>       
  </tr> 
</table>

<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a><font size="4px">Optional类</font></h1><ul>
<li>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。 以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类， Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代 码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</li>
<li><code>Optional&lt;T&gt;</code> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</li>
<li>Optional类的Javadoc描述如下:这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><font size="3px">常用方法</font></h2><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<ul>
<li><p>创建Optional类对象的方法:</p>
<ul>
<li>Optional.of(T t) : 创建一个 Optional 实例，t必须非空; </li>
<li>Optional.empty() : 创建一个空的 Optional 实例</li>
<li>Optional.ofNullable(T t)：t可以为null</li>
</ul>
</li>
<li><p>判断Optional容器中是否包含对象：</p>
<ul>
<li>boolean isPresent() : 判断是否包含对象</li>
<li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li>
</ul>
</li>
<li><p>获取Optional容器的对象:</p>
<ul>
<li>T get(): 如果调用对象包含值，返回该值，否则抛异常</li>
<li>T orElse(T other) :如果有值则将其返回，否则返回指定的other对象。</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other) :如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li>
<li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) :如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Boy boy = <span class="keyword">new</span> Boy(<span class="string">"Amy"</span>);</span><br><span class="line">    <span class="comment">//ofNullable(T t)：t可以为null</span></span><br><span class="line">    Optional&lt;Girl&gt; girl = Optional.ofNullable(boy.getGirl());</span><br><span class="line">    <span class="comment">//存在对象就打印对象信息</span></span><br><span class="line">    girl.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">    boy = <span class="keyword">new</span> Boy();</span><br><span class="line">    Optional&lt;Girl&gt; girl1 = Optional.ofNullable(boy.getGirl());</span><br><span class="line">    <span class="comment">//有对象就输出，没有则使用该对象</span></span><br><span class="line">    Girl eura = girl1.orElse(<span class="keyword">new</span> Girl(<span class="string">"Eura"</span>));</span><br><span class="line">    <span class="comment">//Eura</span></span><br><span class="line">    System.out.println(eura.getName());</span><br><span class="line">    <span class="keyword">boolean</span> present = girl1.isPresent();</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    System.out.println(present);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Girl girl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGirl</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.girl = <span class="keyword">new</span> Girl(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Girl&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
    
    <div>
    
        <div style="margin-top:30px;padding-top:20px;border-top: 1px dashed #b3a9a7;text-align:center;color: #ccc;font-size:20px;">
        本文结束&nbsp;<i class="fa fa-smile-o"></i>&nbsp;感谢您的阅读</div>
    
    </div>

    
    
    
        
      
        

<div>
<ul class="post-copyright">
  <li><strong>本文标题：</strong><a href="/2019/09/20/Java基础知识-Java8新特性/">Java基础知识-Java8新特性</a></li>
  <li class="post-copyright-author">
    <strong>本文作者： </strong><a href="/" title="访问 Wang Ting 的个人博客">Wang Ting</a></li>
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.runaccepted.com/2019/09/20/Java基础知识-Java8新特性/" title="Java基础知识-Java8新特性">https://www.runaccepted.com/2019/09/20/Java基础知识-Java8新特性/</a>
  </li>
  <li><strong>发布时间：</strong>2019年09月20日 - 14:52</li>
  <li><strong>更新时间：</strong>2021年01月31日 - 04:12</li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/19/Java基础知识-类加载机制与反射/" rel="next" title="Java基础知识-类加载机制与程序执行内存分析">
                  <i class="fa fa-chevron-left"></i> Java基础知识-类加载机制与程序执行内存分析
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/20/Servlet与JSP/" rel="prev" title="Servlet与JSP">
                  Servlet与JSP <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">2.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda语法"><span class="nav-number">2.1.</span> <span class="nav-text">Lambda语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda的延迟执行"><span class="nav-number">2.2.</span> <span class="nav-text">Lambda的延迟执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#性能浪费的日志案例"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">性能浪费的日志案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Lambda作为参数和返回值"><span class="nav-number">2.3.</span> <span class="nav-text">使用Lambda作为参数和返回值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式接口概念"><span class="nav-number">3.</span> <span class="nav-text">函数式接口概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何理解函数式接口"><span class="nav-number">3.1.</span> <span class="nav-text"> 如何理解函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是函数式-Functional-接口"><span class="nav-number">3.2.</span> <span class="nav-text"> 什么是函数式(Functional)接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FunctionalInterface注解"><span class="nav-number">3.3.</span> <span class="nav-text">@FunctionalInterface注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用函数式接口"><span class="nav-number">3.4.</span> <span class="nav-text">常用函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心接口"><span class="nav-number">3.4.1.</span> <span class="nav-text">核心接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他接口"><span class="nav-number">3.4.2.</span> <span class="nav-text">其他接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Supplier接口-T-get"><span class="nav-number">3.4.3.</span> <span class="nav-text">Supplier接口 - T get()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#求数组元素最大值"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">求数组元素最大值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer接口"><span class="nav-number">3.4.4.</span> <span class="nav-text">Consumer接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#void-accept-T-t"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">void accept(T t)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer-andThen-Consumer"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">Consumer andThen(Consumer)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化打印信息"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">格式化打印信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Predicate接口"><span class="nav-number">3.4.5.</span> <span class="nav-text">Predicate接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#boolean-test-T-t"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">boolean test(T t)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate-and-Predicate"><span class="nav-number">3.4.5.2.</span> <span class="nav-text">Predicate and(Predicate)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate-or-Predicate-“或”"><span class="nav-number">3.4.5.3.</span> <span class="nav-text">Predicate or(Predicate)“或”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate-negate-Predicate-“非”"><span class="nav-number">3.4.5.4.</span> <span class="nav-text">Predicate negate(Predicate)“非”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合信息筛选"><span class="nav-number">3.4.5.5.</span> <span class="nav-text">集合信息筛选</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function接口"><span class="nav-number">3.4.6.</span> <span class="nav-text">Function接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#R-apply-T-t"><span class="nav-number">3.4.6.1.</span> <span class="nav-text">R apply(T t)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-andThen-Function"><span class="nav-number">3.4.6.2.</span> <span class="nav-text">Function andThen(Function)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义函数模型拼接"><span class="nav-number">3.4.6.3.</span> <span class="nav-text">自定义函数模型拼接</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法引用与构造器引用"><span class="nav-number">4.</span> <span class="nav-text">方法引用与构造器引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number">4.1.</span> <span class="nav-text">方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类-实例方法名"><span class="nav-number">4.1.1.</span> <span class="nav-text">类::实例方法名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造器引用-class-new"><span class="nav-number">4.2.</span> <span class="nav-text">构造器引用 class::new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组引用-type-new"><span class="nav-number">4.3.</span> <span class="nav-text">数组引用 type[]::new</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">5.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取Stream方法"><span class="nav-number">5.2.</span> <span class="nav-text">获取Stream方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过集合Collection-stream"><span class="nav-number">5.2.1.</span> <span class="nav-text">通过集合Collection.stream()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过数组Arrays-stream-T"><span class="nav-number">5.2.2.</span> <span class="nav-text">通过数组Arrays.stream(T[])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Stream的of"><span class="nav-number">5.2.3.</span> <span class="nav-text">通过Stream的of()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建无限流"><span class="nav-number">5.2.4.</span> <span class="nav-text">创建无限流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-的中间操作"><span class="nav-number">5.3.</span> <span class="nav-text">Stream 的中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#筛选与切片"><span class="nav-number">5.3.1.</span> <span class="nav-text">筛选与切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射"><span class="nav-number">5.3.2.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">5.3.3.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-的终止操作"><span class="nav-number">5.4.</span> <span class="nav-text">Stream 的终止操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配与查找"><span class="nav-number">5.4.1.</span> <span class="nav-text">匹配与查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归约"><span class="nav-number">5.4.2.</span> <span class="nav-text">归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收集"><span class="nav-number">5.4.3.</span> <span class="nav-text">收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Collectors-实用类静态方法"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">Collectors 实用类静态方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Optional类"><span class="nav-number">6.</span> <span class="nav-text">Optional类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用方法"><span class="nav-number">6.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/a.jpg"
      alt="Wang Ting">
  <p class="site-author-name" itemprop="name">Wang Ting</p>
  <div class="site-description" itemprop="description">技术成长笔记</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/helloworld1006" title="GitHub &rarr; https://github.com/helloworld1006" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:wangtn01@163.com" title="E-Mail &rarr; mailto:wangtn01@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/5107570539/profile?rightmod=1&wvr=6&mod=personinfo" title="Weibo &rarr; https://weibo.com/5107570539/profile?rightmod=1&wvr=6&mod=personinfo" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://blog.csdn.net/sinat_32676193" title="CDSN &rarr; https://blog.csdn.net/sinat_32676193" rel="noopener" target="_blank"><i class="fa fa-fw fa-codiepie"></i>CDSN</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      最近阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/av27666354?from=search&seid=16145558899213252036" title="https://www.bilibili.com/video/av27666354?from=search&seid=16145558899213252036" rel="noopener" target="_blank">数学大观</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/av49228231?from=search&seid=1276315582965680632" title="https://www.bilibili.com/video/av49228231?from=search&seid=1276315582965680632" rel="noopener" target="_blank">王道训练营 C语言视频最新教程</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/av77638697/?p=3&t=14" title="https://www.bilibili.com/video/av77638697/?p=3&t=14" rel="noopener" target="_blank">浙江大学-研究生机器学习课程</a>
        </li>
      
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Ting</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span>网站总字数&nbsp;<span>
    <span title="站点总字数">461k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span>阅读总时长&nbsp;<span>
    <span title="站点阅读时长">12:48</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.3.0</div>
  <span class="post-meta-divider">|</span> -->
  <span id="sitetime"></span>
<script language=javascript>
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2018,12,23,00,00,00); //北京时间2018-12-23 00:00:00
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行 "+ diffYears+" 年 "+ diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
  siteTime();
</script>


        
<div class="busuanzi-count">
  <script async src="/js/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span>本站总访问量&nbsp;</span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span>本站访客数&nbsp;</span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
<script src="/js/utils.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script><script src="/js/bookmark.js?v=7.3.0"></script>



  








  <script src="/js/local-search.js?v=7.3.0"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>






  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


<script>
NexT.utils.getScript('/js/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: true,
    appId: 'XYcjlUMI3JT5ggb51F8oIkwy-gzGzoHsz',
    appKey: 'OHyypRDYnlmDqCN7vrH85KrL',
    placeholder: '撰写评论',
    avatar: 'mm# Gravatar style',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: 'zh-cn',
    avatar_cdn: 'https://www.gravatar.com/avatar/',
    path: location.pathname
  });
}, window.Valine);
  function ssl_avatar($avatar) {
     $avatar = preg_replace('/.*\/avatar\/(.*)\?s=([\d]+)&.*/','<img src="https://secure.gravatar.com/avatar/$1?s=$2" class="avatar avatar-$2" height="$2" width="$2">',$avatar);
     return $avatar;
  }
</script>

  
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":125,"height":290},"mobile":{"show":true},"react":{"opacity":0.7},"dialog":{"enable":false,"hitokoto":false},"log":false});</script></body>
</html>
